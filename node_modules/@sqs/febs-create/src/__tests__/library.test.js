const childProcess = require('child_process');
const nodePlop = require('node-plop');
const path = require('path');
const { getPackageNameWithoutSqsScope, writeJsonFileSync } = require('../utils');
const cloneFebsExample = require('../actions/cloneFebsExample');
const { version } = require('../../package.json');

// Base constants for tests
const MOCK_PROJECT_ROOT = '/';
const { EXAMPLES } = cloneFebsExample;
const MOCK_DATE = '2021-04-14T11:01:58.135Z';
const MOCK_DATE_UNIX = new Date(MOCK_DATE).getTime();
const DEFAULT_OPTIONS = {
  name: '@sqs/my-new-project',
  description: 'It creates foo',
  monorepoTool: 'none',
  projectType: 'library',
  language: 'typescript',
  directory: '/packages/my-new-project'
};

// Setup Plop for testing
const plop = nodePlop(path.resolve(__dirname, '..', 'logic', 'library.js'));
const create = plop.getGenerator('create');

// Mocks
jest.mock('child_process');
jest.mock('fs', () => ({
  ...jest.requireActual('fs'),
  mkdirSync: jest.fn()
}));
jest.mock('../utils', () => ({
  ...jest.requireActual('../utils'),
  requireConfig: (filePath) => require(`../__fixtures__/${filePath}`),
  writeJsonFileSync: jest.fn()
}));
jest.mock('@microsoft/rush-lib', () => ({
  RushConfiguration: {
    loadFromDefaultLocation: () => ({
      rushJsonFile: `${MOCK_PROJECT_ROOT}rush.json`,
      projectsByName: new Map([
        ['@sqs/bar', { name: '@sqs/bar', description: 'Bar' }]
      ])
    })
  }
}));

// Tests
describe('Run febs create', () => {
  beforeEach(() => {
    jest.spyOn(childProcess, 'execSync');
    jest
      .spyOn(global.Date, 'now')
      .mockImplementationOnce(() =>
        new Date(MOCK_DATE).valueOf()
      );
  });

  const withOptions = overrides => ({
    ...DEFAULT_OPTIONS,
    ...overrides
  });

  const assertProjectCreate = (options) => {
    const packageNameWithoutScope = getPackageNameWithoutSqsScope(options.name);
    const outputDirectoryParent = path.dirname(options.directory);
    const exampleRepo = EXAMPLES[options.projectType][options.language];

    expect(childProcess.execSync)
      .toHaveBeenCalledWith(
        `git clone --depth 1 ${exampleRepo} ${packageNameWithoutScope}`,
        {
          cwd: outputDirectoryParent,
          stdio: [0, 1, 2]
        }
      );
  };

  const assertPackageJsonUpdate = (options, content) => {
    expect(writeJsonFileSync).toHaveBeenCalledWith(
      `${options.directory}/package.json`,
      {
        name: options.name,
        description: options.description,
        version: '1.0.0',
        starter: {
          commit: '',
          createdAt: MOCK_DATE_UNIX,
          febsCreateVersion: version,
          generated: true,
          language: 'typescript',
          projectType: 'library',
          remote: 'git@github.com:sqsp/febs-example-library-ts.git',
        },
        ...content
      }
    );
  };

  it('Should run for @sqs scoped projects', async () => {
    const options = withOptions();
    await create.runActions(options);
    assertProjectCreate(options);
    assertPackageJsonUpdate(options);
  });

  it('Should run for unscoped projects', async () => {
    const options = withOptions({
      name: 'my-new-project',
    });
    await create.runActions(options);
    assertProjectCreate(options);
    assertPackageJsonUpdate(options);
  });

  it('If rush project, should add to rush.json and update clean script', async () => {
    const options = withOptions({ monorepoTool: 'rush' });
    await create.runActions(options);
    assertProjectCreate(options);

    // Ensure project has been added to the rush.json
    expect(writeJsonFileSync).toHaveBeenCalledWith(
      '/rush.json',
      {
        projects: [{
          packageName: '@sqs/bar',
          projectFolder: 'packages/bar'
        }, {
          packageName: options.name,
          projectFolder: path.relative(MOCK_PROJECT_ROOT, options.directory)
        }]
      }
    );

    // Ensure removal of .rush directory added to clean script
    assertPackageJsonUpdate(options, {
      scripts: {
        clean: 'rm -rf .rush'
      }
    });
  });

  it('Should fail if project by same name exists', async () => {
    const options = withOptions({ monorepoTool: 'rush', name: '@sqs/bar' });
    const result = await create.runActions(options);

    expect(result.failures[0])
      .toEqual(new Error('Package with name @sqs/bar already configured within this repository'));
  });

  it('Should fail if project type doesnt exist', async () => {
    const options = withOptions({ projectType: 'library', language: 'rust' });
    const result = await create.runActions(options);

    expect(result.failures[0])
      .toEqual(new Error('No template for a rust library. Supported languages typescript,javascript'));
  });
});