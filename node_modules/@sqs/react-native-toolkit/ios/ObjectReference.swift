import Foundation

func synchronized<T>(_ lock: AnyObject, _ body: () throws -> T) rethrows -> T {
    objc_sync_enter(lock)
    defer { objc_sync_exit(lock) }
    return try body()
}

@objc(ObjectReference)
@objcMembers
open class ObjectReference: NSObject {

    struct WeakReference {
        weak var object: AnyObject?
    }

    static var objects = [String: WeakReference]()

    class ReferenceID {
        let id = UUID().uuidString
        deinit {
            synchronized(objects as AnyObject) {
                objects[id] = nil
            }
        }
    }

    public static func reference<T: AnyObject>(forObject: T) -> String {
        return synchronized(objects as AnyObject) {
            // check for an existing object reference and return the id
            if let referenceID = objc_getAssociatedObject(forObject, &AssociationKeys.objectReferenceID) as? ReferenceID {
                return referenceID.id
            }

            // create a new object reference
            let referenceID = ReferenceID()
            objects[referenceID.id] = WeakReference(object: forObject)
            objc_setAssociatedObject(forObject, &AssociationKeys.objectReferenceID, referenceID, .OBJC_ASSOCIATION_RETAIN)
            return referenceID.id
        }
    }

    public static func object<T: AnyObject>(forReference: String) -> T? {
        return synchronized(objects as AnyObject) {
            return objects[forReference]?.object as? T
        }
    }

    public static func nsobject(forReference: String) -> NSObject? {
        let object: NSObject? = self.object(forReference: forReference)
        return object
    }

    private struct AssociationKeys {
        static var objectReferenceID: UInt8 = 0
    }
}
