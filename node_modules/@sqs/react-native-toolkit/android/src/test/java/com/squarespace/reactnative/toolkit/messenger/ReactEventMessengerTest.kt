package com.squarespace.reactnative.toolkit.messenger

import com.facebook.react.bridge.ReactContext
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.nhaarman.mockitokotlin2.any
import com.nhaarman.mockitokotlin2.anyOrNull
import com.nhaarman.mockitokotlin2.argumentCaptor
import com.nhaarman.mockitokotlin2.doReturn
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.times
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import com.squarespace.android.commons.util.Logger
import com.squarespace.reactnative.toolkit.context.ReactContextProvider
import junit.framework.Assert.assertEquals
import org.junit.Before
import org.junit.Test

class ReactEventMessengerTest {

  private val mockContextProvider: ReactContextProvider = mock()

  private val mockContext: ReactContext = mock()

  private val mockEventEmitter: DeviceEventManagerModule.RCTDeviceEventEmitter = mock()

  private val mockPayload: ReadableMap = mock()

  private val mockLogger: Logger = mock()

  private lateinit var testMessenger: ReactEventMessenger

  @Before
  fun setup() {
    doReturn(mockEventEmitter)
      .whenever(mockContext)
      .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)

    testMessenger = ReactEventMessenger(mockContextProvider)
    testMessenger.log = mockLogger
  }

  @Test
  fun `send message uses deferred context`() {
    testMessenger.sendMessage("test", mockPayload)

    verify(mockContextProvider, times(1))
      .withContext(any())
  }

  @Test
  fun `send message with payload`() {
    testMessenger.sendMessage("test", mockPayload)

    val action = argumentCaptor<(ReactContext) -> Unit> {
      verify(mockContextProvider, times(1))
        .withContext(capture())
    }.firstValue

    action.invoke(mockContext)

    verify(mockEventEmitter, times(1))
      .emit("test", mockPayload)
  }

  @Test
  fun `send message without payload`() {
    testMessenger.sendMessage("test")

    val action = argumentCaptor<(ReactContext) -> Unit> {
      verify(mockContextProvider, times(1))
        .withContext(capture())
    }.firstValue

    action.invoke(mockContext)

    verify(mockEventEmitter, times(1))
      .emit("test", null)
  }

  @Test
  fun `send message order preserved`() {
    val testEvents = listOf("test1", "test2", "test3")

    testEvents.forEach { testMessenger.sendMessage(it) }

    val actions = argumentCaptor<(ReactContext) -> Unit> {
      verify(mockContextProvider, times(3))
        .withContext(capture())
    }

    // Let's assume somehow the third action (associated with "test3) gets triggered first.
    // This is fine because subsequent invocations (regardless of order) will act on an empty queue
    actions.thirdValue.invoke(mockContext)

    val events = argumentCaptor<String> {
      verify(mockEventEmitter, times(3))
        .emit(capture(), anyOrNull())
    }

    assertEquals(testEvents, events.allValues)
  }

  @Test
  fun `when message is sent then log occurs`() {
    testMessenger.sendMessage("test", mockPayload)

    val action = argumentCaptor<(ReactContext) -> Unit> {
      verify(mockContextProvider, times(1))
        .withContext(capture())
    }.firstValue

    action.invoke(mockContext)

    verify(mockLogger, times(1))
      .debug(anyOrNull(), any<() -> String?>())
  }
}
