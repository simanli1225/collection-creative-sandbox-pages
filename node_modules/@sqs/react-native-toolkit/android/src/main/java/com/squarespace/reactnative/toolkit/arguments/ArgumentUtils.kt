package com.squarespace.reactnative.toolkit.arguments

import android.os.Bundle
import androidx.annotation.RestrictTo
import androidx.annotation.VisibleForTesting
import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.JavaOnlyArray
import com.facebook.react.bridge.JavaOnlyMap
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.bridge.ReadableMapKeySetIterator
import com.facebook.react.bridge.ReadableType
import com.facebook.react.bridge.WritableArray
import com.facebook.react.bridge.WritableMap
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import com.google.gson.JsonPrimitive

/**
 * Extensions on top of React Native [Arguments] helper.
 */
class ArgumentUtils {
  companion object {

    /**
     * Flip this in testing to allow for creating java only data structures.
     * The default is set to `true` and you should always use `true` outside of testing.
     */
    @RestrictTo(RestrictTo.Scope.TESTS)
    var allowNativeDataStructures = true

    /**
     * @see [Arguments.createMap]
     */
    fun createMap(): WritableMap {
      return if (allowNativeDataStructures) {
        Arguments.createMap()
      } else {
        JavaOnlyMap()
      }
    }

    /**
     * @see [Arguments.createArray]
     */
    fun createArray(): WritableArray {
      return if (allowNativeDataStructures) {
        Arguments.createArray()
      } else {
        JavaOnlyArray()
      }
    }

    /**
     * Convert a [JsonPrimitive] into a raw value that can be used as a React Argument.
     * This will return either a [String], [Boolean], a value associated with [fromNumber],
     * or null if the primitive couldn't be parsed
     */
    fun fromJsonPrimitive(jsonPrimitive: JsonPrimitive): Any? =
      jsonPrimitive.run {
        when {
          isNumber -> fromNumber(asNumber)
          isString -> asString
          isBoolean -> asBoolean
          else -> null
        }
      }

    /**
     * Convert a [Number] into a raw value that can be used as a React Argument.
     * This will return either a [Double] or an [Int] as these are the only values compatible with javascript.
     *
     * See: https://github.com/facebook/react-native/issues/9685
     */
    private fun fromNumber(number: Number): Any =
      when (number) {
        is Long, is Double, is Float -> number.toDouble()
        is Int -> number.toInt()
        else -> parseNumber(number)
      }

    /**
     * Use the [Number] interface to parse the smallest fit RN compatible type.
     * @throws NumberFormatException if there was an issue parsing the number
     */
    @Throws(NumberFormatException::class)
    private fun parseNumber(number: Number): Any {
      // Extract the number as a String because LazilyParsedNumber makes undesired assumptions
      val value = number.toString()

      return runCatching { value.toInt() }
        .recoverCatching { value.toDouble() }
        .getOrThrow()
    }

    /**
     * Convert a [JsonElement] into a type that can be used as a React Argument
     * This will return either a [WritableMap], [WritableArray], a value associated with [fromJsonPrimitive],
     * or null if the element couldn't be parsed
     */
    fun fromJsonElement(jsonElement: JsonElement): Any? =
      jsonElement.run {
        when {
          isJsonPrimitive -> fromJsonPrimitive(asJsonPrimitive)
          isJsonObject -> fromJsonObject(asJsonObject)
          isJsonArray -> fromJsonArray(asJsonArray)
          else -> null
        }
      }

    /**
     * Convert a [JsonObject] into a [WritableMap] to be used as a React Argument
     */
    fun fromJsonObject(jsonObject: JsonObject): WritableMap {
      val writableMap = ArgumentUtils.createMap()

      jsonObject.entrySet().forEach { entry ->
        entry.apply {
          when {
            value.isJsonPrimitive -> fromJsonPrimitive(value.asJsonPrimitive)?.let { writableMap.putPrimitive(key, it) }
            value.isJsonObject -> writableMap.putMap(key, fromJsonObject(value.asJsonObject))
            value.isJsonArray -> writableMap.putArray(key, fromJsonArray(value.asJsonArray))
            value.isJsonNull -> writableMap.putNull(key)
          }
        }
      }

      return writableMap
    }

    /**
     * Convert a [JsonObject] into a [WritableArray] to be used as a React Argument
     */
    fun fromJsonArray(jsonArray: JsonArray): WritableArray {
      val writableArray = ArgumentUtils.createArray()

      jsonArray.forEach { element ->
        when {
          element.isJsonPrimitive -> fromJsonPrimitive(element.asJsonPrimitive)?.let { writableArray.pushPrimitive(it) }
          element.isJsonObject -> writableArray.pushMap(fromJsonObject(element.asJsonObject))
          element.isJsonArray -> writableArray.pushArray(fromJsonArray(element.asJsonArray))
          element.isJsonNull -> writableArray.pushNull()
        }
      }

      return writableArray
    }

    /**
     * Convert a [String] to a immutable [JsonPrimitive]
     */
    fun toJsonPrimitive(string: String) = JsonPrimitive(string)

    /**
     * Convert a [Boolean] to a immutable [JsonPrimitive]
     */
    fun toJsonPrimitive(bool: Boolean) = JsonPrimitive(bool)

    /**
     * Convert a [Number] to a immutable [JsonPrimitive]
     */
    fun toJsonPrimitive(number: Number): JsonPrimitive {
      return if (number.isWholeNumber()) {
        JsonPrimitive(number.toLong())
      } else {
        JsonPrimitive(number)
      }
    }

    /**
     * Adds `null` to the [JsonObject]
     */
    private fun JsonObject.addNull(key: String) {
      add(key, JsonNull.INSTANCE)
    }

    /**
     * Convert a [ReadableMap] to a mutable [JsonObject]
     */
    fun toJsonObject(map: ReadableMap): JsonObject {
      fun JsonObject.convert(key: String) {
        when (map.getType(key)) {
          ReadableType.Null -> addNull(key)
          ReadableType.Boolean -> map.getBoolean(key)
            .let { toJsonPrimitive(it) }
            .let { add(key, it) }
          ReadableType.Number -> map.getNumber(key)
            .let { toJsonPrimitive(it) }
            .let { add(key, it) }
          ReadableType.String -> map.getString(key)
            ?.let { toJsonPrimitive(it) }
            ?.let { add(key, it) }
            ?: addNull(key)
          ReadableType.Map -> map.getMap(key)
            ?.let { toJsonObject(it) }
            ?.let { add(key, it) }
            ?: addNull(key)
          ReadableType.Array -> map.getArray(key)
            ?.let { toJsonArray(it) }
            ?.let { add(key, it) }
            ?: addNull(key)
          else -> addNull(key)
        }
      }

      // recursively traverse the ReadableMap
      // convert each key into its json equivalent
      // then add it to the json object
      return JsonObject().apply {
        for (key in map.keySetIterator()) convert(key)
      }
    }

    /**
     * Adds `null` to the [JsonArray]
     */
    private fun JsonArray.addNull() {
      add(JsonNull.INSTANCE)
    }

    /**
     * Convert a [ReadableArray] to a mutable [JsonArray]
     */
    fun toJsonArray(array: ReadableArray): JsonArray {
      fun JsonArray.convert(index: Int) {
        when (array.getType(index)) {
          ReadableType.Null -> addNull()
          ReadableType.Boolean -> array.getBoolean(index)
            .let { toJsonPrimitive(it) }
            .let { add(it) }
          ReadableType.Number -> array.getNumber(index)
            .let { toJsonPrimitive(it) }
            .let { add(it) }
          ReadableType.String -> array.getString(index)
            ?.let { toJsonPrimitive(it) }
            ?.let { add(it) }
            ?: addNull()
          ReadableType.Map -> array.getMap(index)
            ?.let { toJsonObject(it) }
            ?.let { add(it) }
            ?: addNull()
          ReadableType.Array -> array.getArray(index)
            ?.let { toJsonArray(it) }
            ?.let { add(it) }
            ?: addNull()
          else -> addNull()
        }
      }

      // recursively traverse the ReadableArray
      // convert each key into its json equivalent
      // then append it to the json array
      return JsonArray().apply {
        for (index in 0 until array.size()) convert(index)
      }
    }

    /**
     * Extension on [ReadableMapKeySetIterator]
     * Adds enhanced for loop [Iterator] functionality.
     */
    private operator fun ReadableMapKeySetIterator.iterator(): Iterator<String> {
      return object : Iterator<String> {
        override fun hasNext() = hasNextKey()
        override fun next() = nextKey()
      }
    }
  }
}

private fun Number.isWholeNumber(): Boolean {
  return this.toLong().toDouble() == this.toDouble()
}

/**
 * Returns a long if the number is a whole number, else a double
 * See: https://github.com/facebook/react-native/issues/4141
 */
fun ReadableMap.getNumber(key: String): Number {
  return getDouble(key).let {
    if (it.isWholeNumber()) it.toLong() else it
  }
}

/**
 * Returns a long if the number is a whole number, else a double
 * See: https://github.com/facebook/react-native/issues/4141
 */
fun ReadableArray.getNumber(index: Int): Number {
  return getDouble(index).let {
    if (it.isWholeNumber()) it.toLong() else it
  }
}

/**
 * Extension on [WritableMap]
 * Allows for putting arbitrary primitives into the map.
 */
fun WritableMap.putPrimitive(key: String, any: Any) {
  when (any) {
    is Double -> putDouble(key, any)
    is Int -> putInt(key, any)
    is String -> putString(key, any)
    is Boolean -> putBoolean(key, any)
  }
}

/**
 * Extension on [WritableArray]
 * Allows for putting arbitrary primitives into the array.
 */
fun WritableArray.pushPrimitive(any: Any) {
  when (any) {
    is Double -> pushDouble(any)
    is Int -> pushInt(any)
    is String -> pushString(any)
    is Boolean -> pushBoolean(any)
  }
}

/**
 * Extension on [ReadableMap]
 * Fixes issue where all Numbers are treated as Doubles, even if they should be Longs/Ints.
 * Makes any whole numbers in the resulting map Longs.
 */
@SuppressWarnings("unchecked") //ReadableMap.toMap only produces Map<String, Any>
fun ReadableMap.toMapCorrect(): Map<String, Any> {
  return toHashMap().let {
    makeWholeNumberValuesLongs(it) as Map<String, Any>
  }
}

@VisibleForTesting
fun makeWholeNumberValuesLongs(map: Map<*, *>): Map<Any?, Any?> {
  return map.mapValues {
    val value = it.value
    when (value) {
      is Number -> if (value.isWholeNumber()) value.toLong() else value
      is Map<*, *> -> makeWholeNumberValuesLongs(value)
      else -> value
    }
  }
}

/**
 * Extension on [WritableArray].
 * Adds an API to [WritableArray] that is similar to Kotlin's stdlib listOf().
 */
@Throws(IllegalArgumentException::class)
fun WritableArray.of(vararg elements: Any?): WritableArray {
  return this.apply {
    elements.forEach {
      when (it) {
        null -> pushNull()
        is Int -> pushInt(it)
        is Double -> pushDouble(it)
        is Boolean -> pushBoolean(it)
        is String -> pushString(it)
        is WritableArray -> pushArray(it)
        is WritableMap -> pushMap(it)
        else -> throw IllegalArgumentException("Unsupported Type for WritableArray: $it")
      }
    }
  }
}

/**
 * Extension on [WritableMap].
 * Adds an API to [WritableMap] that is similar to Kotlin's stdlib mapOf().
 */
@Throws(IllegalArgumentException::class)
fun WritableMap.of(vararg elements: Pair<String, Any?>): WritableMap {
  return this.apply {
    elements.forEach { (key, value) ->
      when (value) {
        null -> putNull(key)
        is Int -> putInt(key, value)
        is Double -> putDouble(key, value)
        is Boolean -> putBoolean(key, value)
        is String -> putString(key, value)
        is WritableArray -> putArray(key, value)
        is WritableMap -> putMap(key, value)
        else -> throw IllegalArgumentException("Unsupported Type for 'value' in WritableMap: key=$key, value=$value")
      }
    }
  }
}

/**
 * Extension on [WritableMap].
 * Wraps [Arguments.toBundle] to provide better nullability handling in Kotlin. Since this extension method can only be
 * called on a non-null object, it is guaranteed to never return a null value.
 */
fun WritableMap.toBundle(): Bundle {
  return Arguments.toBundle(this)!! // will never return null since the map is not null
}
