package com.squarespace.reactnative.toolkit;

import java.util.UUID;

import com.facebook.react.ReactInstanceManager;
import com.facebook.react.ReactRootView;

import android.content.Context;
import android.os.Bundle;
import android.util.AttributeSet;
import android.view.View;
import androidx.annotation.CallSuper;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * Template view for react native components.
 * <p>
 * Inherit this class to create custom view wrappers around react native views.
 * The only hard requirements are that you provide a module name and props.
 * </p>
 * <p>
 * This {@link BaseReactView} is associated with a {@link ReactViewRegistry} upon calling
 * {@link #initialize(ReactViewRegistry, ReactInstanceManager, boolean)}.
 * This allows react native to find the and communicate with this native wrapper at a later point in time.
 * </p>
 *
 * Typical usage would be:
 *
 * <pre>
 *   // Create a concrete implementation.
 *   class MyReactView extends BaseReactView {
 *     protected String getModuleName() { return "MyReactComponentName"; }
 *     protected Bundle getProps() { return new Bundle(); }
 *   }
 * </pre>
 *
 * <pre>
 *   // Instantiate and initialize the view.
 *   MyReactView view = new MyReactView(context);
 *   view.initialize(reactViewRegistry, reactInstanceManager);
 * </pre>
 *
 * <strong>Note</strong> :
 * <p>
 * React components, in general, can be expensive to render. {@link BaseReactView} is aware of this
 * and waits until this view is worth rendering before starting the underlying react application that
 * powers it. This means you can place a react component in your view hierarchy with a visibility
 * of {@link View#GONE} for relatively cheap. To kick start the underlying react application, simply
 * change the visibility to {@link View#VISIBLE} or {@link View#INVISIBLE} after the view has been
 * attached to the window.
 * </p>
 */
public abstract class BaseReactView extends ReactRootView {

  protected static String REFERENCE_KEY = "reference";

  private ReactViewRegistry reactViewRegistry;

  private ReactInstanceManager reactInstanceManager;

  private final UUID uuid = UUID.randomUUID();

  private boolean hasStarted = false;

  public UUID getUUID() {
    return uuid;
  }

  public BaseReactView(@NonNull Context context) {
    super(context);
  }

  public BaseReactView(@NonNull Context context, @Nullable AttributeSet attrs) {
    super(context, attrs);
  }

  public BaseReactView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
  }

  /**
   * Initializes this {@link BaseReactView}.
   *
   * Immediately starts the underlying react application if this view is not marked as {@link View#GONE}
   * or if <em>forceImmediate</em> is used.
   *
   * @param viewRegistry using the provided registry, this view registers itself when attached to the window.
   * When detached from the window, this view unregisters itself from the registry.
   * @param instanceManager used to drive the underlying react application
   * @param forceImmediate <em>true</em> to force start the underlying application immediately.
   * <em>false</em> to leverage
   */
  public void initialize(
      @NonNull ReactViewRegistry viewRegistry,
      @NonNull ReactInstanceManager instanceManager,
      boolean forceImmediate
  ) {
    // React tracks theirs views by ID. If we provide React with the root view,
    // then we most likely are not assigning an ID and/or caring about the ID of the view.
    // We set the view ID to NO_ID so that, React can override the ID to track the view.
    this.setId(View.NO_ID);
    reactViewRegistry = viewRegistry;
    reactInstanceManager = instanceManager;
    reactViewRegistry.registerView(uuid, this);
    if (forceImmediate || canStart()) {
      startReactApplication();
    }
  }

  /**
   * Override to initialize properties that should be sent to the js component constructor.
   */
  @CallSuper
  protected Bundle getInitialProperties() {
    Bundle bundle = getProps();
    bundle.putString(REFERENCE_KEY, getUUID().toString());
    return bundle;
  }

  @Override
  protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    if (canStart()) {
      startReactApplication();
    }
    if (reactViewRegistry != null) {
      reactViewRegistry.registerView(uuid, this);
    }
  }

  @Override
  protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
    super.onVisibilityChanged(changedView, visibility);
    if (canStart()) {
      startReactApplication();
    }
  }

  /**
   * Schedules rendering for the underlying react components.
   *
   * @throws IllegalStateException if this {@link BaseReactView} is not configured properly
   * @see #startReactApplication(ReactInstanceManager, String, Bundle)
   */
  protected void startReactApplication() throws IllegalStateException {
    if (hasStarted) {
      return;
    }

    if (reactInstanceManager == null || reactViewRegistry == null) {
      final String reason = "BaseReactView is missing required components. Did you remember to call initialize(...)";
      throw new IllegalStateException(reason);
    }

    startReactApplication(reactInstanceManager, getModuleName(), getInitialProperties());
    hasStarted = true;
  }

  /**
   * Check to see if it's worth starting the underlying react application for this view.
   *
   * @return <em>true</em> if this view is in a state that is worth rendering.
   * <em>false</em> if this rendering this view is a waste of resources.
   */
  private boolean canStart() {
    return isAttachedToWindow() && (getVisibility() == View.VISIBLE || getVisibility() == View.INVISIBLE);
  }

  @Override
  protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (reactViewRegistry != null) {
      reactViewRegistry.unregisterView(uuid);
    }
    unmountReactApplication();
  }

  protected abstract String getModuleName();

  protected abstract Bundle getProps();
}
