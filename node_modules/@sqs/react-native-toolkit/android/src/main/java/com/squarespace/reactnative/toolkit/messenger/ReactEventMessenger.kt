package com.squarespace.reactnative.toolkit.messenger

import androidx.annotation.MainThread
import androidx.annotation.VisibleForTesting
import com.facebook.react.bridge.ReactContext
import com.facebook.react.bridge.ReadableArray
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.squarespace.android.commons.util.Logger
import com.squarespace.reactnative.toolkit.context.ReactContextProvider
import java.util.LinkedList

private typealias EventMessage = Pair<String, Any?>

/**
 * Manages broadcasts of React Native RCT Events.
 *
 * This [ReactEventMessenger] ensures that we don't attempt to emit events before the [ReactContext] is initialized.
 * It also ensures that messages emitted prior to initialization won't be dropped. Any messages sent before
 * initialization will be retried when the [ReactContext] is available.
 *
 * Note: This class is not guaranteed to function properly if called from any thread other than the main thread.
 */
@MainThread
open class ReactEventMessenger(private val contextProvider: ReactContextProvider) {

  // This shouldn't require synchronization as this should only be accessed by the main thread.
  // Synchronizing this will be expensive as it's called pretty often.
  // I TRUST Y'ALL! If you use this outside of the main thread,
  // then a pack of wild alpacas MIGHT destroy your phone.
  private val messageQueue = LinkedList<EventMessage>()

  @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
  internal var log = Logger(ReactEventMessenger::class)

  /**
   * Send an RCT event to react native. Message sending may be deferred until after react native initialization.
   *
   * In the case of multiple deferred messages, the order in which this function was called will be preserved.
   *
   * @param eventName name of the event
   * @param payload any extra argument type supported by react native (ie [ReadableMap], [ReadableArray], [String], etc)
   */
  fun sendMessage(eventName: String, payload: Any? = null) {
    // add this to the queue to preserve order in case context isn't ready
    messageQueue.add(eventName to payload)
    // only drain the queue when the context is ready
    contextProvider.withContext { sendAllMessages(it) }
  }

  private fun sendAllMessages(context: ReactContext) {
    messageQueue.forEach { (eventName, payload) ->
      sendMessage(context, eventName, payload)
    }

    messageQueue.clear()
  }

  private fun sendMessage(context: ReactContext, eventName: String, payload: Any?) {
    log.debug { "Emitting event $eventName with payload $payload" }

    context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
      .emit(eventName, payload)
  }
}
