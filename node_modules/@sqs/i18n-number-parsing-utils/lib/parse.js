"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNumber = void 0;
var loose_matching_1 = require("./loose-matching");
var parseNumber = function (value, properties) {
    var negative, number, prefix, suffix;
    var grammar = [
        ['nan'],
        ['prefix', 'infinity', 'suffix'],
        ['prefix', 'number', 'suffix'],
        ['negativePrefix', 'infinity', 'negativeSuffix'],
        ['negativePrefix', 'number', 'negativeSuffix'],
    ];
    var invertedSymbolMap = properties[0];
    var invertedNuDigitsMap = properties[1] || {};
    var tokenizer = properties[2];
    value = (0, loose_matching_1.looseMatching)(value);
    function parse(type) {
        return function (lexeme) {
            lexeme = lexeme
                .split('')
                .map(function (character) {
                return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;
            })
                .join('');
            switch (type) {
                case 'infinity':
                    number = Infinity;
                    break;
                case 'nan':
                    number = NaN;
                    break;
                case 'number':
                    lexeme = lexeme.replace(/,/g, '');
                    number = +lexeme;
                    break;
                case 'prefix':
                case 'negativePrefix':
                    prefix = lexeme;
                    break;
                case 'suffix':
                    suffix = lexeme;
                    break;
                case 'negativeSuffix':
                    suffix = lexeme;
                    negative = true;
                    break;
                default:
                    throw new Error('Internal error');
            }
            return '';
        };
    }
    function tokenizeNParse(val) {
        return grammar.some(function (statement) {
            return (statement.every(function (type) {
                if (val.match(tokenizer[type]) === null) {
                    return false;
                }
                val = val.replace(tokenizer[type], parse(type));
                return true;
            }) && !val.length);
        });
    }
    var valid = tokenizeNParse(value, grammar);
    if (!valid || isNaN(number)) {
        return NaN;
    }
    var prefixNSuffix = '' + prefix + suffix;
    if (prefixNSuffix.indexOf('%') !== -1) {
        number /= 100;
    }
    else if (prefixNSuffix.indexOf('\u2030') !== -1) {
        number /= 1000;
    }
    if (negative) {
        number *= -1;
    }
    return number;
};
exports.parseNumber = parseNumber;
