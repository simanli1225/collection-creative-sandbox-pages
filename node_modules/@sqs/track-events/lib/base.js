import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import cookie from '@sqs/cookie-cutter';
import qs from 'querystring';
import uuid from 'uuid/v4';
import safeLocalStorage from './safeLocalStorage';
import { ClientConfig, EventSource, SourceEnvironment } from './types';
import { maybeWindow } from './util';
export { ClientConfig, EventSource, SourceEnvironment };

/**
 * BaseClient
 * A base class that provides the core shared functionality of the event trackers
 */
var BaseClient = /*#__PURE__*/function () {
  function BaseClient() {
    var _maybeWindow, _maybeWindow$bind;
    _classCallCheck(this, BaseClient);
    // Bind sendBeacon to the right context
    // https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
    _defineProperty(this, "_safeSendBeacon", (_maybeWindow = maybeWindow()) === null || _maybeWindow === void 0 || (_maybeWindow = _maybeWindow.navigator) === null || _maybeWindow === void 0 || (_maybeWindow = _maybeWindow.sendBeacon) === null || _maybeWindow === void 0 || (_maybeWindow$bind = _maybeWindow.bind) === null || _maybeWindow$bind === void 0 ? void 0 : _maybeWindow$bind.call(_maybeWindow, window.navigator));
  }
  return _createClass(BaseClient, [{
    key: "track",
    value:
    /**
     * Format an event for analytics and send to their endpoint
     * @param {Object} event - The object with the event data
     * @returns {Promise} - Resolved when request is complete
     */
    function track() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (this._config.fireEvents === false) {
        return Promise.resolve();
      }
      var payload = this._generatePayload(event);
      if (this._config.validateMode) {
        return this._validateEvent(payload);
      } else if (!this._config.url) {
        return Promise.resolve();
      }
      if (!payload) {
        return Promise.reject(new Error('no payload'));
      }
      if (this._config.useBeacon) {
        return this._sendBeacon(payload);
      }
      return this._sendXhr(payload);
    }

    /**
     * Public alias for getting analytics ID
     * This was aliased vs renaming existing method to prevent breaking existing implementations
     */
  }, {
    key: "getAnalyticsId",
    value: function getAnalyticsId() {
      return this._getAnalyticsId();
    }

    /**
     * Get analyticsId from state, cookie or localStorage
     * Cookie takes priority, disparate IDs will be reset accordingly
     * @returns {string} - The analyticsId retrieved
     */
  }, {
    key: "_getAnalyticsId",
    value: function _getAnalyticsId() {
      var queryParams = new URLSearchParams(window.location.search);
      var queryValue = this._validateAnalyticsId(queryParams.get('analytics_id'));
      var cookieValue = this._validateAnalyticsId(cookie.get(this._config.storageKey));
      var localValue = this._validateAnalyticsId(this._getLocalStorageItem());
      var stateValue = this._validateAnalyticsId(this._analyticsId);
      var finalValue = queryValue || cookieValue || localValue || stateValue || uuid();
      if (this._config.setAnalyticsCookie) {
        this._setAnalyticsId(finalValue);
      }
      return finalValue;
    }

    /**
     * Get the analyticsId localStorage item
     * Will check if expiration has passed and delete the item if so
     * This is needed to comply with cookie compliance regulations
     * @returns {string} - The analyticsId retrieved
     */
  }, {
    key: "_getLocalStorageItem",
    value: function _getLocalStorageItem() {
      var pastExpiration = false;
      var expiration = safeLocalStorage.getItem(this._config.expirationKey);
      if (expiration) {
        var now = new Date();
        var expires = new Date(expiration);
        pastExpiration = now > expires;
      }
      if (pastExpiration) {
        safeLocalStorage.removeItem(this._config.storageKey);
        safeLocalStorage.removeItem(this._config.expirationKey);
        return null;
      }
      return safeLocalStorage.getItem(this._config.storageKey);
    }

    /**
     * Get the page pathname, stripped of any trailing slashes
     * @returns {string} - The pathname retrieved
     */
  }, {
    key: "_getNormalizedPathname",
    value: function _getNormalizedPathname() {
      var pathname = window.location.pathname;
      if (pathname[pathname.length - 1] === '/') {
        pathname = pathname.substring(0, pathname.length - 1);
      }
      return pathname;
    }

    /**
     * Generate the event payload
     * @param {Object} event - The object with the event data
     * @returns {Object} - The fully constructed event payload
     */
  }, {
    key: "_generatePayload",
    value: function _generatePayload(event) {
      return event;
    }

    /**
     * Logs messages to the console if logging is enabled
     * @param {string} message - The message to log
     */
  }, {
    key: "_log",
    value: function _log(message) {
      if (this._config.logging) {
        console.log(message);
      }
    }

    /**
     * Send a new event via beacon
     * For more info see https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API
     * This method should not be called directly; use track() instead
     * @param {Object} payload - The event payload to send
     * @returns {Promise} - Resolved when request has been made
     */
  }, {
    key: "_sendBeacon",
    value: function _sendBeacon(payload) {
      var headers = {
        type: 'application/x-www-form-urlencoded'
      };
      var payloadBlob = new Blob([qs.stringify(payload)], headers);
      try {
        // While this may be undefined, the catch will handle that in addition to browser issues.
        this._safeSendBeacon(this._config.url, payloadBlob);
        return Promise.resolve();
      } catch (error) {
        if (this._isIllegalInvocationTypeError(error)) {
          return Promise.resolve();
        }
        return Promise.reject(error);
      }
    }

    /**
     * Despite binding navigator.sendBeacon there are still a handful of users that are throwing
     * TypeErrors with the message 'Illegal invocation'. We have chosen to suppress these errors.
     * https://goto/sqs-track-events-illegal-invocation
     * @param {*} error - The error thrown by navigator.sendBeacon
     * @returns {boolean} - The error is an Illegal invocation TypeError
     */
  }, {
    key: "_isIllegalInvocationTypeError",
    value: function _isIllegalInvocationTypeError(error) {
      return error instanceof TypeError && error.message === 'Illegal invocation';
    }

    /**
     * Send an XHR to the analytics endpoint
     * @param {Object} payload - The event payload to send
     * @param {string} url - Optional: The URL to send event to, used for v2 validation endpoint
     * @returns {Promise} - Resolves when the request was completed successfully
     */
  }, {
    key: "_sendXhr",
    value: function _sendXhr(payload, url) {
      var _this = this;
      url = url || this._config.url;
      var req = new XMLHttpRequest();
      var data = JSON.stringify(payload);
      var SUCCESSFUL_XHR_RESPONSE_CODES = new Set([200, 202]);
      return new Promise(function (resolve, reject) {
        req.open('POST', url, true);
        req.setRequestHeader('Content-Type', 'application/json');
        req.send(data);
        req.addEventListener('readystatechange', function () {
          if (req.readyState !== 4) {
            return;
          }
          if (SUCCESSFUL_XHR_RESPONSE_CODES.has(req.status)) {
            resolve();
          } else {
            _this._warn("Error tracking event: HTTP Status ".concat(req.status));
            reject(new Error("Error tracking event: HTTP Status ".concat(req.status)));
          }
        });
      });
    }

    /**
     * Store analyticsId in both cookie & localStorage
     * @param {string} value - The analyticsId to store
     */
  }, {
    key: "_setAnalyticsId",
    value: function _setAnalyticsId(value) {
      this._analyticsId = value; // Store analyticsId in state for cases of storage expiry

      var _this$_config$cookie = this._config.cookie,
        path = _this$_config$cookie.path,
        secure = _this$_config$cookie.secure;
      var domain = window.location.hostname;
      this._config.cookie.domains.forEach(function (rootDomain) {
        if (window.location.hostname.indexOf(rootDomain) > -1) {
          domain = rootDomain;
        }
      });
      var expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + this._config.cookie.daysToStore);
      var expires = expiryDate.toUTCString();
      try {
        cookie.set(this._config.storageKey, value, {
          domain: domain,
          expires: expires,
          path: path,
          secure: secure
        });

        // Resolve cases of duplicate cookies (root and subdomain)
        var duplicateCookie = document.cookie.indexOf(this._config.storageKey) !== document.cookie.lastIndexOf(this._config.storageKey);
        if (duplicateCookie) {
          var pastDate = new Date(0).toUTCString(); // this will force immediate expiration
          cookie.set(this._config.storageKey, null, {
            expires: pastDate
          });
        }
        safeLocalStorage.setItem(this._config.storageKey, value);
        safeLocalStorage.setItem(this._config.expirationKey, expires);
      } catch (error) {
        this._warn('Unable to store analyticsId');
      }
    }

    /**
     * Checks that analyticsId is in valid UUID format
     * @param {string} value - The analyticsId to validate
     * @returns {string|null} - Returns value if valid or null if invalid
     */
  }, {
    key: "_validateAnalyticsId",
    value: function _validateAnalyticsId(value) {
      var regExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
      return regExp.test(value) ? value : null;
    }

    /**
     * Sends event for validation only to staging endpoint, does not actually log event
     * @param {Object} payload - The event payload to send
     * @returns {Promise} - Resolves when the request was completed successfully
     */
  }, {
    key: "_validateEvent",
    value: function _validateEvent(payload) {
      return Promise.resolve(payload);
    }

    /**
     * Logs warnings to the console if logging is enabled
     * @param {string} message - The warning message
     */
  }, {
    key: "_warn",
    value: function _warn(message) {
      if (this._config.logging) {
        console.warn(message);
      }
    }
  }]);
}();
export { BaseClient as default };