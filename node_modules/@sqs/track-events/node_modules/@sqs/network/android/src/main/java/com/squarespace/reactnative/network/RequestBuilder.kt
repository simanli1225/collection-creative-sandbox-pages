package com.squarespace.reactnative.network

import com.facebook.react.bridge.ReadableMap
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.squarespace.android.api.dynamic.DynamicRequest
import com.squarespace.android.api.dynamic.MediaTypes
import com.squarespace.android.commons.util.Logger
import com.squarespace.reactnative.toolkit.arguments.ArgumentUtils
import com.squarespace.reactnative.toolkit.arguments.asJsonObject
import com.squarespace.reactnative.toolkit.arguments.toMapCorrect
import okhttp3.FormBody
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody

/**
 * Constructs normalized HTTP requests for the [NetworkBridge].
 *
 * The JavaScript client code has a poor api and makes requests in various unsupported formats.
 * This [RequestBuilder] is responsible for accepting all formats and transforming them into a valid network request.
 */
internal object RequestBuilder {

  private val LOG = Logger(RequestBuilder::class)

  // because sometimes our legacy endpoints ask for a POST/PUT with no body
  private const val INVALID_BODY = "invalid body"

  /**
   * Construct a [DynamicRequest]
   *
   * @param method HTTP method (`get`, `put`, `post`, etc). Accepts both upper and lowercase.
   * @param path either a fully qualified url or a url path
   * @param query the query, as a stringified JsonObject, to append to the url.
   * @param body the stringified body to attach to the HTTP request.
   * For certain [encoding] types, the body may be included in the query
   * @param encoding the encoding format of the HTTP request body.
   *
   * @return a [DynamicRequest] to be used with configured [client][com.squarespace.android.api.dynamic.DynamicClient].
   */
  fun build(
    method: String,
    path: String,
    query: String?,
    body: String?,
    encoding: String?
  ): DynamicRequest {
    val format = runCatching { Format.parse(encoding) }
      .onFailure { LOG.warn("Failed to parse encoding.", it) }
      .getOrDefault(Format.URL)

    val queryParameters = coerceQueryToMap(query)
    val bodyAsJsonElement = coerceBodyToJsonElement(body)

    return DynamicRequest(
      methodString = method,
      url = path,
      queryParams = normalizeQueryParams(queryParameters, bodyAsJsonElement, format),
      body = normalizeRequestBody(bodyAsJsonElement, format)
    )
  }

  /**
   * Construct a [DynamicRequest]
   *
   * @param path HTTP method (`get`, `put`, `post`, etc). Accepts both upper and lowercase.
   * @param path either a fully qualified url or a url path
   * @param filePart part containing the file in a multipart message
   *
   * @return a [DynamicRequest] to be used with configured [client][com.squarespace.android.api.dynamic.DynamicClient].
   */
  fun build(
    path: String,
    bodyParameters: ReadableMap?,
    filePart: MultipartBody.Part
  ): DynamicRequest {
    val multipartBody = MultipartBody.Builder()
      .addAll(bodyParameters?.asJsonObject()?.toMap())
      .addPart(filePart)
      .setType(MultipartBody.FORM)
      .build()

    return DynamicRequest(
      methodString = DynamicRequest.DynamicMethod.POST.name,
      url = path,
      body = multipartBody
    )
  }

  private fun coerceQueryToMap(query: String?): Map<String, String> {
    val parser = JsonParser()

    val queryElement = runCatching { parser.parse(query) as? JsonObject }
      .onFailure { LOG.warn("Failed to parse query.", it) }
      .getOrNull()

    val queryAsMap = queryElement?.let { ArgumentUtils.fromJsonObject(it) }
      ?: ArgumentUtils.createMap()

    return queryAsMap.flatten()
  }

  private fun coerceBodyToJsonElement(body: String?): JsonElement? {
    val parser = JsonParser()

    return runCatching { parser.parse(body) }
      .onFailure { LOG.warn("Failed to parse body.", it) }
      .getOrNull()
  }

  /**
   * Creates a flattened [Map] from a nested [ReadableMap].
   * Each complex value will be mapped into a single [String], delimited by commas
   */
  private fun ReadableMap.flatten(): Map<String, String> {
    // This mapping is done because a Jersey REST API supports query params in the following formats
    //    ?foo=bar&foo=baz
    //    ?foo=bar,baz
    // It does not support the following format:
    //    ?foo=[baz,bar]
    // This module actually knows too much about the backend details right now
    // In the future, we should consider using okhttp directly so that we can directly format requests
    return toMapCorrect().mapValues {
      when (val value = it.value) {
        is Iterable<*> -> value.joinToString(",")
        else -> value.toString()
      }
    }
  }

  /**
   * Creates properly formatted query params to be used in an HTTP request.
   */
  private fun normalizeQueryParams(
    queryParameters: Map<String, String>,
    body: JsonElement?,
    format: Format
  ): Map<String, String>? {
    return when {
      format == Format.URL && body != null && body.isJsonObject -> body.asJsonObject.firstEntryOrNull()
        ?.let { queryParameters.toMutableMap().putIfAbsent(it) }
        ?: queryParameters
      else -> queryParameters
    }
  }

  /**
   * Creates a properly formatted body to be used in an HTTP request.
   */
  private fun normalizeRequestBody(
    body: JsonElement?,
    format: Format
  ): RequestBody? {
    return when (format) {
      Format.JSON -> body!!.convertToString()
        .toRequestBody(MediaTypes.APPLICATION_JSON.toMediaTypeOrNull())
      Format.FORM -> FormBody.Builder(Charsets.UTF_8)
        .addAll(body!!.asJsonObject.toMap())
        .build()
        .let { CharsetRequestBody(it, Charsets.UTF_8) }
      Format.URL -> (body?.flattenToString() ?: INVALID_BODY)
        .toRequestBody(MediaTypes.APPLICATION_FORM_URLENCODED.toMediaTypeOrNull())
    }
  }

  /**
   * Adds all the key/value pairs associated with the provided [map] to this [FormBody.Builder]
   */
  private fun FormBody.Builder.addAll(map: Map<String, String>?): FormBody.Builder {
    map?.forEach { add(it.key, it.value) }
    return this
  }

  private fun MultipartBody.Builder.addAll(map: Map<String, String>?): MultipartBody.Builder {
    map?.forEach { addFormDataPart(it.key, it.value) }
    return this
  }

  /**
   * Maps all values of this [JsonObject] to it's [String] representation,
   * and provides a [Map] of [key -> string representations]
   */
  private fun JsonObject.toMap(): Map<String, String> {
    return entrySet()
      .map { it.key to it.value.flattenToString() }
      .toMap()
  }

  /**
   * Inserts the provided [pair] if there is no existing entry associated with the [key][Pair.first].
   */
  private fun <T, R> MutableMap<T, R>.putIfAbsent(pair: Pair<T, R>): MutableMap<T, R> {
    val (key, value) = pair
    if (!this.containsKey(key)) {
      this.put(key, value)
    }
    return this
  }

  /**
   * Extracts the first key/value pair from the [JsonObject].
   */
  private fun JsonObject.firstEntryOrNull(): Pair<String, String>? {
    return entrySet().firstOrNull()
      ?.let { it.key to it.value.toString() }
  }

  /**
   * Converts teh given [JsonElement] to a String, taking extra care to flatten
   * JSON arrays to comma-separated lists.
   */
  private fun JsonElement.flattenToString(): String {
    return when {
      isJsonArray -> asJsonArray.joinToString(",") { it.asString.removeSurrounding("\"") }
      else -> convertToString()
    }
  }

  /**
   * Converts the given [JsonElement] to a String, handling conversion
   * edge-cases.
   */
  private fun JsonElement.convertToString(): String {
    // toString() adds double-quotes if the underlying element is a String
    return takeIf { it.isJsonPrimitive }
      ?.asJsonPrimitive
      ?.takeIf { it.isString }
      ?.asString
      ?: toString()
  }

  /**
   * Various formats that are sent across the [NetworkBridge].
   * Used to categorize requests and route each through the correct normalization logic respectively.
   */
  private enum class Format(vararg val expectedFormats: String) {
    JSON("json"),
    URL("url"),
    FORM("form", "x-www-form-urlencoded");

    companion object {
      fun parse(encoding: String?): Format {
        return values().firstOrNull { it.expectedFormats.contains(encoding?.toLowerCase()) }
          ?: throw NetworkBridgeException("Unexpected encoding type : $encoding")
      }
    }
  }
}
