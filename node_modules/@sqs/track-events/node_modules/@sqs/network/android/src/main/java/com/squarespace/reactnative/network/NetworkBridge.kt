package com.squarespace.reactnative.network

import android.net.Uri
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.ReadableMap
import com.squarespace.android.commons.rx.scheduler.SchedulerProvider
import com.squarespace.android.commons.util.Logger
import com.squarespace.android.files.mime.MimeTypeEvaluator
import com.squarespace.android.files.upload.UploadManager
import com.squarespace.android.files.upload.Uploader
import com.squarespace.android.files.validation.ImageValidator
import com.squarespace.android.files.validation.Validator
import com.squarespace.android.tracker.operational.OpEventLogger
import com.squarespace.reactnative.network.client.ClientFactory
import com.squarespace.reactnative.network.client.OpEventNames
import com.squarespace.reactnative.toolkit.arguments.ArgumentUtils
import com.squarespace.reactnative.toolkit.arguments.of
import com.squarespace.reactnative.toolkit.context.ReactContextProvider
import com.squarespace.reactnative.toolkit.context.asContextProvider
import com.squarespace.reactnative.toolkit.extensions.resolve
import com.squarespace.reactnative.toolkit.messenger.ReactEventMessenger
import io.reactivex.Single
import io.reactivex.disposables.CompositeDisposable
import io.reactivex.subjects.PublishSubject
import okhttp3.MultipartBody
import java.io.File
import java.util.concurrent.TimeUnit

/**
 * Handles all HTTP networking requests made from JavaScript.
 *
 * @param context - Context of the calling activity.
 * @param clientFactory - dynamically constructs a client that can be used to make http requests.
 * @param schedulerProvider - Bundle of commonly used schedulers.
 */
class NetworkBridge(
  context: ReactApplicationContext,
  private val clientFactory: ClientFactory,
  private val schedulerProvider: SchedulerProvider,
  private val opEventLogger: OpEventLogger
) : ReactContextBaseJavaModule(context),
  OnDestroyListener {

  companion object {
    /** Used to tag any [Promise] related messages */
    private const val PROMISE_TAG = "NetworkBridgeError"
    private val LOG = Logger(NetworkBridge::class)
    private const val UPLOAD_UPDATE_THROTTLE_BY_MS = 100L
    private const val DEFAULT_MIMETYPE = ""
    private val validators: List<Validator> = listOf(
      ImageValidator()
    )
  }

  private var compositeDisposable = CompositeDisposable()

  /** When a cancel is requested, this emits the original uri [String] used to begin the upload process. */
  private val cancelSubject = PublishSubject.create<String>()
  private val mimeTypeEvaluator = MimeTypeEvaluator()

  private val messenger by lazy { NetworkBridge.Messenger(reactApplicationContext.asContextProvider()) }

  init {
    reactApplicationContext.addLifecycleEventListener(this)
  }

  override fun getName() = "NetworkBridge"

  @ReactMethod
  fun request(
    method: String,
    path: String,
    query: String? = null,
    body: String? = null,
    encoding: String?,
    promise: Promise
  ) {
    Single.fromCallable { request(method, path, query, body, encoding) }
      .subscribeOn(schedulerProvider.io)
      .subscribe({
        promise.resolve(it)
      }, {
        LOG.error("Network request failed.", it)
        promise.reject(PROMISE_TAG, it.localizedMessage, it)
      }).let { compositeDisposable.add(it) }
  }

  @Throws(NetworkBridgeException::class)
  private fun request(
    method: String,
    path: String,
    query: String?,
    body: String?,
    encoding: String?
  ): ReadableMap {
    val client = clientFactory.create()

    // delegate to dedicated builder as we usually need to normalize requests
    val request = RequestBuilder.build(method, path, query, body, encoding)

    val response = client.dynamicRequest(request)

    // delegate to a dedicated parser as there is a expectation on the response format
    return ResponseParser.parse(response)
  }

  @ReactMethod
  fun upload(path: String, uri: String, formData: ReadableMap, promise: Promise) {
    val cancelEvent = cancelSubject.filter { it == uri }
      .map { UploadEvent.Canceled<Any?>() }
      .take(1)
      .singleElement() // ensure we finish up the stream after emitting one item
      .toObservable()
      .cache() // only need to catch this event once

    Single.fromCallable { validateUri(Uri.parse(uri)) }
      .map { Uploader { upload(path, formData, it) } }
      .map { UploadManager(it, opEventLogger) }
      .flatMapObservable { it.upload(uri) }
      .throttleLatest(UPLOAD_UPDATE_THROTTLE_BY_MS, TimeUnit.MILLISECONDS, true)
      .map { it.asUploadEvent() }
      .takeUntil(cancelEvent) // cancel upstream
      .concatWith(cancelEvent) // then ensure we emit that cancel event
      .takeUntil { it is UploadEvent.Canceled || it is UploadEvent.Result }
      .subscribeOn(schedulerProvider.upload)
      .observeOn(schedulerProvider.main)
      .subscribe({
        when (it) {
          is UploadEvent.Progress -> messenger.notifyProgress(uri, it.value)
          is UploadEvent.Canceled -> {
            promise.reject(PROMISE_TAG, "Upload canceled")
            opEventLogger.success(
              OpEventNames.Origin.NATIVE,
              OpEventNames.Feature.FILE_UPLOADER,
              OpEventNames.Action.CANCEL
            )
          }
          is UploadEvent.Result -> promise.resolve(it.data)
        }
      }, {
        LOG.error("Upload request failed.", it)
        promise.reject(PROMISE_TAG, "Upload failed")
      }).let { compositeDisposable.add(it) }
  }

  @Throws(NetworkBridgeException::class)
  private fun upload(path: String, formData: ReadableMap, part: MultipartBody.Part): Any? {
    val client = clientFactory.create()

    // delegate to dedicated builder in case we need to normalize requests
    val request = RequestBuilder.build(path, formData, part)

    val response = client.dynamicRequest(request)

    if (!response.isSuccessful) {
      throw NetworkBridgeException(response)
    }
    // delegate to a dedicated parser as there is a expectation on the response format
    return ResponseParser.parse(response.body())
  }

  private fun validateUri(uri: Uri) {
    val mimeType = mimeTypeEvaluator.guessFrom(uri.toString()) // extrapolate from the original uri
      ?: DEFAULT_MIMETYPE
    val fileToValidate = File(uri.path)
    validators.filter { it.canValidate(mimeType) }
      .forEach { it.validate(mimeType, fileToValidate) }
  }

  @ReactMethod
  fun cancelUpload(uri: String, promise: Promise) {
    cancelSubject.onNext(uri)

    // optimistic resolution - we acknowledge that we've made an async request to cancel anything in flight
    promise.resolve()

    opEventLogger.start(
      OpEventNames.Origin.NATIVE,
      OpEventNames.Feature.FILE_UPLOADER,
      OpEventNames.Action.CANCEL
    )
  }

  override fun onHostDestroy() {
    compositeDisposable.clear()
  }

  class Messenger(contextProvider: ReactContextProvider) : ReactEventMessenger(contextProvider) {
    fun notifyProgress(url: String, progress: Double) {
      val args = ArgumentUtils.createMap().of(
        "fileUrl" to url,
        "progress" to progress
      )

      sendMessage("uploadProgress", args)
    }
  }

  /**
   * Converts events from the uploader into events understood by this bridge.
   */
  private fun <T> UploadManager.Event<T>.asUploadEvent(): UploadEvent<T> {
    return when (this) {
      is UploadManager.Event.Complete -> UploadEvent.Result(this.result)
      is UploadManager.Event.Progress -> UploadEvent.Progress(this.progress)
    }
  }

  @Suppress("unused") // generic used for type inference
  private sealed class UploadEvent<T> {
    class Canceled<T> : UploadEvent<T>()
    class Progress<T>(val value: Double) : UploadEvent<T>()
    data class Result<T>(val data: T) : UploadEvent<T>()
  }
}
