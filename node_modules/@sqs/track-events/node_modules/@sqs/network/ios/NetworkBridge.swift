import Foundation
import React

// MARK: - React Native Event Emitter

private enum NetworkBridgeRCTEvent: String, CaseIterable {
    case uploadProgress = "uploadProgress"
}

// MARK: - Network Bridge Client

public protocol NetworkBridgeClient {
    func makeRequest(
        method: String,
        path: String,
        queryParameters: [String : Any]?,
        bodyParameters: Any?,
        bodyIsJSON: Bool
    ) async throws -> (request: URLRequest, response: HTTPURLResponse?, result: Result<Data, Error>)

    func uploadImage(
        _ data: Data,
        fileName: String,
        path: String,
        additionalMultipartFormFields: [(String, Data)],
        progressHandler: @escaping (Progress) -> Void
    ) -> Task<Data, Error>
}

// MARK: - Network Bridge

@objc(NetworkBridge)
public class NetworkBridge: RCTEventEmitter {
    public enum Errors: Error {
        case contextNotInitialized
        case invalidLocalFileURL
        case localFileMissing
        case serializationFailed
    }

    public struct Dependencies {
        let client: NetworkBridgeClient

        public init(client: NetworkBridgeClient) {
            self.client = client
        }
    }

    public static var dependencies: Dependencies?

    private let uploader = SerialImageUploader { request in
        guard let dependencies else { throw Errors.contextNotInitialized }
        // Reading the local file here delays reading the file data until we actually start the upload.
        // So we won't hold all pending uploads in memory at the same time.
        guard let data = try? Data(contentsOf: request.localFileURL) else { throw Errors.localFileMissing }

        return dependencies.client.uploadImage(data, fileName: request.fileName, path: request.path, additionalMultipartFormFields: request.additionalFormData, progressHandler: request.progressHandler)
    }

    public override func supportedEvents() -> [String]! {
        return NetworkBridgeRCTEvent.allCases.map { $0.rawValue }
    }

    @objc override public static func requiresMainQueueSetup() -> Bool {
        return false
    }

    // swiftlint:disable function_parameter_count
    @objc (request:path:parameters:bodyParameters:encoding:resolver:rejector:)
    public final func request(method: String, path: String, parameters: String? = nil, bodyParameters: String? = nil, encoding: String, resolver resolve: @escaping RCTPromiseResolveBlock, rejector reject: @escaping RCTPromiseRejectBlock) {
        guard let dependencies = NetworkBridge.dependencies else {
            reject("NetworkBridgeError", "Context not initialized", nil)
            return
        }

        let queryParameters: [String : Any]?
        let body: Any?
        do {
            queryParameters = try parseQueryParameters(json: parameters)
            body = try parseBody(json: bodyParameters)
        } catch {
            reject("NetworkBridgeError", error.localizedDescription, error)
            return
        }

        Task {
            do {
                let (request, urlResponse, result) = try await dependencies.client.makeRequest(
                    method: method,
                    path: path,
                    queryParameters: queryParameters,
                    bodyParameters: body,
                    bodyIsJSON: encoding.lowercased() == "json"
                )

                let queryItems = request.url.flatMap {
                    URLComponents(url: $0, resolvingAgainstBaseURL: false)?.queryItems
                }?.reduce(into: [:]) {
                    $0[$1.name] = $1.value
                } ?? [:]

                guard let statusCode = urlResponse?.statusCode else {
                    reject("NetworkBridgeError", "Invalid response received", nil)
                    return
                }

                let config: [String: Any] = [
                    "params": queryItems
                ]

                let response: [String : Any] = [
                    "status": statusCode,
                    "config": config
                ]

                guard
                    case .success(let data) = result,
                    let json = try? JSONSerialization.jsonObject(with: data),
                    json is [Any] || json is [String : Any]
                else {
                    resolve(response)
                    return
                }

                let dataResponse = response.merging(["data": json]) { return $1 }
                resolve(dataResponse)
            } catch {
                reject("NetworkBridgeError", error.localizedDescription, error)
            }
        }
    }

    @objc(upload:localFileURL:additionalFormData:resolver:rejector:)
    public final func upload(path: String, localFileURLString: String, additionalFormData: [String : AnyObject], resolver resolve: @escaping RCTPromiseResolveBlock, rejector reject: @escaping RCTPromiseRejectBlock) {
        guard let dependencies = NetworkBridge.dependencies else {
            reject("NetworkBridgeError", "Context not initialized", nil)
            return
        }

        guard let localFileURL = URL(string: localFileURLString) else {
            reject("NetworkBridgeError", "Invalid Local File URL", Errors.invalidLocalFileURL)
            return
        }
        let fileName = additionalFormData["fileName"] as? String ?? localFileURL.lastPathComponent
        let request = SerialImageUploader.Request(
            localFileURL: localFileURL,
            path: path,
            fileName: fileName,
            additionalFormData: parseMultipartFormParameters(additionalFormData)
        ) { [weak self] progress in
            self?.sendEvent(withName: NetworkBridgeRCTEvent.uploadProgress.rawValue, body: [
                "fileUrl" : localFileURLString,
                "progress" : progress.fractionCompleted
            ])
        } resultHandler: { result in
            do {
                let json = try JSONSerialization.jsonObject(with: result.get()) as? [String: Any]
                resolve(json)
            } catch let error where error.isCancelled {
                reject("NetworkBridgeError", "Upload canceled", error)
            } catch {
                reject("NetworkBridgeError", "Upload failed", error)
            }
        }

        Task {
            do {
                try await uploader.add(request)
            } catch let error as SerialImageUploader.Errors {
                reject("NetworkBridgeError", error.localizedDescription, error)
            } catch {
                reject("NetworkBridgeError", "Upload failed", error)
            }
        }
    }

    @objc(cancelUpload:resolver:rejector:)
    public final func cancelUpload(for localFileURLString: String, resolver resolve: @escaping RCTPromiseResolveBlock, rejector reject: @escaping RCTPromiseRejectBlock) {
        guard let localFileURL = URL(string: localFileURLString) else {
            reject("NetworkBridgeError", "Invalid Local File URL", Errors.invalidLocalFileURL)
            return
        }
        Task {
            do {
                try await uploader.cancelRequest(with: localFileURL)
                resolve(nil)
            } catch let error as SerialImageUploader.Errors {
                reject("NetworkBridgeError", error.localizedDescription, error)
            } catch {
                reject("NetworkBridgeError", "Upload cancellation failed", error)
            }
        }
    }

    // MARK: - Private

    private func parseQueryParameters(json: String?) throws -> [String : Any]? {
        guard let json = json else { return nil }
        guard
            let data = json.data(using: .utf8),
            let parameters = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
        else {
            throw Errors.serializationFailed
        }
        return parameters
    }

    private func parseBody(json: String?) throws -> Any? {
        guard let json = json else { return nil }
        guard
            let data = json.data(using: .utf8),
            let parameters = try? JSONSerialization.jsonObject(with: data, options: [])
        else {
            throw Errors.serializationFailed
        }
        
        return parameters
    }

    private func parseMultipartFormParameters(_ parameters: [String : AnyObject]) -> [(String, Data)] {
        parameters.reduce(into: [:]) {
            $0[$1.key] = switch $1.value {
            case let value as String:
                value.data(using: .utf8)
            case let value as NSNumber:
                (value.isBool ? (value.boolValue ? "true" : "false") : value.stringValue).data(using: .utf8)
            default:
                nil
            }
        }.map {
            ($0.key, $0.value)
        }
    }
}

private extension NSNumber {
    var isBool: Bool {
        let testBool = true
        let testValue = testBool as NSNumber
        let testBoolObjcType = String(cString: testValue.objCType)

        let selfObjcType = String(cString: self.objCType)

        return testBoolObjcType == selfObjcType
    }
}

extension Error {
    var isCancelled: Bool {
        do {
            throw self
        } catch is CancellationError {
            return true
        } catch URLError.cancelled {
            return true
        } catch CocoaError.userCancelled {
            return true
        } catch {
            return false
        }
    }
}
