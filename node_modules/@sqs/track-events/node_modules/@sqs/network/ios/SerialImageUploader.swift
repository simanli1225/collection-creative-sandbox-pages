import Foundation

actor SerialImageUploader {
    struct Request: Identifiable {
        enum State {
            case waiting
            case active(Task<Data, Error>)
            case cancelled
        }

        let localFileURL: URL
        let path: String
        let fileName: String
        let additionalFormData: [(String, Data)]
        let progressHandler: (Progress) -> Void
        let resultHandler: (Result<Data, Error>) -> Void

        var id: URL { localFileURL }
    }

    let uploadHandler: (_ request: Request) throws -> Task<Data, Error>

    private let (requests, requestContinuation) = AsyncStream<Request>.makeStream()
    private var requestStates: [Request.ID: Request.State] = [:]

    init(uploadHandler: @escaping (Request) throws -> Task<Data, Error>) {
        self.uploadHandler = uploadHandler
        Task {
            for await request in requests {
                await process(request: request)
            }
        }
    }

    func add(_ request: Request) throws {
        switch requestStates[request.id] {
        case .none:
            requestStates[request.id] = .waiting
            requestContinuation.yield(request)
        default:
            throw Errors.duplicateUploadAttempted
        }
    }

    func cancelRequest(with id: Request.ID) throws {
        switch requestStates[id] {
        case .waiting:
            requestStates[id] = .cancelled
        case.active(let task):
            task.cancel()
        case .cancelled:
            break
        case .none:
            throw Errors.noUploadInProgress
        }
    }

    private func process(request: Request) async {
        switch requestStates[request.id] {
        case .waiting:
            let result: Result<Data, Error>
            do {
                let uploadTask = try uploadHandler(request)
                requestStates[request.id] = .active(uploadTask)
                result = await uploadTask.result
            } catch {
                result = .failure(error)
            }
            requestStates.removeValue(forKey: request.id)
            request.resultHandler(result)
        case .active:
            request.resultHandler(.failure(Errors.duplicateUploadAttempted))
        case .cancelled:
            requestStates.removeValue(forKey: request.id)
            request.resultHandler(.failure(CancellationError()))
        case .none:
            fatalError()
        }
    }

    enum Errors: Error {
        case duplicateUploadAttempted
        case noUploadInProgress

        var localizedDescription: String {
            switch self {
            case .duplicateUploadAttempted: "An upload is already in progress for the given URL"
            case .noUploadInProgress: "No upload is in progress for the given URL"
            }
        }
    }
}
