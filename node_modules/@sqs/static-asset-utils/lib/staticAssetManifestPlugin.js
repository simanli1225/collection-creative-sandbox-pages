"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAssetParser = exports.formatLog = void 0;
const generateStaticAssetPaths_1 = require("./generateStaticAssetPaths");
const path_1 = __importDefault(require("path"));
const fileWriter_1 = require("./fileWriter");
const queuedFileWriter_1 = require("./queuedFileWriter");
const febs_logger_1 = __importDefault(require("@sqs/febs-logger"));
const chalk_1 = __importDefault(require("chalk"));
const pluginName = 'StaticAssetManifestPlugin';
function formatLog(messages) {
    const prefix = chalk_1.default.magenta.bold(`${pluginName}`);
    return messages.reduce((acc, curr) => {
        if (typeof curr !== 'string') {
            curr = JSON.stringify(curr, null, 2);
        }
        return acc.concat('\n' + curr);
    }, prefix);
}
exports.formatLog = formatLog;
function formatError(error, text = '') {
    const formatted = Object.assign(error, {
        message: chalk_1.default.bgMagenta.bold(`${pluginName}`) + ` ${text} ` + error.message,
    });
    return formatted;
}
function extractExtension(filename) {
    const filenameParts = filename.split('.');
    let extension = filenameParts.pop();
    if (extension === 'map') {
        extension = `${filenameParts.pop()}.map`;
    }
    if (!extension) {
        throw new Error(`Failed to extract extension from ${filename}`);
    }
    return extension;
}
function createManifestKey(filename, chunkName, locale) {
    const extension = extractExtension(filename);
    let key;
    if (chunkName) {
        key =
            ['js', 'js.map'].includes(extension) && locale
                ? `${chunkName}.${locale}.${extension}`
                : `${chunkName}.${extension}`;
    }
    else {
        key = filename;
    }
    return key;
}
function generateAssetParser({ outputPath, projectName, locale, }) {
    return function assetParser(filename, chunkname) {
        const localPath = './' + path_1.default.join(outputPath, filename);
        const remotePath = path_1.default.join('/', projectName, filename);
        const key = createManifestKey(filename, chunkname, locale);
        return { key, paths: { localPath, remotePath } };
    };
}
exports.generateAssetParser = generateAssetParser;
function getCompilationAssetsManifest(compilation, getPaths) {
    const chunkArray = Array.from(compilation.chunks);
    const assetChunkMap = chunkArray.reduce((acc, chunk) => {
        for (const file of chunk.files) {
            acc[file] = chunk;
        }
        return acc;
    }, {});
    const webpackManifestEntries = {};
    Object.keys(compilation.assets)
        .filter((filename) => filename !== 'index.html')
        .forEach((filename) => {
        const assetChunkName = assetChunkMap[filename]
            ? assetChunkMap[filename].name
            : '';
        const { key, paths } = getPaths(filename, assetChunkName);
        webpackManifestEntries[key] = paths;
    });
    return webpackManifestEntries;
}
class StaticAssetManifestPlugin {
    constructor(options) {
        if (!options.projectName) {
            throw new Error(formatLog(['Requires `projectName` option']));
        }
        this.options = Object.assign(Object.assign({}, StaticAssetManifestPlugin.defaults), options);
        this.writer = queuedFileWriter_1.createQueuedWriter(fileWriter_1.createWriter());
        const logLevel = this.options.debug ? 'debug' : 'info';
        febs_logger_1.default.setLevel(logLevel);
        this.logger = febs_logger_1.default;
        this.log('Plugin Options', this.options);
    }
    log(...messages) {
        this.logger.debug(formatLog(messages));
    }
    apply(compiler) {
        if (!compiler.options.context ||
            !compiler.options.output ||
            !compiler.options.output.path) {
            throw new Error(formatLog([
                'Insufficient compiler options. `context` and `output.path` are required',
                compiler.options,
            ]));
        }
        const compilerContext = compiler.options.context;
        const outputPath = path_1.default.relative(compilerContext, compiler.options.output.path);
        const { projectName, locale, outputFilePrefix } = this.options;
        const assetParser = generateAssetParser({
            outputPath,
            projectName,
            locale,
        });
        const manifestFileName = locale ? `${outputFilePrefix}.${locale}.json` : `${outputFilePrefix}.json`;
        const manifestFilePath = path_1.default.join(compiler.options.output.path, manifestFileName);
        compiler.hooks.emit.tapAsync(pluginName, async (compilation, callback) => {
            const manifestEntries = getCompilationAssetsManifest(compilation, assetParser);
            this.log('Manifest Entries from Webpack Compilation', manifestEntries);
            if (this.options.customAssets) {
                try {
                    const { nonWebpackContent, projectRoot, assetsRoot, } = this.options.customAssets;
                    const additionalManifestEntries = await generateStaticAssetPaths_1.generateStaticAssetPaths({
                        files: nonWebpackContent,
                        projectRoot: projectRoot || compilerContext,
                        assetsRoot,
                        projectName,
                    });
                    this.log('Non-Webpack Entries', additionalManifestEntries);
                    Object.assign(manifestEntries, additionalManifestEntries);
                }
                catch (error) {
                    return callback(formatError(error, 'Failed to add non webpack assets to the manifest'));
                }
            }
            this.writer(manifestEntries, manifestFilePath, (error) => {
                if (error) {
                    return callback(formatError(error));
                }
                this.log('Wrote Static Asset Manifest to ' + manifestFilePath);
                callback();
            });
        });
    }
}
exports.default = StaticAssetManifestPlugin;
StaticAssetManifestPlugin.defaults = {
    debug: false,
    outputFilePrefix: 'manifest',
};
//# sourceMappingURL=staticAssetManifestPlugin.js.map