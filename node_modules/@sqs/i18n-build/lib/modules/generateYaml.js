"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUnusedYamls = removeUnusedYamls;
exports.build = build;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const pretty_bytes_1 = tslib_1.__importDefault(require("pretty-bytes"));
const yaml_lint_1 = require("yaml-lint");
const CWD = process.cwd();
const DEFAULT_YAML_SUFFIX = 'en-US.yaml';
const YAML_REGEX = [
    '\\{[^\\{\\}]+?\\}', // sub-replacement
    '\\{\\{[^\\{\\}]+?\\}\\}', // handlebars 2x braces
    '\\{\\{\\{[^\\{\\}]+?\\}\\}\\}', // handlebars 3x braces
    '\\\\<(?:[a-z]+.*?|\\/[a-z]+?)>', // html
].join('|');
const ast_utils_1 = require("../ast-utils");
function generateYamlHeader() {
    return [
        '# smartling.plurals_detection = on',
        `# smartling.placeholder_format_custom = ${YAML_REGEX}`,
        '---',
    ];
}
function escapeValueForYaml(value) {
    return value.replace(/\"/g, '\\"').replace(/\n/g, '\\n');
}
function getAdditionalPathText(additionalPaths) {
    if (!Array.isArray(additionalPaths) || additionalPaths.length === 0) {
        return '';
    }
    return ` (+ ${additionalPaths.length} other file(s))`;
}
function generateYamlEntry(translationInstance) {
    const output = [];
    const { uid, value, type, path: filePath, additionalPaths } = translationInstance;
    const notesText = translationInstance.notes !== null ? translationInstance.notes : 'No notes available';
    const translationIdText = translationInstance.translationId !== null
        ? ` | Overwrite id: ${translationInstance.translationId}`
        : '';
    const additionalPathsText = getAdditionalPathText(additionalPaths);
    // translator notes are passed as a comment above the string value
    // append filename and additionalPaths
    output.push(`# ${notesText} | source: ${filePath}${translationIdText}${additionalPathsText}`);
    // variantId: stringValue
    if (type === ast_utils_1.T_FUNCTION_NAME + '()' || type === '<' + ast_utils_1.T_COMPONENT_NAME + '>') {
        output.push(`${uid}: "${escapeValueForYaml(value)}"`);
    }
    else if (type === ast_utils_1.PLURALIZE_FUNCTION_NAME + '()' ||
        type === '<' + ast_utils_1.PLURAL_COMPONENT_NAME + '>') {
        output.push(`${uid}:`);
        output.push(`    one: "${escapeValueForYaml(value.one)}"`);
        output.push(`    other: "${escapeValueForYaml(value.other)}"`);
    }
    return output;
}
function generateBundleContent(instances) {
    let yamlOutput = generateYamlHeader();
    // Sort string hashes for cleaner diffs
    const stringHashes = Object.keys(instances).sort();
    const outputBody = stringHashes.reduce((acc, hash) => {
        const translationInstance = instances[hash];
        const yaml = generateYamlEntry(translationInstance);
        return acc.concat(yaml);
    }, []);
    yamlOutput = yamlOutput.concat(outputBody);
    return yamlOutput.join('\n');
}
/**
 * @param {array} the extracted project keys
 * @param {string} the dir where the yaml files exist
 */
function removeUnusedYamls(extractions, yamlDirectory) {
    const allFiles = fs_1.default.readdirSync(yamlDirectory, 'utf8');
    // Iterate over the files and delete files where there is not an associated extraction key
    const deletedYamls = allFiles.filter((file) => {
        if (!file.endsWith(DEFAULT_YAML_SUFFIX)) {
            return false;
        }
        // Get the project key from the base file name
        const ext = path_1.default.extname(file);
        const baseFileName = path_1.default.basename(file, ext);
        const yamlFileProjectKey = baseFileName.split('.').slice(0, -1).join('.');
        return !extractions.includes(yamlFileProjectKey);
    });
    let deletedYamlCount = 0;
    deletedYamls.forEach((file) => {
        const yamlFilePath = path_1.default.join(yamlDirectory, file);
        try {
            // Unlink unused file
            fs_1.default.unlinkSync(yamlFilePath);
            console.log(`Delete: ${path_1.default.relative(CWD, yamlFilePath)} (unused)`);
            deletedYamlCount++;
        }
        catch (e) {
            console.log(`Unable to delete file: ${path_1.default.relative(CWD, yamlFilePath)} : ${e.message}`);
        }
    });
    if (deletedYamlCount > 0) {
        console.log(`Deleted ${deletedYamlCount} YAML files`);
    }
    return deletedYamls;
}
/**
 * Build YAML files, assuming they all validate with yaml-lint
 */
async function build(extractions, outputDirectory, isDryRun = false) {
    const projectKeys = Object.keys(extractions);
    const yamlPromises = projectKeys.map(async (project) => {
        const outputPath = path_1.default.join(outputDirectory, `${project}.${DEFAULT_YAML_SUFFIX}`);
        const bundleContent = generateBundleContent(extractions[project].instances);
        const relativePath = path_1.default.relative(CWD, outputPath);
        const stringCount = Object.keys(extractions[project].instances).length;
        try {
            await (0, yaml_lint_1.lint)(bundleContent);
            if (!isDryRun) {
                fs_1.default.writeFileSync(outputPath, bundleContent, 'utf8');
                const fileSize = (0, pretty_bytes_1.default)(fs_1.default.lstatSync(outputPath).size);
                console.log(`Wrote ${stringCount} strings: ${relativePath} (${fileSize})`);
            }
            else {
                console.log(`\n[dry-run] Generated YAML file contents: ${relativePath}`);
                console.log(`${bundleContent}`);
            }
        }
        catch (err) {
            throw new Error('Could not generate and validate YAML for ' + relativePath + ';\nError: ' + err);
        }
    });
    try {
        await Promise.all(yamlPromises);
        console.log(`\nCreated ${projectKeys.length} YAML files`);
    }
    catch (err) {
        throw err;
    }
}
exports.default = {
    generateYamlHeader,
    escapeValueForYaml,
    generateYamlEntry,
    generateBundleContent,
    build,
    removeUnusedYamls,
};
