import { TranslationOrPluralValue, UUID } from '../ast-utils/utils/hash';
/**
 * @param {array} dirs the paths to walk for js(x) files
 * @param {array} ignorePathGlobs - dirs to ignore from crawling
 * @returns {array} a list of all js(x) files in the paths
 */
export declare function getFilePaths(dirs: string[], ignorePathGlobs?: string[]): Promise<string[]>;
/**
 * @param {array} fileExtractions a list of extractions for a given file
 * @param {array<string>} spellingsToEnforce a list of project keys for which variation (based on Levenshtein distance) are not allowed
 * @returns {boolean} returns false if file contains a duplicate case-insensitive project key, true otherwise.
 */
export declare function areProjectKeysValidInFile(fileExtractions: ExtractResultWithPaths[] | undefined, spellingsToEnforce: string[]): boolean;
export interface ExtractConfig {
    bundlePath?: string;
    ignorePathGlobs?: string[];
    enforceProjectSpelling?: string[];
}
export interface ExtractResult {
    type: 't()' | 'pluralize()' | '<T>' | '<Plural>';
    project: string;
    translationId: string | null;
    uid: UUID;
    value: TranslationOrPluralValue;
    notes?: string;
}
export type ParseMetaData = {
    errors?: string[];
    extractionResult: ExtractResult;
} | {
    errors: string[];
    extractionResult?: ExtractResult;
};
export interface ExtractResultWithPaths extends ExtractResult {
    path: string;
    additionalPaths: string[];
    lineNumber: number | null;
}
/**
 * @exports
 * @param {array} srcDirs the paths to walk for js(x) files
 * @param {object} config options for extraction
 * @param {boolean=false} logging logging output to stdout
 * @returns {Promise<ExtractResultWithPaths[]>} extracted strings
 */
export declare const extractStrings: (srcDirs: string[], config?: ExtractConfig) => Promise<ExtractResultWithPaths[]>;
export interface ExtractionBundle {
    uids: UUID[];
    filepaths: string[];
    instances: Record<string, ExtractResultWithPaths>;
}
/**
 *
 * what should the bundle look like?
 * app.domains: {
 *  uids: [],
 *  instances: {
 *    '123abc': {
 *      uid: '1234abc',
 *      path: path,
 *      ...
 *    },
 *  }
 *
 * then consume this json to create a formatted yaml
 *
 * @exports
 * @param {array} raw - metadata for translationHelpers as an array of JS objects
 * @returns {object} extractions - tied extraction bundles
 */
export declare const tieBundle: (raw: ExtractResultWithPaths[]) => {
    extractions: Record<string, ExtractionBundle>;
};
