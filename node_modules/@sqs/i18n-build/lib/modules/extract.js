"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tieBundle = exports.extractStrings = void 0;
exports.getFilePaths = getFilePaths;
exports.areProjectKeysValidInFile = areProjectKeysValidInFile;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = require("lodash"); // eslint-disable-line
const crawl_1 = tslib_1.__importDefault(require("../utils/crawl"));
const parse_1 = tslib_1.__importDefault(require("../utils/parse"));
const findProjectKeyTypo_1 = tslib_1.__importDefault(require("../utils/findProjectKeyTypo"));
const CWD = process.cwd();
let processedFiles;
let totalFiles;
/**
 * @param {array} dirs the paths to walk for js(x) files
 * @param {array} ignorePathGlobs - dirs to ignore from crawling
 * @returns {array} a list of all js(x) files in the paths
 */
async function getFilePaths(dirs, ignorePathGlobs) {
    console.log('Gathering paths...');
    const crawls = [];
    dirs.forEach((d) => crawls.push((0, crawl_1.default)(d, ignorePathGlobs)));
    const results = await Promise.all(crawls);
    const flatPaths = [].concat(...results);
    totalFiles = flatPaths.length;
    console.log('Found ' + totalFiles + ' files');
    return flatPaths;
}
const logProjectKeyTypoError = (incorrectSpellingProject, correctSpellingProject) => {
    const explanatoryText = [
        'This causes a bug with processing translations.',
        'Please ensure that all of your project keys are spelled correctly.',
    ];
    console.error(`\n
  We detected a project key with incorrect spelling: '${incorrectSpellingProject}' should be '${correctSpellingProject}'
  ${explanatoryText.join(' ')}`);
};
function areProjectKeysValid(projectKey, spellingsToEnforce) {
    const foundProjectKeyWithTypo = (0, findProjectKeyTypo_1.default)(projectKey, spellingsToEnforce);
    if (foundProjectKeyWithTypo) {
        logProjectKeyTypoError(projectKey, foundProjectKeyWithTypo);
        return false;
    }
    return true;
}
/**
 * @param {array} fileExtractions a list of extractions for a given file
 * @param {array<string>} spellingsToEnforce a list of project keys for which variation (based on Levenshtein distance) are not allowed
 * @returns {boolean} returns false if file contains a duplicate case-insensitive project key, true otherwise.
 */
function areProjectKeysValidInFile(fileExtractions = [], spellingsToEnforce) {
    const projectKeys = (0, lodash_1.uniq)(fileExtractions.map((instance) => instance.project));
    for (const projectKey of projectKeys) {
        if (!areProjectKeysValid(projectKey, spellingsToEnforce)) {
            return false;
        }
    }
    return true;
}
/**
 * @param {string} filePath a file path
 * @param {function} projectSpellingsToEnforce list of project keys to disallow spelling variation from
 * @returns {array} extracted string raw data from file
 */
async function extractStringsFromFile(filePath, projectSpellingsToEnforce = []) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
                return;
            }
            let results;
            try {
                results = (0, parse_1.default)(data, filePath);
            }
            catch (e) {
                console.error(`Parse error: ${e.message}`);
                reject(e);
                return;
            }
            if (!results) {
                resolve([]);
                return;
            }
            const { errors, strings } = results;
            const relativeFilePath = path_1.default.relative(CWD, filePath);
            if (errors) {
                console.log(`\nErrors encountered while parsing file: ${relativeFilePath}`);
                reject(new Error(errors));
                return;
            }
            if (!areProjectKeysValidInFile(strings, projectSpellingsToEnforce)) {
                const errorMessage = `Unable to extract file: ${relativeFilePath}`;
                console.error(errorMessage);
                reject(new Error(errorMessage));
                return;
            }
            processedFiles++;
            // TODO: https://squarespace.atlassian.net/browse/I18NPLAT-2069
            // console.debug('Processed file:', relativeFilePath);
            resolve(strings);
        });
    });
}
/**
 * @param {array} srcDirs the paths to walk for js(x) files
 * @param {object} config options for extraction
 * @returns {Promise<ExtractResultWithPaths[]>} extracted string raw data from files
 */
async function extractStringsFromDirs(srcDirs, config) {
    const scans = [];
    const paths = await getFilePaths(srcDirs, config.ignorePathGlobs);
    const spellingsToEnforce = config.enforceProjectSpelling || [];
    paths.forEach((p) => scans.push(extractStringsFromFile(p, spellingsToEnforce)));
    const results = await Promise.all(scans);
    const allResults = [].concat(...results);
    console.log(`Processed ${processedFiles}/${totalFiles} files`);
    return allResults;
}
/**
 * @exports
 * @param {array} srcDirs the paths to walk for js(x) files
 * @param {object} config options for extraction
 * @param {boolean=false} logging logging output to stdout
 * @returns {Promise<ExtractResultWithPaths[]>} extracted strings
 */
const extractStrings = (srcDirs, config = {}) => {
    processedFiles = 0;
    return extractStringsFromDirs(srcDirs, config);
};
exports.extractStrings = extractStrings;
/**
 * Mutates projectInstance by updating projectInstance uids and instances
 * @param {object} project
 * @param {object} translationInstance
 * @returns {undefined}
 */
const initializeTranslationInstance = (project, translationInstance) => {
    if (!project.uids) {
        // Initialize uids property
        project.uids = [];
    }
    const { uid } = translationInstance;
    // If the uid doesn't exist yet
    // Add the uid to the uids array and add the extractionInstance as a
    // property of this project.
    if (!project.uids.includes(uid)) {
        project.uids.push(uid);
        project.instances[uid] = {
            ...translationInstance,
            // Initialize the additionalPaths property to track the other unique file(s) where this instance exists
            additionalPaths: [],
        };
    }
};
/**
 * Mutates project by updating filepaths
 * @param {object} project
 * @param {object} translationInstance
 * @returns {undefined}
 */
const addFilePaths = (project, translationInstance) => {
    // add to filespath if doesn't exist already
    if (!project.filepaths.includes(translationInstance.path)) {
        project.filepaths.push(translationInstance.path);
    }
};
/**
 * Mutates projectInstance by updating additionalPaths
 * @param {object} project
 * @param {object} translationInstance
 * @returns {undefined}
 */
const addAdditionalPaths = (project, translationInstance) => {
    const { uid, path: currFilePath } = translationInstance;
    const projectInstance = project.instances[uid];
    // If the currFilePath doesn't match the existing path,
    // add currFilePath to the additionalPaths array
    if (projectInstance.path !== currFilePath &&
        !projectInstance.additionalPaths.includes(currFilePath)) {
        projectInstance.additionalPaths.push(currFilePath);
    }
};
/**
 *
 * what should the bundle look like?
 * app.domains: {
 *  uids: [],
 *  instances: {
 *    '123abc': {
 *      uid: '1234abc',
 *      path: path,
 *      ...
 *    },
 *  }
 *
 * then consume this json to create a formatted yaml
 *
 * @exports
 * @param {array} raw - metadata for translationHelpers as an array of JS objects
 * @returns {object} extractions - tied extraction bundles
 */
const tieBundle = (raw) => {
    const extractions = raw.reduce((acc, currTranslationInstance) => {
        const { project } = currTranslationInstance;
        // If the project doesn't exist in the accumulator, add it as a project at
        // the base level of the accumulator.
        // Begin tracking the uids at the project level in an array.
        // Set the uid of the given extractionInstance as a property of the project by uid.
        if (!acc.hasOwnProperty(project)) {
            acc[project] = {};
            acc[project].uids = [];
            acc[project].filepaths = [];
            acc[project].instances = {};
        }
        const projectExtraction = acc[project];
        if (!projectExtraction) {
            throw new Error(`Project '${project}' has not been initialized`);
        }
        initializeTranslationInstance(projectExtraction, currTranslationInstance);
        addFilePaths(projectExtraction, currTranslationInstance);
        addAdditionalPaths(projectExtraction, currTranslationInstance);
        return acc;
    }, {});
    return { extractions };
};
exports.tieBundle = tieBundle;
