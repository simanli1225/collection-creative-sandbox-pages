#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = require("lodash"); // eslint-disable-line
const commander_1 = tslib_1.__importDefault(require("commander"));
const pretty_bytes_1 = tslib_1.__importDefault(require("pretty-bytes"));
const pretty_ms_1 = tslib_1.__importDefault(require("pretty-ms"));
const extract_1 = require("../modules/extract");
const utils_1 = require("../utils");
const CWD = process.cwd();
const DEFAULT_IGNORE_DIRS = [
    'node_modules/**',
    '**/node_modules/**',
    'lib/**',
    '**/lib/**',
    'cjs/**',
    '**/cjs/**',
    'dist/**',
    '**/dist/**',
];
let bundlePath;
let bundleDetailsPath;
let config;
let dry;
let extractionTime;
let name;
let out;
let print;
let src;
let extractDetails;
commander_1.default
    .name('sqs-i18n extract')
    .usage('<src-paths...> [options]')
    .arguments('<src-paths...>')
    .option('-o, --output-dir <path>', 'Directory to output the extraction JSON, defaults to cwd', CWD)
    .option('-i, --ignore-config <path>', 'Relative path to ignore config, which should contain file globs.')
    .option('-n, --file-name <name>', "The file name for the json bundle, defaults to 'translationExtraction'", 'translationExtraction')
    .option('--print', 'Print resultant document to stdout')
    .option('--dry-run', 'Run command but do not write results to file')
    .option('-q, --quiet', 'Suppress output', false)
    .option('--extract-details', 'Extract an additional file with extraction bundle details', false)
    .action(function (srcPaths, options) {
    srcPaths.forEach((srcPath) => (0, utils_1.validatePath)(srcPath));
    src = srcPaths;
    if (options.outputDir) {
        (0, utils_1.validatePath)(options.outputDir, 'dir');
        out = options.outputDir;
    }
    if (options.fileName) {
        name = options.fileName;
    }
    extractionTime = Date.now();
    config = {
        bundlePath: path_1.default.resolve(out),
        ignorePathGlobs: DEFAULT_IGNORE_DIRS,
        ...options,
    };
    dry = options.dryRun;
    print = options.print;
    extractDetails = options.extractDetails;
})
    .parse(process.argv);
if (!config) {
    throw new Error('[@sqs/i18n-build] Config has not been initialized');
}
const options = commander_1.default.opts();
if (options.ignoreConfig) {
    const ignorePathGlobs = [];
    try {
        // Ignore config is relative to where the command is called, typically site-server root
        // The reason we accept and modify globs here is because globs is the format
        // supported by jscodeshift (for the codemod, which should consume
        // the same ignoreConfig as this i18n-bundle).
        const ignoreConfigFilePath = path_1.default.resolve(CWD, options.ignoreConfig);
        const ignoreGlobsFromFile = fs_1.default
            .readFileSync(ignoreConfigFilePath, 'utf8')
            .split('\n')
            // Trim whitespace
            .map(lodash_1.trim)
            // Ignore empty lines
            .filter((line) => !(0, lodash_1.isEmpty)(line));
        // Because ignoreConfig is in a .gitignore-style format (which jscodeshift
        // uses), this mapping does the same thing jscodeshift does internally.
        // see: https://github.com/facebook/jscodeshift/blob/master/src/ignoreFiles.js#L14
        // .gitignore format: https://git-scm.com/docs/gitignore#_pattern_format
        ignoreGlobsFromFile.forEach((glob) => {
            // Ignore commented out lines
            if (glob && typeof glob === 'string' && !(0, lodash_1.startsWith)(glob, '#')) {
                if (glob.indexOf('/') === -1) {
                    ignorePathGlobs.push(`**/${glob}`);
                }
                else if ((0, lodash_1.endsWith)(glob, '/')) {
                    ignorePathGlobs.push(`**/${glob}**`);
                    ignorePathGlobs.push(`${glob}**`);
                }
                ignorePathGlobs.push(glob);
            }
        });
        config.ignorePathGlobs = (config.ignorePathGlobs || []).concat(ignorePathGlobs);
    }
    catch (e) {
        throw new Error(`[@sqs/i18n-build] Cannot parse ignoreConfig: ${e.message}`);
    }
}
if (!src) {
    throw new Error("'src' not initialized");
}
// extract strings
(0, extract_1.extractStrings)(src, config)
    .then((extracted) => {
    const results = (0, extract_1.tieBundle)(extracted);
    const { extractions } = results;
    const projectKeys = Object.keys(extractions);
    const bundleDetails = [];
    let totalYamlStringsCount = 0;
    bundlePath = path_1.default.join(out, `${name}.json`);
    bundleDetailsPath = path_1.default.join(out, `${name}-details.json`);
    if (extractDetails) {
        // If the --extract-details option is passed in push the bundle details for each project
        projectKeys.forEach((key) => {
            const filepaths = extractions[key].filepaths;
            if (!filepaths) {
                throw new Error('No filepaths');
            }
            const filepathsCount = filepaths.length;
            const strings = extractions[key].uids;
            if (!strings) {
                throw new Error('No strings');
            }
            const stringsCount = strings.length;
            totalYamlStringsCount += stringsCount;
            const output = {};
            output[key] = {
                stringsCount,
                filepathsCount,
                filepaths,
            };
            bundleDetails.push(output);
        });
    }
    // Delete the filepath and uids key from the extraction so we dont see it in the bundle/non-detail output
    projectKeys.forEach((key) => {
        // @ts-expect-error
        delete extractions[key].filepaths;
        // @ts-expect-error
        delete extractions[key].uids;
    });
    const extractOutput = JSON.stringify(results, null, 2);
    if (print) {
        console.log('---- Extraction output ----');
        console.log(extractOutput);
        console.log('----------------------------');
        if (extractDetails) {
            console.log('---- Extraction details ----');
            console.log(JSON.stringify(bundleDetails, null, 2));
            console.log('----------------------------');
        }
    }
    if (!dry) {
        fs_1.default.writeFileSync(bundlePath, extractOutput, 'utf8');
        console.log('----------------------------');
        console.log(`Extraction JSON saved to: ${path_1.default.relative(CWD, bundlePath)}\n`);
        if (extractDetails) {
            // If the --extract-details option is passed in write the details into a file
            fs_1.default.writeFileSync(bundleDetailsPath, JSON.stringify({ bundleDetails }, null, 2), 'utf8');
            console.log(`Extraction details saved to: ${path_1.default.relative(CWD, bundleDetailsPath)}\n`);
        }
        console.log(`Extraction JSON Size: ${(0, pretty_bytes_1.default)(fs_1.default.lstatSync(bundlePath).size)}`);
        console.log(`Number of bundles within extraction: ${projectKeys.length}`);
        console.log(`Number of strings written to YAML: ${totalYamlStringsCount}`);
        console.log(`Extraction duration: ${(0, pretty_ms_1.default)(Date.now() - extractionTime)}`);
        console.log('----------------------------');
    }
})
    .catch((e) => {
    console.log(e);
    // Throwing an exception here doesn't set a non-zero exit code. So we manually set an exit code 1 to
    // force the process to fail, instead of continuing to to scan files in extractStringsFromDirs.
    process.exit(1); // eslint-disable-line
});
