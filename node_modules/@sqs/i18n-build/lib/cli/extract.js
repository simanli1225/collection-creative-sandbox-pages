#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * sqs-i18n-extract
 *
 * This module is a temporary home of a new command `sqs-i18n-extract` intended to replace both
 * existing extract and generateYaml commands
 */
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const promises_1 = tslib_1.__importDefault(require("node:fs/promises"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const commander_1 = tslib_1.__importDefault(require("commander"));
const pretty_bytes_1 = tslib_1.__importDefault(require("pretty-bytes"));
const utils_1 = require("../utils");
const constants_1 = require("../utils/constants");
const extract_1 = require("../modules/extract");
const generateYaml_1 = require("../modules/generateYaml");
const DEFAULT_IGNORE_PATHS = ['node_modules/', 'cjs/', 'lib/', 'dist/', '.next/'];
const CWD = process.cwd();
const IGNORE_CONFIG_PATH = node_path_1.default.resolve(CWD, '.i18nignore');
const YAML_PATH = node_path_1.default.resolve(CWD, constants_1.TRANSLATIONS_STRINGS_DIRECTORY);
const EXTRACTION_PATH = node_path_1.default.resolve(CWD, constants_1.TRANSLATIONS_META_DIRECTORY);
const JSON_EXTRACTION_PATH = node_path_1.default.resolve(EXTRACTION_PATH, 'i18n-meta-data.json');
const EXTRACT_DIRECTORIES = [];
/**
 * `.i18nignore` supports .gitignore-style format for globbing
 * This helper transforms rules into mapping for minimatch
 * See {@link ./src/utils/crawl.ts}
 *
 * @param rules
 */
function transformIgnorePatterns(rules) {
    const globs = [];
    rules.forEach((rule) => {
        // Ignore commented out lines
        if (lodash_1.default.isString(rule) && !lodash_1.default.startsWith(rule, '#')) {
            if (rule.indexOf('/') === -1) {
                globs.push(`**/${rule}`);
            }
            else if (lodash_1.default.endsWith(rule, '/')) {
                globs.push(`**/${rule}**`);
                globs.push(`${rule}**`);
            }
            globs.push(rule);
        }
    });
    return globs;
}
async function getIgnoreDirectories() {
    const baseRules = [...DEFAULT_IGNORE_PATHS];
    if (!(0, utils_1.isValidPath)(IGNORE_CONFIG_PATH, 'file')) {
        return baseRules;
    }
    console.info('Detected .i18nignore config file');
    try {
        const ignoreFileContent = await promises_1.default.readFile(IGNORE_CONFIG_PATH, 'utf8');
        const fileRules = ignoreFileContent
            .split('\n')
            .map(lodash_1.default.trim) // Trim whitespace
            .filter((line) => !lodash_1.default.isEmpty(line)); // Ignore empty lines
        return lodash_1.default.uniq([...baseRules, ...fileRules]);
    }
    catch (e) {
        throw new commander_1.default.InvalidOptionArgumentError(`Error while reading .i18nignore file: ${e.message}`);
    }
}
async function validateDirectories(dirs) {
    if (!(0, utils_1.isValidPath)(EXTRACTION_PATH, 'dir')) {
        console.info(`Creating missing directory: ${node_path_1.default.relative(CWD, EXTRACTION_PATH)}...`);
        await promises_1.default.mkdir(EXTRACTION_PATH, { recursive: true });
    }
    if (!(0, utils_1.isValidPath)(YAML_PATH, 'dir')) {
        console.info(`Creating missing directory: ${node_path_1.default.relative(CWD, YAML_PATH)}...`);
        await promises_1.default.mkdir(YAML_PATH, { recursive: true });
    }
    dirs.forEach((directory) => {
        if (!(0, utils_1.isValidPath)(directory, 'dir')) {
            throw new commander_1.default.InvalidOptionArgumentError(`Invalid file or directory: ${directory}`);
        }
        EXTRACT_DIRECTORIES.push(directory);
    });
    if (EXTRACT_DIRECTORIES.length === 0) {
        EXTRACT_DIRECTORIES.push(CWD);
    }
}
async function main() {
    console.time('Extraction Duration');
    commander_1.default
        // eslint-disable-next-line import/no-commonjs
        .version(require('../../package').version, '-v, --version', 'output the current version')
        .name('sqs-i18n-extract')
        .description('Extracts i18n strings from Frontend code')
        .arguments('[directory...]')
        .option('-d, --dry-run', 'run command but do not write results to disk', false)
        .option('--enforce-project-spelling <spellings...>', 'Provide a list of project keys for which variations are not allowed')
        .action(validateDirectories);
    const options = (await commander_1.default.parseAsync(process.argv)).opts();
    const ignorePaths = await getIgnoreDirectories();
    const ignorePathGlobs = transformIgnorePatterns(ignorePaths);
    const extractedResults = await (0, extract_1.extractStrings)(EXTRACT_DIRECTORIES, {
        ignorePathGlobs,
        bundlePath: EXTRACTION_PATH,
        enforceProjectSpelling: options.enforceProjectSpelling,
    });
    const { extractions } = (0, extract_1.tieBundle)(extractedResults);
    const projects = Object.keys(extractions);
    const trimmedExtraction = projects.reduce((extraction, projectName) => {
        extraction[projectName] = lodash_1.default.pick(extractions[projectName], 'instances');
        return extraction;
    }, {});
    const perProjectStats = projects.map((projectName) => {
        const extractedStrings = extractions[projectName].instances;
        const stringIds = Object.keys(extractedStrings);
        const notesCount = stringIds.reduce((count, stringId) => {
            if (extractedStrings[stringId].notes) {
                count = count + 1;
            }
            return count;
        }, 0);
        return {
            project: projectName,
            notes: notesCount,
            strings: stringIds.length,
        };
    });
    const extractOutput = JSON.stringify({ extractions: trimmedExtraction }, null, 2);
    const totalStrings = perProjectStats.reduce((n, { strings }) => n + strings, 0);
    const totalNotes = perProjectStats.reduce((n, { notes }) => n + notes, 0);
    console.log('----------------------------');
    console.log(`Extracted projects: ${projects.length}`);
    console.log(`Total strings: ${totalStrings}`);
    console.log(`Total notes: ${totalNotes}`);
    if (projects.length > 1 && !options.dryRun) {
        perProjectStats.sort((a, b) => b.strings - a.strings);
        console.table(perProjectStats, ['project', 'strings', 'notes']);
    }
    if (!options.dryRun) {
        await promises_1.default.writeFile(JSON_EXTRACTION_PATH, extractOutput, 'utf8');
        console.log(`Extraction JSON saved to: ${node_path_1.default.relative(CWD, JSON_EXTRACTION_PATH)} (${(0, pretty_bytes_1.default)((await promises_1.default.lstat(JSON_EXTRACTION_PATH)).size)})`);
    }
    console.log('----------------------------');
    await (0, generateYaml_1.build)(trimmedExtraction, YAML_PATH, options.dryRun);
    // Remove unused yamls before generation
    (0, generateYaml_1.removeUnusedYamls)(projects, YAML_PATH);
    console.timeEnd('Extraction Duration');
}
main();
