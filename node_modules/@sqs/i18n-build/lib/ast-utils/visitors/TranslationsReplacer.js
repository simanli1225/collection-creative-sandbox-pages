"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranslationsReplacer = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const generator_1 = tslib_1.__importDefault(require("@babel/generator"));
const validate_1 = tslib_1.__importDefault(require("../validate"));
const index_1 = require("./../errors/index");
const I18nComponent = tslib_1.__importStar(require("../parse/components"));
const I18nFunction = tslib_1.__importStar(require("../parse/functions"));
const hash_1 = require("../utils/hash");
const generate_1 = require("../generate");
function throwTranslationMismatch(message, translation, path) {
    throw new Error(`${message}:\n` +
        `Translation: ${JSON.stringify(translation, null, 2)}\n` +
        `Source: ${(0, generator_1.default)(path.node).code}\n`);
}
exports.TranslationsReplacer = {
    JSXElement: {
        exit(path) {
            if (validate_1.default.isTComponent(path.node)) {
                const results = I18nComponent.parseTComponent(path.node);
                if (results.errors) {
                    throw new index_1.InvalidUsageError({
                        message: results.errors.join('\n'),
                        node: path.node,
                    });
                }
                const { uid, translationId } = results.extractionResult;
                const translation = (0, hash_1.resolveTranslation)(this.translations, uid, translationId);
                if (translation) {
                    if (!lodash_1.default.isString(translation)) {
                        throwTranslationMismatch('Cannot replace static translation with non-string value', translation, path);
                    }
                    path.replaceWith((0, generate_1.transformTComponent)(path.node, translation));
                    path.shouldSkip = true;
                    this.transformed = true;
                }
            }
            if (validate_1.default.isPluralComponent(path.node)) {
                const results = I18nComponent.parsePluralComponent(path.node);
                if (results.errors) {
                    throw new index_1.InvalidUsageError({
                        message: results.errors.join('\n'),
                        node: path.node,
                    });
                }
                const { uid, translationId } = results.extractionResult;
                const translation = (0, hash_1.resolveTranslation)(this.translations, uid, translationId);
                if (translation) {
                    if (!Array.isArray(translation) && !lodash_1.default.isObject(translation)) {
                        throwTranslationMismatch('Cannot replace dynamic translation with non-array value', translation, path);
                    }
                    path.replaceWith((0, generate_1.transformPluralComponent)(path.node, translation));
                    path.shouldSkip = true;
                    this.transformed = true;
                }
            }
        },
    },
    CallExpression: {
        exit(path) {
            if (validate_1.default.isTFunction(path.node)) {
                const results = I18nFunction.parseTFunction(path.node);
                if (results.errors) {
                    throw new index_1.InvalidUsageError({
                        message: results.errors.join('\n'),
                        node: path.node,
                    });
                }
                const { uid, translationId } = results.extractionResult;
                const translation = (0, hash_1.resolveTranslation)(this.translations, uid, translationId);
                if (translation) {
                    if (!lodash_1.default.isString(translation)) {
                        throwTranslationMismatch('Cannot replace static translation with non-string value', translation, path);
                    }
                    path.replaceWith((0, generate_1.transformTFunction)(path.node, translation));
                    path.shouldSkip = true;
                    this.transformed = true;
                }
            }
            if (validate_1.default.isPluralizeFunction(path.node)) {
                const results = I18nFunction.parsePluralizeFunction(path.node);
                if (results.errors) {
                    throw new index_1.InvalidUsageError({
                        message: results.errors.join('\n'),
                        node: path.node,
                    });
                }
                const { uid, translationId } = results.extractionResult;
                const translation = (0, hash_1.resolveTranslation)(this.translations, uid, translationId);
                if (translation) {
                    if (!Array.isArray(translation) && !lodash_1.default.isObject(translation)) {
                        throwTranslationMismatch('Cannot replace dynamic translation with non-array value', translation, path);
                    }
                    path.replaceWith((0, generate_1.transformPluralizeFunction)(path.node, translation));
                    path.shouldSkip = true;
                    this.transformed = true;
                }
            }
        },
    },
};
