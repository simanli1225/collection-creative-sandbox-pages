"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoConfigImporter = void 0;
// @ts-expect-error: this package does not ship with TS types
const helper_module_imports_1 = require("@babel/helper-module-imports");
const helpers_1 = require("../validate/helpers");
/**
 * Checks if import path starts with "@sqs/"
 *
 * @param packageName {string}
 * @returns {boolean}
 */
function isSqsScopedPackagePath(importPath) {
    return importPath.startsWith('@sqs/');
}
/**
 * Returns package name from '@sqs/core-components/some/path'
 *
 * @param importPath
 */
function getPackageName(importPath) {
    const [pkgScope, pkgName] = importPath.split('/', 2);
    if (pkgName) {
        return [pkgScope, pkgName].join('/');
    }
    // if pkgName is undefined then there are no slashes
    return importPath;
}
exports.AutoConfigImporter = {
    Program: {
        enter(_, state) {
            state.transformed = false;
            state.packagesToAdd = new Set();
        },
        exit(path, state) {
            const { packagesToAdd } = state;
            if (packagesToAdd.size === 0) {
                return;
            }
            const reverseOrderedImports = Array.from(packagesToAdd).reverse();
            // Reverse order because `addSideEffect` inserts new states at the beginning
            for (const importPath of reverseOrderedImports) {
                // avoid circular adding circular dependencies when filePath == importPath
                if (state.filePath && state.filePath.endsWith(importPath)) {
                    return;
                }
                (0, helper_module_imports_1.addSideEffect)(path, importPath);
                state.transformed = true;
            }
        },
    },
    ImportDeclaration(path, state) {
        const importName = path.node.source.value;
        if (!isSqsScopedPackagePath(importName)) {
            return;
        }
        const packageName = getPackageName(importName);
        const { autoImportPackagesConfig } = state.opts;
        // ensure an import mapping exists
        if (autoImportPackagesConfig[packageName]) {
            const packageConfigImport = autoImportPackagesConfig[packageName];
            state.packagesToAdd.add(packageConfigImport);
        }
    },
    CallExpression(path, state) {
        const expression = path.node;
        if ((0, helpers_1.isRequireOrImportStatement)(expression)) {
            const importName = expression.arguments[0].value;
            if (!isSqsScopedPackagePath(importName)) {
                return;
            }
            const packageName = getPackageName(importName);
            const { autoImportPackagesConfig } = state.opts;
            // ensure an import mapping exists
            if (autoImportPackagesConfig[packageName]) {
                const packageConfigImport = autoImportPackagesConfig[packageName];
                state.packagesToAdd.add(packageConfigImport);
            }
        }
    },
};
