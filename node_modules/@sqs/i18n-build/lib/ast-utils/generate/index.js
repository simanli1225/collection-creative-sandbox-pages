"use strict";
/**
 * This module leverages a variety of babel-types API to transform and re-create code
 * For reference see https://babeljs.io/docs/core-packages/babel-types/
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTComponent = transformTComponent;
exports.transformTFunction = transformTFunction;
exports.transformPluralComponent = transformPluralComponent;
exports.transformPluralizeFunction = transformPluralizeFunction;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("@babel/types"));
const constants_1 = tslib_1.__importDefault(require("../utils/constants"));
const { T_COMPONENT_NAME, T_FUNCTION_NAME, PLURAL_COMPONENT_NAME, PLURALIZE_FUNCTION_NAME, FORMS_TAG, TRANSLATION_ID_TAG, } = constants_1.default;
function attributesFilter(params) {
    const { name } = params;
    return !(name && name.name === TRANSLATION_ID_TAG);
}
function argumentsFilter({ key }) {
    return !(t.isIdentifier(key) && key.name === TRANSLATION_ID_TAG);
}
/**
 * Transforms a valid T function to include the `project` and `notes` attributes.
 * Both are needed to calculate the translation hash in run-time to support the visual-context tool.
 *
 * @param {JSXElement} tElement - T Component node
 * @param {string} translation
 * @return {JSXElement} JSXElement - transformed component
 */
function transformTComponent(tElement, translation) {
    return t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier(T_COMPONENT_NAME), tElement.openingElement.attributes.filter((attr) => attributesFilter(attr))), t.jsxClosingElement(t.jsxIdentifier(T_COMPONENT_NAME)), [t.jsxExpressionContainer(t.stringLiteral(translation))], false);
}
/**
 * Transforms a valid T function to include the `project` and `notes` arguments.
 * Both are exclusively needed to calculate the translation hash in run-time to support the visual-context tool.
 *
 * @param {CallExpression} tExpression - function node
 * @param {string} translation
 * @return {CallExpression} t - transformed node
 */
function transformTFunction(tExpression, translation) {
    // The `t()` arguments array consist of [stringValue: string, substitution: object, options: object]
    // Ex: t('Hi, my name is {name}', { name: 'Alex' }, { project: 'i18n-ui', notes: 'greeting text' })
    const args = tExpression.arguments.slice();
    args[0] = t.stringLiteral(translation);
    // Remove `translationId` argument
    const filteredOptions = args[2].properties.filter((prop) => argumentsFilter(prop));
    args[2] = t.objectExpression(filteredOptions);
    return t.callExpression(t.identifier(T_FUNCTION_NAME), args);
}
/**
 * Transforms a valid Plural component to remove unnecessary run-time attributes
 *
 * @param {JSXElement} pluralElement - Plural Component node
 * @param {TranslationOrPluralValue} translation
 * @return {JSXElement} JSXElement - transformed component
 */
function transformPluralComponent(pluralElement, translation) {
    const formsNode = pluralElement.openingElement.attributes.find((attr) => t.isJSXAttribute(attr) && attr.name.name === FORMS_TAG);
    if (!formsNode) {
        throw new Error('[@sqs/i18n-build] Could not find forms node');
    }
    formsNode.value = t.jsxExpressionContainer(t.objectExpression(Object.keys(translation).map((key) => t.objectProperty(t.identifier(key), t.stringLiteral(translation[key])))));
    return t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier(PLURAL_COMPONENT_NAME), pluralElement.openingElement.attributes.filter((attr) => attributesFilter(attr)), true), null, [], true);
}
/**
 * Transforms a valid pluralize function to remove unnecessary run-time attributes
 *
 * @param {CallExpression} pluralizeExpression - function node
 * @param {TranslationOrPluralValue} translation
 * @return {CallExpression} t - transformed node
 */
function transformPluralizeFunction(pluralizeExpression, translation) {
    // The `pluralize()` arguments array consist of
    // [formsObject: object, n: number, substitutionsObject: object, options: object]
    // Ex: pluralize({
    //       one: 'there is a single {color} dog',
    //       other: 'there are {%n} {color} dogs'
    //     },
    //     4,
    //     { color: 'brown' },
    //     { project: 'PROJECT' }
    //   )
    // )
    const args = pluralizeExpression.arguments.slice();
    args[0] = t.objectExpression(Object.keys(translation).map((key) => t.objectProperty(t.identifier(key), t.stringLiteral(translation[key]))));
    // Remove `translationId` argument
    const filteredOptions = args[3].properties.filter((prop) => argumentsFilter(prop));
    args[3] = t.objectExpression(filteredOptions);
    return t.callExpression(t.identifier(PLURALIZE_FUNCTION_NAME), args);
}
