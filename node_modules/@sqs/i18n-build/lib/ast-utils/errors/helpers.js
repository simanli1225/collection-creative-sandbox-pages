"use strict";
/**
 * A module for getting errors messages when validation fails
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_MESSAGES = void 0;
exports.getJSXComponentErrors = getJSXComponentErrors;
exports.getVanillaFunctionErrors = getVanillaFunctionErrors;
const tslib_1 = require("tslib");
const constants_1 = tslib_1.__importDefault(require("../utils/constants"));
const jsx_1 = require("../utils/jsx");
const object_1 = require("../utils/object");
const string_1 = require("../utils/string");
const helpers_1 = require("../validate/helpers");
const { NOTES_TAG, PROJECT_TAG, TRANSLATION_ID_TAG } = constants_1.default;
var ERROR_MESSAGES;
(function (ERROR_MESSAGES) {
    // <Plural> and pluralize()
    ERROR_MESSAGES["PLURALIZE_FIRST_PARAM_ERROR"] = "1st param (forms) should be an object like: \n{ one: 'there is a single {color} dog, other: 'there are {%n} {color} dogs'}";
    ERROR_MESSAGES["PLURALIZE_SECOND_PARAM_ERROR"] = "2nd param (a number that identifies which plural form to use) cannot be null.";
    ERROR_MESSAGES["PLURALIZE_NUM_PARAMS_ERROR"] = "pluralize() function takes exactly 4 arguments: \nformsObject, n as selectValue, substitutionsObject, and options (where your project goes). \nPlease see https://i18n-docs.squarespace.net/docs/api/i18n-ui-object#pluralize for more details.";
    ERROR_MESSAGES["PLURAL_COMPONENT_FORMS_ERROR"] = "Prop 'forms' is required to match single and plural translations for plural component. \nIt should have the shape \nforms={{ one: 'there is a single {color} dog', other: 'there are {%n} {color} dogs' }} ";
    ERROR_MESSAGES["PLURAL_COMPONENT_N_ERROR"] = "Prop 'n' is required to determine proper plural form from forms: it is the number value used to determine string output.";
    ERROR_MESSAGES["PLURAL_COMPONENT_SELF_CLOSING_ERROR"] = "Plural component cannot contain children. \nPlease self-close the component like so: <Plural />";
    // <T> and t()
    ERROR_MESSAGES["T_COMPONENT_ERROR_VALID_CHILDREN"] = "<T> component should wrap valid children";
    ERROR_MESSAGES["T_COMPONENT_ERROR_SELF_CLOSING"] = "<T> component must contain children. Children should resolve to strings and can have substitutions. \nExample: <T project='app.greeting' name='Bob'>{'Hello {name}'}</T>";
    ERROR_MESSAGES["T_FUNCTION_FIRST_PARAM_ERROR"] = "1st param (value) should be a string";
    ERROR_MESSAGES["T_FUNCTION_NUM_PARAMS_ERROR"] = "t() function takes exactly 3 arguments: stringValue, substitutionsObject, and options.";
    ERROR_MESSAGES["T_FUNCTION_SUBS_ERROR"] = "Invalid substitutions object. You can either leave as null, or make sure it is formatted correctly, as an object.";
    // project and notes
    ERROR_MESSAGES["PROJECT_ERROR_VANILLA_FUNCTION"] = "'project' key-value pair is invalid. It cannot be an empty string. For example, for a t() function: \nt('Okay', null, { project: 'web.campaigns' })";
    ERROR_MESSAGES["PROJECT_ERROR_JSX"] = "Project (which is required) is not specified.";
    ERROR_MESSAGES["PROJECT_ERROR_WS"] = "Project name cannot contain whitespace characters";
    ERROR_MESSAGES["NOTES_ERROR"] = "Notes is improperly formatted. Make sure it resolves to a string value.";
    ERROR_MESSAGES["MISSING_PROJECT_ERROR_VANILLA_FUNCTION"] = "'project' attribute is missing. For example, for a t() function: \nt('Okay', null, { project: 'web.campaigns' })";
    // translationId
    ERROR_MESSAGES["MISSING_TRANSLATION_ID"] = "Missing translationId";
})(ERROR_MESSAGES || (exports.ERROR_MESSAGES = ERROR_MESSAGES = {}));
/**
 * Checks for JSX component errors for <T> and <Pluralize />.
 * Returns either a string with all errors related to project, notes, and translationId
 * OR an empty string if no such errors are found.
 *
 * @param {Node} node
 * @returns {ERROR_MESSAGES[]}
 */
function getJSXComponentErrors(node) {
    const errors = [];
    const projectValue = (0, jsx_1.getAttributeValue)(node, PROJECT_TAG);
    if (!(0, string_1.isNonEmptyString)(projectValue)) {
        errors.push(ERROR_MESSAGES.PROJECT_ERROR_JSX);
    }
    if ((0, string_1.hasWhitespace)(projectValue)) {
        errors.push(ERROR_MESSAGES.PROJECT_ERROR_WS);
    }
    if (!(0, helpers_1.isValidNotes)((0, jsx_1.getAttributeValue)(node, NOTES_TAG))) {
        errors.push(ERROR_MESSAGES.NOTES_ERROR);
    }
    if (!(0, helpers_1.isValidTranslationId)((0, jsx_1.getAttributeValue)(node, TRANSLATION_ID_TAG))) {
        errors.push(ERROR_MESSAGES.MISSING_TRANSLATION_ID);
    }
    return errors;
}
/**
 * Checks for function errors for t() and pluralize().
 * Checks for project, notes, translationId, and properly formatted subs object.
 * If no errors, returns empty array.
 *
 * @param {object} subsObject, {Node} extractionObject
 * @returns {ERROR_MESSAGES[]}
 */
function getVanillaFunctionErrors(subsObject, extractionObject) {
    const errors = [];
    const projectNode = (0, object_1.getObjectPropertyByName)(extractionObject, PROJECT_TAG);
    const notesNode = (0, object_1.getObjectPropertyByName)(extractionObject, NOTES_TAG);
    const translationIdNode = (0, object_1.getObjectPropertyByName)(extractionObject, TRANSLATION_ID_TAG);
    if (!projectNode) {
        errors.push(ERROR_MESSAGES.MISSING_PROJECT_ERROR_VANILLA_FUNCTION);
    }
    if (projectNode && !(0, string_1.isNonEmptyString)(projectNode.value)) {
        errors.push(ERROR_MESSAGES.PROJECT_ERROR_VANILLA_FUNCTION);
    }
    if (projectNode && (0, string_1.hasWhitespace)(projectNode.value)) {
        errors.push(ERROR_MESSAGES.PROJECT_ERROR_WS);
    }
    if (!(0, helpers_1.isValidNotes)(notesNode && notesNode.value)) {
        errors.push(ERROR_MESSAGES.NOTES_ERROR);
    }
    if (!(0, helpers_1.isValidTranslationId)(translationIdNode && translationIdNode.value)) {
        errors.push(ERROR_MESSAGES.MISSING_TRANSLATION_ID);
    }
    if (!(0, helpers_1.isValidSubs)(subsObject)) {
        errors.push(ERROR_MESSAGES.T_FUNCTION_SUBS_ERROR);
    }
    return errors;
}
