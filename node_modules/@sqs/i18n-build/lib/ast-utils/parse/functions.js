"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTFunction = exports.parsePluralizeFunction = void 0;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("@babel/types"));
const string_1 = require("../utils/string");
const object_1 = require("../utils/object");
const index_1 = require("../index");
const hash_1 = require("../utils/hash");
const PLURALIZE_FUNCTION_VALUE_POSITION = 0;
const PLURALIZE_FUNCTION_EXTRACTION_OBJECT_POSITION = 3;
const T_FUNCTION_VALUE_POSITION = 0;
const T_FUNCTION_EXTRACTION_OBJECT_POSITION = 2;
function getExtractionObject(node, functionArity) {
    const extractionObject = node.arguments[functionArity];
    const projectProperty = (0, object_1.getObjectPropertyByName)(extractionObject, index_1.PROJECT_TAG);
    const notesProperty = (0, object_1.getObjectPropertyByName)(extractionObject, index_1.NOTES_TAG);
    const translationIdProperty = (0, object_1.getObjectPropertyByName)(extractionObject, index_1.TRANSLATION_ID_TAG);
    return {
        project: (0, string_1.stringlikeToStringLiteral)(projectProperty.value),
        translationId: translationIdProperty
            ? (0, string_1.stringlikeToStringLiteral)(translationIdProperty.value)
            : null,
        // Ignore null values for notes
        notes: notesProperty && !t.isNullLiteral(notesProperty.value)
            ? (0, string_1.stringlikeToStringLiteral)(notesProperty.value)
            : '',
    };
}
function getPluralizeFunctionExtractionObject(node) {
    return getExtractionObject(node, PLURALIZE_FUNCTION_EXTRACTION_OBJECT_POSITION);
}
function getTFunctionExtractionObject(node) {
    return getExtractionObject(node, T_FUNCTION_EXTRACTION_OBJECT_POSITION);
}
/**
 * pluralize(
 *   { one: '', other: '' },
 *   selectValue,
 *   substitutions object,
 *   { project: 'PROJECT', notes: 'TRANSLATOR NOTES' }
 * );
 */
function getPluralizeValues(node) {
    const value = node.arguments[PLURALIZE_FUNCTION_VALUE_POSITION];
    return value.properties.reduce((acc, prop) => {
        const { name } = prop.key;
        acc[name] = (0, string_1.stringlikeToStringLiteral)(prop.value);
        return acc;
    }, {});
}
/**
 * t(
 *   stringValue,
 *   substitutions object,
 *   { project: 'PROJECT', notes: 'TRANSLATOR NOTES' }
 * )
 */
function getTFunctionValue(node) {
    const value = node.arguments[T_FUNCTION_VALUE_POSITION];
    return value && !t.isNullLiteral(value) ? (0, string_1.stringlikeToStringLiteral)(value) : null;
}
/**
 * Finds any invalid usage errors. If none, parses a valid pluralize function
 *
 * @param {CallExpression} node
 * @returns {translationInstance}
 */
const parsePluralizeFunction = (node) => {
    const errors = index_1.I18nValidate.getPluralizeFunctionErrors(node);
    if (errors.length > 0) {
        return {
            errors,
        };
    }
    const value = getPluralizeValues(node);
    const type = index_1.PLURALIZE_FUNCTION_NAME + '()';
    const { project, notes, translationId } = getPluralizeFunctionExtractionObject(node);
    const uid = (0, hash_1.hash)(project, value, notes);
    return {
        extractionResult: {
            type,
            notes,
            project,
            translationId,
            value,
            uid,
        },
    };
};
exports.parsePluralizeFunction = parsePluralizeFunction;
/**
 * Finds any invalid usage errors. If none, parses a valid t function
 *
 * @param {CallExpression} node
 * @returns {ParseMetaData} Will return either `errors` or `ExtractResult`
 */
const parseTFunction = (node) => {
    const errors = index_1.I18nValidate.getTFunctionErrors(node);
    if (errors.length > 0) {
        return {
            errors,
        };
    }
    const value = getTFunctionValue(node);
    const type = index_1.T_FUNCTION_NAME + '()';
    const { project, notes, translationId } = getTFunctionExtractionObject(node);
    const uid = (0, hash_1.hash)(project, value, notes);
    return {
        extractionResult: {
            type,
            notes,
            project,
            translationId,
            value,
            uid,
        },
    };
};
exports.parseTFunction = parseTFunction;
