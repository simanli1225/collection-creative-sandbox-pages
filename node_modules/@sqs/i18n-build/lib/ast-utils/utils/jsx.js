"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttributeValue = getAttributeValue;
exports.isWrapper = isWrapper;
exports.getJSXIdentifierName = getJSXIdentifierName;
exports.isBlockTag = isBlockTag;
exports.isNotAlreadyWrapped = isNotAlreadyWrapped;
exports.copyJSXElement = copyJSXElement;
exports.hasWhitespaceChildren = hasWhitespaceChildren;
exports.hasInlineChildrenWithTextContent = hasInlineChildrenWithTextContent;
exports.isEqualElementTagName = isEqualElementTagName;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("@babel/types"));
const tagTypes_1 = require("./tagTypes");
const string_1 = require("./string");
/**
 * Returns the value of the attrName component
 * attribute if exists, otherwise returns null
 *
 * @param {object} node
 * @return {Node}
 */
function getAttributeValue(node, attrName) {
    if (!node.hasOwnProperty('openingElement')) {
        return null;
    }
    const astNode = node.openingElement.attributes.find((attr) => {
        return t.isJSXAttribute(attr) && attr.name.name === attrName;
    });
    if (!astNode) {
        return null;
    }
    return astNode.value || null;
}
/**
 * Determines if <T> component has children that also resolve to strings
 * (JSXText, JSXExpressionContainer, and more. See "resolvesToString")
 *
 * @param {object} node
 * @param {string} [componentName=T]
 * @return {boolean}
 */
function isWrapper(node, componentName) {
    return (node.hasOwnProperty('closingElement') &&
        node?.closingElement?.name?.name === componentName &&
        node.children.length > 0 &&
        node.children.every(string_1.resolvesToString));
}
function getJSXIdentifierName(node) {
    return node.openingElement.name.name;
}
/**
 * Determines if element is a block
 *
 * @param {JSXElement} node
 * @returns {boolean}
 */
function isBlockTag(node) {
    return t.isJSXElement(node) && tagTypes_1.blockTags.indexOf(getJSXIdentifierName(node)) !== -1;
}
/**
 * Don't rewrap a path if it's already wrapped with <T>
 *
 * @param {JSXElement} node
 * @returns {boolean}
 */
function isNotAlreadyWrapped(node) {
    return getJSXIdentifierName(node) !== 'T';
}
function copyJSXElement(node, children) {
    return t.jsxElement(node.openingElement, node.closingElement, [...children], false);
}
/**
 * Tests for JSXElement Child Nodes
 *
 * @param {JSXElement} node
 * @return {boolean}
 */
function isInlineTag(node) {
    return t.isJSXElement(node) && tagTypes_1.inlineTags.indexOf(getJSXIdentifierName(node)) !== -1;
}
/**
 * Theoretically, this should blacklist elements that are block level,
 * so we dont end up with: <div><T>asdf <div>stuff</div></T></div> but rather
 * <div><T>asdf </T><div><T>stuff</T></div></div>
 *
 * @param {JSXElement}
 * @return {boolean}
 */
function hasWhitespaceChildren(node) {
    if (!node) {
        return false;
    }
    // todo: there isn't a babel node type that has a `value.children` property. suspected jscodeshift
    const children = node.children || (node.value && node.value.children);
    if (children) {
        return children.some((child) => {
            return (t.isJSXText(child) || t.isLiteral(child)) && child.value.replace(/\W/g, '') !== '';
        });
    }
    return false;
}
/**
 * Tests for JSXElement's children within text content
 *
 * @param {JSXElement}
 * @return {boolean}
 */
function hasInlineChildrenWithTextContent(node) {
    // todo: there isn't a babel node type that has a `value.children` property. suspected jscodeshift
    const children = node.children || node.value.children;
    if (children) {
        return children.some((child) => {
            return isInlineTag(child) && hasWhitespaceChildren(child);
        });
    }
    return false;
}
/**
 * Checks if JSXelement tag equal to a name
 *
 * @param {JSXElement} node
 * @param {string} tagName
 * @returns {boolean}
 */
function isEqualElementTagName(node, tagName) {
    return node.hasOwnProperty('openingElement') && getJSXIdentifierName(node) === tagName;
}
