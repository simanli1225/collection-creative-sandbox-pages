import * as t from '@babel/types';
/**
 * Determines if StringLiteral is empty
 * Also checks a JSX expression with a nested string literal e.g, <T project={'scripts-v6'} />
 * @param {StringLiteral} stringNode
 * @returns {boolean}
 */
export declare function isNonEmptyString(node: t.Node | null): boolean;
/**
 * Determines if StringLiteral contains whitespace
 *
 * @param {StringLiteral} stringNode
 * @returns {boolean}
 */
export declare function hasWhitespace(node: t.Node | null): boolean;
/**
 * Escapes any new lines characters
 * @param {string} value
 */
export declare function replaceNewlines(value: string): string;
/**
 * Determines if node resolves to a string value
 *
 * @param {Node} node - must be an AST node, not a plain string
 */
export declare function resolvesToString(node: t.Node): boolean;
/**
 * Returns a string provided it is a Literal
 * itself or resolvable to a Literal
 *
 * @param  {object} node an ast node, StringLiteral || JSXExpressionContainer || TemplateLiteral
 * @return {string} the full string value
 * @throws {SyntaxError} All operands of a binary expression must be literals
 * @throws {TypeError} Valid node types are StringLiteral or {BinaryExpression}
 */
export type StringLike = t.StringLiteral | t.JSXExpressionContainer | t.TemplateLiteral;
export declare function stringlikeToStringLiteral(node: StringLike): string;
