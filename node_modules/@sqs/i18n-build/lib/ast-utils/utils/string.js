"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNonEmptyString = isNonEmptyString;
exports.hasWhitespace = hasWhitespace;
exports.replaceNewlines = replaceNewlines;
exports.resolvesToString = resolvesToString;
exports.stringlikeToStringLiteral = stringlikeToStringLiteral;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("@babel/types"));
/**
 * Determines if StringLiteral is empty
 * Also checks a JSX expression with a nested string literal e.g, <T project={'scripts-v6'} />
 * @param {StringLiteral} stringNode
 * @returns {boolean}
 */
function isNonEmptyString(node) {
    const stringNode = t.isJSXExpressionContainer(node) ? node.expression : node;
    if (!stringNode) {
        return false;
    }
    return t.isStringLiteral(stringNode) && stringNode.value !== '' && /\S+/.test(stringNode.value);
}
/**
 * Determines if StringLiteral contains whitespace
 *
 * @param {StringLiteral} stringNode
 * @returns {boolean}
 */
function hasWhitespace(node) {
    const stringNode = t.isJSXExpressionContainer(node) ? node.expression : node;
    if (!stringNode) {
        return false;
    }
    return t.isStringLiteral(stringNode) && /\s+/.test(stringNode.value);
}
/**
 * Concatenates any length Binary Expression strings
 * i.e.:
 * __("This is a string " + "and this is another, " + "etc.")
 * => "This is a string and this is another, etc."
 *
 * @param {object} node
 * @return {string} concatenated string
 */
function concatBinaryExpression(node) {
    const right = node.right.value;
    const left = t.isBinaryExpression(node.left)
        ? concatBinaryExpression(node.left)
        : node.left.value;
    return left + right;
}
/**
 * Escapes any new lines characters
 * @param {string} value
 */
function replaceNewlines(value) {
    return value.replace(/\n/g, '\\n');
}
/**
 * Determines if all operands of Binary Expression are StringLiterals
 *
 * @param  {object} be BinaryExpression node
 * @return {boolean} true if all StringLiterals
 */
function hasStringLiteralOperands(node) {
    let allLiterals = true;
    const right = t.isStringLiteral(node.right);
    const left = t.isBinaryExpression(node.left)
        ? hasStringLiteralOperands(node.left)
        : t.isStringLiteral(node.left);
    if (!right || !left) {
        allLiterals = false;
    }
    return allLiterals;
}
/**
 * Determines if node resolves to a string value
 *
 * @param {Node} node - must be an AST node, not a plain string
 */
function resolvesToString(node) {
    if (t.isTemplateLiteral(node)) {
        return false;
    }
    if (t.isStringLiteral(node) || t.isJSXText(node)) {
        return true;
    }
    if (t.isBinaryExpression(node) && hasStringLiteralOperands(node)) {
        return true;
    }
    if (t.isJSXExpressionContainer(node)) {
        if (t.isStringLiteral(node.expression)) {
            return true;
        }
        if (t.isTemplateLiteral(node.expression) && node.expression.expressions.length === 0) {
            return true;
        }
        if (t.isBinaryExpression(node.expression) && hasStringLiteralOperands(node.expression)) {
            return true;
        }
    }
    return false;
}
function stringlikeToStringLiteral(node) {
    if (t.isStringLiteral(node) || t.isJSXText(node)) {
        return node.value;
    }
    if (t.isBinaryExpression(node) && hasStringLiteralOperands(node)) {
        return concatBinaryExpression(node);
    }
    if (t.isTemplateLiteral(node) && node.expressions.length === 0) {
        // TemplateLiterals persist new lines and indentation as part of the raw
        // string; remove both
        return node.quasis[0].value.raw.trim().replace(/\s+/g, ' ');
    }
    if (t.isJSXExpressionContainer(node)) {
        const { expression } = node;
        if (t.isBinaryExpression(expression) && hasStringLiteralOperands(expression)) {
            return concatBinaryExpression(expression);
        }
        if (t.isStringLiteral(expression)) {
            return expression.value;
        }
        if (t.isTemplateLiteral(expression) && expression.expressions.length === 0) {
            return expression.quasis[0].value.raw.trim().replace(/\s+/g, ' ');
        }
    }
    throw new Error('Valid node types are String Literal, TemplateLiteral without expressions, or a\n' +
        'BinaryExpression wrapped in a JSXExpressionContainer\n' +
        JSON.stringify(node, null, 2));
}
