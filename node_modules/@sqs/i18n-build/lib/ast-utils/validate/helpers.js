"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidFormsProperties = isValidFormsProperties;
exports.isFormsObjectExpression = isFormsObjectExpression;
exports.isValidFormsAttribute = isValidFormsAttribute;
exports.isNamedFunctionCall = isNamedFunctionCall;
exports.isValidSubs = isValidSubs;
exports.isValidNotes = isValidNotes;
exports.isValidTranslationId = isValidTranslationId;
exports.isRequireOrImportStatement = isRequireOrImportStatement;
const tslib_1 = require("tslib");
/**
 * This module containers helpers to be used
 * by the validation functions on React and Vanilla
 * translation functions
 */
const t = tslib_1.__importStar(require("@babel/types"));
const string_1 = require("../utils/string");
const constants_1 = tslib_1.__importDefault(require("../utils/constants"));
const { PLURALIZATION_KEYS } = constants_1.default;
/**
 * Determines if form properties are valid
 * Must contain two keys "one" & "two" with
 * values that resolve to strings
 *
 * @param {array} props - Property list
 * @returns {boolean}
 */
function isValidFormsProperties(props) {
    return (props &&
        props.every((p) => PLURALIZATION_KEYS.includes(p.key.name)) &&
        props.every((p) => (0, string_1.resolvesToString)(p.value)));
}
/**
 * Determines if an expression is valid for forms
 * Must be an object expression with two properties
 *
 * @param {ObjectExpression} expression
 * @returns {boolean}
 */
function isFormsObjectExpression(expression) {
    return (expression &&
        t.isObjectExpression(expression) &&
        expression.properties.length === 2 &&
        isValidFormsProperties(expression.properties));
}
/**
 * Determines if a forms attribute is valid
 * Must be an expression container with an object expression
 *
 * @param {}
 * @returns {boolean}
 */
function isValidFormsAttribute(attribute) {
    return (attribute &&
        t.isJSXExpressionContainer(attribute) &&
        isFormsObjectExpression(attribute.expression) &&
        isValidFormsProperties(attribute.expression.properties));
}
/**
 * Checks if a node is a function call with
 * a specific name idenfiier
 *
 * @param {CallExpression} node
 * @param {string} name
 * @returns {boolean}
 */
function isNamedFunctionCall(node, name) {
    return t.isCallExpression(node) && t.isIdentifier(node.callee, { name });
}
/**
 * Checks if a subs node is valid
 * Can be either null or object expression with non-zero properties
 *
 * @param {} subs
 * @returns {boolean}
 */
function isValidSubs(subs) {
    return subs && (t.isNullLiteral(subs) || t.isIdentifier(subs) || t.isObjectExpression(subs));
}
/**
 * Checks if a notes node is valid
 * Must be either undefined or resolve to string node
 *
 * @returns {boolean}
 * @param {Node} node
 */
function isValidNotes(node) {
    return !node || (0, string_1.resolvesToString)(node);
}
/**
 * Checks if a translationId node is valid
 * Must be either undefined or non-empty string literal
 *
 * @returns {boolean}
 * @param {Node} node
 */
function isValidTranslationId(node) {
    return !node || (0, string_1.isNonEmptyString)(node);
}
/**
 * Checks if expression is a require statement
 *
 * @param {CallExpression} expression
 * @returns {boolean}
 */
function isRequireOrImportStatement(expression) {
    return (
    // require('import-path');
    ((t.isIdentifier(expression.callee) && expression.callee.name === 'require') ||
        // import('import-path');
        t.isImport(expression.callee)) &&
        expression.arguments.length === 1 &&
        t.isStringLiteral(expression.arguments[0]));
}
