"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
const tslib_1 = require("tslib");
const generator_1 = tslib_1.__importDefault(require("@babel/generator"));
const traverse_1 = tslib_1.__importDefault(require("@babel/traverse"));
const loaderUtils = tslib_1.__importStar(require("loader-utils"));
const parser = tslib_1.__importStar(require("@babel/parser"));
const schemaUtils = tslib_1.__importStar(require("schema-utils"));
const path_1 = tslib_1.__importDefault(require("path"));
const constants_1 = require("../utils/constants");
const schema = tslib_1.__importStar(require("./schema.json"));
const ast_utils_1 = require("../ast-utils");
const GENERATOR_OPTIONS = { retainLines: true, retainFunctionParens: true };
function default_1(src, map, meta) {
    let ast;
    let traversalState;
    const loaderOptions = loaderUtils.getOptions(this) || {};
    // @ts-expect-error
    schemaUtils.validate(schema, loaderOptions, {
        name: 'I18N Platform - L10n Loader',
        baseDataPath: 'options',
    });
    const { autoImportOnly, autoImportPackagesConfig, translations, translationsBasePath } = loaderOptions;
    const replacerState = {
        transformed: false,
        translations,
    };
    try {
        ast = parser.parse(src, {
            sourceType: 'unambiguous',
            plugins: ast_utils_1.PARSER_PLUGINS,
        });
    }
    catch (e) {
        console.warn('[l10n-loader] Unable to parse file: ' + this.resourcePath + ': ' + e.message);
        this.callback(null /* no error */, src, map, meta);
        return;
    }
    try {
        if (autoImportPackagesConfig) {
            const autoImporterState = {
                packagesToAdd: new Set(),
                transformed: false,
                filePath: this.resourcePath,
                opts: {
                    autoImportPackagesConfig,
                },
            };
            if (autoImportOnly) {
                traversalState = autoImporterState;
                (0, traverse_1.default)(ast, ast_utils_1.AutoConfigImporter, undefined, traversalState);
            }
            else {
                traversalState = { ...replacerState, ...autoImporterState };
                const combinedVisitors = traverse_1.default.visitors.merge([ast_utils_1.TranslationsReplacer, ast_utils_1.AutoConfigImporter], [traversalState]);
                (0, traverse_1.default)(ast, combinedVisitors, undefined, traversalState);
            }
        }
        else {
            traversalState = replacerState;
            (0, traverse_1.default)(ast, ast_utils_1.TranslationsReplacer, undefined, traversalState);
        }
    }
    catch (e) {
        const toThrow = new Error(`${e.message}: ${path_1.default.basename(this.resourcePath)}`);
        toThrow.stack = undefined;
        throw toThrow;
    }
    /**
     * Flag is set when we update translations in a given file
     */
    if (traversalState && traversalState.transformed) {
        const output = (0, generator_1.default)(ast, GENERATOR_OPTIONS, src).code;
        /**
         * Add `sqs-i18n-translations/strings/` as a contextual dependency
         * to files with translations
         */
        if (translationsBasePath) {
            this.addContextDependency(path_1.default.join(translationsBasePath, constants_1.TRANSLATIONS_STRINGS_DIRECTORY));
        }
        return this.callback(null /* no error */, output, map, meta);
    }
    /**
     * return original source
     */
    this.callback(null /* no error */, src, map, meta);
}
