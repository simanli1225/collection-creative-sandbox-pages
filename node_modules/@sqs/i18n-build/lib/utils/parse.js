"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = parse;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const parser = tslib_1.__importStar(require("@babel/parser"));
const traverse_1 = tslib_1.__importDefault(require("@babel/traverse"));
const ast_utils_1 = require("../ast-utils");
const nodeDataAggregator = (data) => (node, pathname, location) => {
    const bundlePath = process.cwd();
    data.push({
        uid: node.uid,
        type: node.type,
        value: node.value,
        project: node.project,
        notes: node.notes,
        translationId: node.translationId,
        path: path_1.default.relative(bundlePath, pathname),
        lineNumber: location && location.start ? location.start.line : null,
    });
};
function parse(src, pathname) {
    let ast;
    let errors = '';
    const strings = [];
    const addNodeData = nodeDataAggregator(strings);
    try {
        ast = parser.parse(src, {
            sourceType: 'module',
            plugins: ast_utils_1.PARSER_PLUGINS,
        });
    }
    catch (e) {
        console.log('Unable to parse file: ' + pathname + ': ' + e.message);
        return { strings, errors };
    }
    (0, traverse_1.default)(ast, {
        JSXElement(p) {
            if (ast_utils_1.I18nValidate.isTComponent(p.node)) {
                const results = ast_utils_1.I18nComponent.parseTComponent(p.node);
                if (results.errors) {
                    // results.errors is a string[], but js knows to convert it to a string
                    // we leave it as += here for performance reasons
                    errors += results.errors;
                    return;
                }
                addNodeData(results.extractionResult, pathname, p.node.loc);
            }
            if (ast_utils_1.I18nValidate.isPluralComponent(p.node)) {
                const results = ast_utils_1.I18nComponent.parsePluralComponent(p.node);
                if (results.errors) {
                    errors += results.errors;
                    return;
                }
                addNodeData(results.extractionResult, pathname, p.node.loc);
            }
        },
        CallExpression(p) {
            if (ast_utils_1.I18nValidate.isTFunction(p.node)) {
                const results = ast_utils_1.I18nFunction.parseTFunction(p.node);
                if (results.errors) {
                    errors += results.errors;
                    return;
                }
                addNodeData(results.extractionResult, pathname, p.node.loc);
            }
            if (ast_utils_1.I18nValidate.isPluralizeFunction(p.node)) {
                const results = ast_utils_1.I18nFunction.parsePluralizeFunction(p.node);
                if (results.errors) {
                    errors += results.errors;
                    return;
                }
                addNodeData(results.extractionResult, pathname, p.node.loc);
            }
        },
    });
    return { strings, errors };
}
