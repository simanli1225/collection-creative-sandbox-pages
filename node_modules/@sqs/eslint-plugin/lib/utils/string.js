const t = require('@babel/types');

/**
 * babel-eslint parses node string literals as node.type = "Literal" instead of "StringLiteral"
 * Check if a node is a non-null Literal.
 */
function isNonNullLiteral(node) {
  if (node.type === 'NullLiteral') {
    return false;
  }
  if (t.isLiteral(node) && node.raw === 'null') {
    return false;
  }
  return t.isLiteral(node);
}

/**
 * Determines if all operands of Binary Expression are Literals
 *
 * @param  {object} be BinaryExpression node
 * @return {Boolean} true if literals
 */
function hasLiteralOperands(node) {
  let allLiterals = true;
  const right = t.isStringLiteral(node.right) || isNonNullLiteral(node.right);
  const left = t.isBinaryExpression(node.left) ?
    hasLiteralOperands(node.left) :
    t.isStringLiteral(node.left) || isNonNullLiteral(node.left);
  if (!right || !left) {
    allLiterals = false;
  }
  return allLiterals;
}

/**
 * Determines if node resolves to a string value
 *
 * @param {Node} node - must be an AST node, not a plain string
 */
function resolvesToString(node) {
  if (t.isTemplateLiteral(node)) {
    return false;
  }

  if (t.isStringLiteral(node) || isNonNullLiteral(node) || t.isJSXText(node)) {
    return true;
  }

  if (t.isBinaryExpression(node) && hasLiteralOperands(node)) {
    return true;
  }

  if (t.isJSXExpressionContainer(node)) {
    if (t.isStringLiteral(node.expression)) {
      return true;
    }
    if (
      t.isTemplateLiteral(node.expression) &&
      node.expression.expressions.length === 0
    ) {
      return true;
    }
    if (
      t.isBinaryExpression(node.expression) &&
      hasLiteralOperands(node.expression)
    ) {
      return true;
    }
  }

  return false;
}

module.exports = {
  resolvesToString,
};
