/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 437:
/***/ ((module) => {

var SPLIT_COOKIE_KEY_VALUE = /^([^=]+)=([^;]*)$/;
var exports = module.exports = function (doc, shouldEscapeCookie) {
    if (!doc) doc = {};
    if (typeof doc === 'string') doc = { cookie: doc };
    if (doc.cookie === undefined) doc.cookie = '';
    if (shouldEscapeCookie !== false) shouldEscapeCookie = true;

    var identity = function (str) { return str; }
    var _escape = shouldEscapeCookie ? escape : identity;
    var _unescape = shouldEscapeCookie ? unescape : identity;
    
    var self = {};
    self.get = function (key) {
        var splat = doc.cookie.split(/;\s*/);
        for (var i = 0; i < splat.length; i++) {
            var splitCookie = (splat[i]||'').match(SPLIT_COOKIE_KEY_VALUE) || [];
            var k = _unescape(splitCookie[1] || '');
            if (k === key) return _unescape(splitCookie[2] || '');
        }
        return undefined;
    };
    
    self.set = function (key, value, opts) {
        if (!opts) opts = {};
        var s = _escape(key) + '=' + _escape(value);
        if (opts.expires) s += '; expires=' + opts.expires;
        if (opts.path) s += '; path=' + _escape(opts.path);
        if (opts.domain) s += '; domain=' + _escape(opts.domain);
        if (opts.secure) s += '; secure';
        doc.cookie = s;
        return s;
    };
    return self;
};

if (typeof document !== 'undefined') {
    var cookie = exports(document);
    exports.get = cookie.get;
    exports.set = cookie.set;
}


/***/ }),

/***/ 471:
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ 814:
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ 550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(814);
var bytesToUuid = __webpack_require__(471);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSessionInfo: () => (/* binding */ getSessionInfo)
/* harmony export */ });
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(550);
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sqs_cookie_cutter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(437);
/* harmony import */ var _sqs_cookie_cutter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sqs_cookie_cutter__WEBPACK_IMPORTED_MODULE_1__);


var FIRST_SESSION_KEY = 'SS_IS_FIRST_SESSION';
var HAS_LANDED_KEY = 'SS_HAS_LANDED';
var SESSION_ID_KEY = 'SS_SESSION_ID';
var ROOT_DOMAINS = ['squarespace.com', 'squarespace.net', 'sqsp.net'];
var setCookie = function setCookie(key, value) {
  var domain;
  ROOT_DOMAINS.forEach(function (rootDomain) {
    if (window.location.hostname.indexOf(rootDomain) > -1) {
      domain = rootDomain;
    }
  });
  domain = domain || window.location.hostname;
  _sqs_cookie_cutter__WEBPACK_IMPORTED_MODULE_1___default().set(key, value, {
    domain: domain,
    path: '/',
    secure: window.location.protocol.indexOf('https') > -1
  });
};
function getSessionInfo() {
  var isCookieEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  if (typeof window === 'undefined') {
    return;
  }
  if (window._sessionInfo) {
    return window._sessionInfo;
  }
  try {
    var ls = localStorage.getItem(HAS_LANDED_KEY); // This will be set if the user has had previous sessions
    var ss = sessionStorage.getItem(FIRST_SESSION_KEY); // This will be set if the user has previously viewed other pages during the current session

    var isFirstLanding = ss === null;
    var isFirstSession = ls === null || ss === 'true';
    var sessionId = _sqs_cookie_cutter__WEBPACK_IMPORTED_MODULE_1___default().get(SESSION_ID_KEY);
    localStorage.setItem(HAS_LANDED_KEY, 'true');
    if (isFirstLanding) {
      if (isFirstSession) {
        sessionStorage.setItem(FIRST_SESSION_KEY, 'true');
      } else {
        sessionStorage.setItem(FIRST_SESSION_KEY, 'false');
      }
    }
    if (!sessionId && isCookieEnabled) {
      sessionId = uuid_v4__WEBPACK_IMPORTED_MODULE_0___default()();
      setCookie(SESSION_ID_KEY, sessionId);
    }
    window._sessionInfo = {
      isFirstLanding: isFirstLanding,
      isFirstSession: isFirstSession,
      sessionId: sessionId
    };
    return window._sessionInfo;
  } catch (error) {
    console.warn('Unable access local/session storage.');
    return {
      isFirstLanding: false,
      isFirstSession: false
    };
  }
}
})();

module.exports = __webpack_exports__;
/******/ })()
;