"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAPPINGS = {
    a: {
        transformations: ['á', 'ä', 'à', 'â', 'ã', 'æ'],
    },
    A: {
        transformations: ['Á', 'Ä', 'À', 'Â', 'Ã', 'Æ'],
    },
    b: {
        transformations: ['ß'],
        widthMultiplier: 2,
    },
    B: {
        transformations: ['ß'],
    },
    c: {
        transformations: ['ç'],
    },
    C: {
        transformations: ['Ç'],
    },
    d: {
        transformations: [],
    },
    D: {
        transformations: [],
    },
    e: {
        transformations: ['é', 'è', 'ê', 'ë'],
    },
    E: {
        transformations: ['É', 'È', 'Ê', 'Ë'],
    },
    f: {
        transformations: [],
        widthMultiplier: 0.5,
    },
    F: {
        transformations: [],
    },
    g: {
        transformations: [],
    },
    G: {
        transformations: [],
    },
    h: {
        transformations: [],
    },
    H: {
        transformations: [],
    },
    i: {
        transformations: ['ì', 'î', 'ï', 'í'],
        widthMultiplier: 0.5,
    },
    I: {
        transformations: [],
    },
    j: {
        transformations: [],
    },
    J: {
        transformations: [],
    },
    k: {
        transformations: [],
    },
    K: {
        transformations: [],
    },
    l: {
        transformations: [],
        widthMultiplier: 0.5,
    },
    L: {
        transformations: [],
    },
    m: {
        transformations: [],
        widthMultiplier: 1.5,
    },
    M: {
        transformations: [],
        widthMultiplier: 1.4,
    },
    n: {
        transformations: ['ñ'],
    },
    N: {
        transformations: ['Ñ'],
    },
    o: {
        transformations: ['ö', 'ô', 'œ', 'ó', 'ò', 'õ'],
    },
    O: {
        transformations: ['Ö', 'Ô', 'Œ', 'Ó', 'Ò', 'Õ'],
    },
    p: {
        transformations: [],
    },
    P: {
        transformations: [],
    },
    q: {
        transformations: [],
    },
    Q: {
        transformations: [],
    },
    r: {
        transformations: [],
        widthMultiplier: 0.75,
    },
    R: {
        transformations: [],
        widthMultiplier: 0.75,
    },
    s: {
        transformations: [],
    },
    S: {
        transformations: [],
    },
    t: {
        transformations: [],
        widthMultiplier: 0.75,
    },
    T: {
        transformations: [],
        widthMultiplier: 0.75,
    },
    u: {
        transformations: ['ú', 'ù', 'û', 'ü'],
    },
    U: {
        transformations: ['Ú', 'Ù', 'Û', 'Ü'],
    },
    v: {
        transformations: [],
    },
    w: {
        transformations: [],
        widthMultiplier: 1.5,
    },
    W: {
        transformations: [],
        widthMultiplier: 1.5,
    },
    x: {
        transformations: [],
    },
    X: {
        transformations: [],
        widthMultiplier: 1.3,
    },
    y: {
        transformations: ['ÿ'],
    },
    Y: {
        transformations: ['Ÿ'],
        widthMultiplier: 1.5,
    },
    z: {
        transformations: [],
    },
    Z: {
        transformations: [],
        widthMultiplier: 1.3,
    },
};
var Character = (function () {
    function Character(char) {
        this.characterInfo = MAPPINGS[char];
        this.originalCharacter = char;
    }
    Character.prototype.getTransformations = function () {
        if (!this.characterInfo) {
            return [];
        }
        return this.characterInfo.transformations || [];
    };
    Character.prototype.getReplacement = function () {
        var transformations = this.getTransformations();
        if (!transformations.length) {
            return null;
        }
        return transformations[1] || transformations[0];
    };
    Character.prototype.getExpansion = function (expansionFactor, strategy) {
        var weightedExpansionFactor = Math.round(expansionFactor / this.getWidthMultiplier());
        var transformations = this.getTransformations();
        var fillArrayCount = weightedExpansionFactor - transformations.length;
        while (fillArrayCount > 0) {
            transformations = transformations.concat(this.originalCharacter);
            fillArrayCount--;
        }
        var sliced = strategy === Character.FROM_BACK
            ? transformations.slice(transformations.length - weightedExpansionFactor)
            : transformations.slice(0, weightedExpansionFactor);
        return sliced.join('');
    };
    Character.prototype.getWidthMultiplier = function () {
        if (!this.characterInfo) {
            return 1;
        }
        return this.characterInfo.widthMultiplier || 1;
    };
    Character.FROM_BACK = 'from-back';
    return Character;
}());
exports.default = Character;
