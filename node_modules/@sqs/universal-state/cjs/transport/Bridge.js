"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _protocol = require("./protocol");
/**
 * Bridge sets up communication with a 'consumer' (non-root) window.
 *
 * It subscribes to the 'real' store, posts state updates to the consumer window
 * whenever state changes, and relays dispatched actions from the consumer window
 * back to the store.
 *
 * When a REGISTER event is received from a consumer window, Bridge responds
 * immediately with a STATE_UPDATE event to populate the window's state.
 */
class Bridge {
  constructor(store, consumerWindow) {
    (0, _defineProperty2.default)(this, "handleEvent", event => {
      switch (event.type) {
        case _protocol.UniversalStateEventType.REGISTER:
          this.sendStateUpdate();
          break;
        case _protocol.UniversalStateEventType.DISPATCH:
          this.store.dispatch(event.payload.action);
          break;
        default:
          break;
      }
    });
    (0, _defineProperty2.default)(this, "sendStateUpdate", () => {
      var state = this.store.getState();
      (0, _protocol.sendEvent)(this.consumerWindow, {
        type: _protocol.UniversalStateEventType.STATE_UPDATE,
        payload: {
          state
        }
      });
    });
    this.store = store;
    this.consumerWindow = consumerWindow;
    this.stopListeningForEvents = (0, _protocol.listenForEvents)(this.consumerWindow, this.handleEvent);
    this.unsubscribeFromStore = this.store.subscribe(this.sendStateUpdate);
  }
  teardown() {
    this.unsubscribeFromStore();
    this.stopListeningForEvents();
  }
}
exports.default = Bridge;
module.exports = exports.default;