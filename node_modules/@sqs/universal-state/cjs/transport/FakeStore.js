"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/web.dom-collections.for-each.js");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _protocol = require("./protocol");
/**
 * A Store-like object which stands in for the real store when Universal State
 * is running in a consumer (non-root) window.
 *
 * State updates are received from the root window and actions are sent back.
 *
 * It's possible to call dispatch() before communication has been established
 * with the top window. When this happens, the action is placed on a queue,
 * which is flushed once the FakeStore has received its first state update from
 * the root window.
 *
 * The order of operations on setup is therefore:
 *
 * 1. FakeStore sends REGISTER to the root window.
 * 2. Client code may call dispatch() at this point - actions are queued.
 * 3. Root window responds with STATE_UPDATE.
 * 4. Queued actions are dispatched to the root window in the order they were
 *    received.
 * 5. Setup is now complete. On subsequent calls to dispatch(), actions are
 *    sent immediately to the root window.
 */
class FakeStore {
  /**
   * Set to `true` once the first state update has been received.
   */

  /**
   * Queue of actions to dispatch once communication with the root window has been established.
   */

  /**
   * Listener functions to call on each state update.
   */

  constructor(rootWindow, preloadedState) {
    (0, _defineProperty2.default)(this, "handleEvent", event => {
      switch (event.type) {
        case _protocol.UniversalStateEventType.STATE_UPDATE:
          this.update(event.payload.state);
          break;
        default:
          break;
      }
    });
    this.rootWindow = rootWindow;
    this.state = preloadedState;
    this.hasReceivedState = false;
    this.pendingActions = [];
    this.listeners = new Set();
    (0, _protocol.listenForEvents)(this.rootWindow, this.handleEvent);
    (0, _protocol.sendEvent)(this.rootWindow, {
      type: _protocol.UniversalStateEventType.REGISTER
    });
  }
  update(state) {
    this.state = state;
    if (!this.hasReceivedState) {
      this.flushPendingActions();
      this.hasReceivedState = true;
    }
    this.listeners.forEach(cb => cb());
  }
  flushPendingActions() {
    if (this.pendingActions.length > 0) {
      this.pendingActions.forEach(a => this.actuallyDispatch(a));
      this.pendingActions = [];
    }
  }
  getState() {
    return this.state;
  }
  dispatch(action) {
    if (!this.hasReceivedState) {
      this.pendingActions.push(action);
      return;
    }
    this.actuallyDispatch(action);
  }
  actuallyDispatch(action) {
    (0, _protocol.sendEvent)(this.rootWindow, {
      type: _protocol.UniversalStateEventType.DISPATCH,
      payload: {
        action
      }
    });
  }
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
}
exports.default = FakeStore;
module.exports = exports.default;