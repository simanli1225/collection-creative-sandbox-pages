import _defineProperty from "@babel/runtime/helpers/defineProperty";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.set.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/web.dom-collections.for-each.js";
import { sendEvent, listenForEvents, UniversalStateEventType } from './protocol';
/**
 * A Store-like object which stands in for the real store when Universal State
 * is running in a consumer (non-root) window.
 *
 * State updates are received from the root window and actions are sent back.
 *
 * It's possible to call dispatch() before communication has been established
 * with the top window. When this happens, the action is placed on a queue,
 * which is flushed once the FakeStore has received its first state update from
 * the root window.
 *
 * The order of operations on setup is therefore:
 *
 * 1. FakeStore sends REGISTER to the root window.
 * 2. Client code may call dispatch() at this point - actions are queued.
 * 3. Root window responds with STATE_UPDATE.
 * 4. Queued actions are dispatched to the root window in the order they were
 *    received.
 * 5. Setup is now complete. On subsequent calls to dispatch(), actions are
 *    sent immediately to the root window.
 */
export default class FakeStore {
  /**
   * Set to `true` once the first state update has been received.
   */

  /**
   * Queue of actions to dispatch once communication with the root window has been established.
   */

  /**
   * Listener functions to call on each state update.
   */

  constructor(rootWindow, preloadedState) {
    _defineProperty(this, "handleEvent", event => {
      switch (event.type) {
        case UniversalStateEventType.STATE_UPDATE:
          this.update(event.payload.state);
          break;
        default:
          break;
      }
    });
    this.rootWindow = rootWindow;
    this.state = preloadedState;
    this.hasReceivedState = false;
    this.pendingActions = [];
    this.listeners = new Set();
    listenForEvents(this.rootWindow, this.handleEvent);
    sendEvent(this.rootWindow, {
      type: UniversalStateEventType.REGISTER
    });
  }
  update(state) {
    this.state = state;
    if (!this.hasReceivedState) {
      this.flushPendingActions();
      this.hasReceivedState = true;
    }
    this.listeners.forEach(cb => cb());
  }
  flushPendingActions() {
    if (this.pendingActions.length > 0) {
      this.pendingActions.forEach(a => this.actuallyDispatch(a));
      this.pendingActions = [];
    }
  }
  getState() {
    return this.state;
  }
  dispatch(action) {
    if (!this.hasReceivedState) {
      this.pendingActions.push(action);
      return;
    }
    this.actuallyDispatch(action);
  }
  actuallyDispatch(action) {
    sendEvent(this.rootWindow, {
      type: UniversalStateEventType.DISPATCH,
      payload: {
        action
      }
    });
  }
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
}