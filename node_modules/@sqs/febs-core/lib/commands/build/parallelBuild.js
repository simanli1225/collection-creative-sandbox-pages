"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const febs_logger_1 = __importDefault(require("@sqs/febs-logger"));
const exit_hook_1 = __importDefault(require("exit-hook"));
const ps_tree_1 = __importDefault(require("ps-tree"));
const workerFarm = require("worker-farm");
const utils_1 = require("./utils");
exports.default = async (config, webpackConfigs) => {
    const workersConfig = {
        maxConcurrentWorkers: Math.min(webpackConfigs.length, config.parallel),
        maxRetries: 0,
    };
    febs_logger_1.default.debug('Starting worker farm with max concurrent workers %s and maxRetries %s', workersConfig.maxConcurrentWorkers, workersConfig.maxRetries);
    const workers = workerFarm(workersConfig, require.resolve('./parallelBuildChild'), ['default']);
    const workersPromise = (env, webpackConfigIndex) => new Promise((resolve, reject) => {
        workers.default(config, env, webpackConfigIndex, (error, output) => {
            if (error) {
                febs_logger_1.default.debug('Building config #%s failed', webpackConfigIndex);
                reject(error);
            }
            else {
                resolve(output);
            }
        });
    });
    let hasWorkerFarmShutdown = false;
    const shutdownWorkerFarm = () => {
        if (!hasWorkerFarmShutdown) {
            workerFarm.end(workers);
            febs_logger_1.default.debug('Queued worker farm jobs ended');
        }
        hasWorkerFarmShutdown = true;
    };
    const forceKill = () => new Promise(resolve => {
        ps_tree_1.default(process.pid, (psTreeError, children) => {
            if (psTreeError) {
                throw psTreeError;
            }
            if (children.length) {
                febs_logger_1.default.debug('Force killing running child processes');
                children
                    .map(({ PID }) => parseInt(PID, 10))
                    .forEach(pid => {
                    process.kill(pid, 'SIGKILL');
                    febs_logger_1.default.debug(`Killed child process: ${pid}`);
                });
                febs_logger_1.default.debug('Finished force killing child processes');
            }
            resolve();
        });
    });
    exit_hook_1.default(shutdownWorkerFarm);
    try {
        const envs = utils_1.getWebpackConfigEnvArgs(config);
        const workerPromises = [];
        const numMultiConfigs = (webpackConfigs.length) / (envs.length);
        const envByConfigIdx = envs.reduce((acc, env) => {
            for (let multiConfigIdx = 0; multiConfigIdx < numMultiConfigs; multiConfigIdx++) {
                acc.push(env);
            }
            return acc;
        }, []);
        webpackConfigs.forEach((_, index) => {
            workerPromises.push(workersPromise(envByConfigIdx[index], index));
        });
        const resolvedBuilds = await Promise.all(workerPromises);
        if (!config.watch) {
            shutdownWorkerFarm();
        }
        return resolvedBuilds;
    }
    catch (err) {
        febs_logger_1.default.error('Parallel build error');
        febs_logger_1.default.error(err);
        shutdownWorkerFarm();
        await forceKill();
        throw new Error(err);
    }
};
//# sourceMappingURL=parallelBuild.js.map