"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const febs_logger_1 = __importDefault(require("@sqs/febs-logger"));
const febs_utils_1 = require("@sqs/febs-utils");
const i18n_locale_list_1 = require("@sqs/i18n-locale-list");
const glob_1 = __importDefault(require("glob"));
const map_1 = __importDefault(require("lodash/map"));
const mapValues_1 = __importDefault(require("lodash/mapValues"));
const reduce_1 = __importDefault(require("lodash/reduce"));
const zipObject_1 = __importDefault(require("lodash/zipObject"));
const paralleljs_1 = __importDefault(require("paralleljs"));
const path_1 = __importDefault(require("path"));
const statsReporter_1 = require("./statsReporter");
const bundleStats_1 = require("./bundleStats");
const utils_1 = require("./utils");
function getFileSize(filePath) {
    const fs = require('fs');
    const zlib = require('zlib');
    const buff = fs.readFileSync(filePath);
    const gzip = buff.byteLength === 0 ? buff : zlib.gzipSync(buff);
    return {
        gzipSize: gzip.byteLength,
        size: buff.byteLength,
    };
}
function getFilePaths(filesGlob) {
    return glob_1.default.sync(filesGlob);
}
function getCSSFiles(dirPath) {
    return getFilePaths(path_1.default.join(dirPath, '/**/*.css'));
}
function getJSFiles(dirPath) {
    return getFilePaths(path_1.default.join(dirPath, '/**/*.js'));
}
function getNormalizedFileName(filePath) {
    return path_1.default
        .basename(filePath)
        .replace(bundleStats_1.fileNameCleanupPattern, '')
        .replace(/\./g, '-');
}
function getSizesMap(paths) {
    if (!paths.length) {
        return {};
    }
    const parallelFileList = new paralleljs_1.default(Array.from(paths), {
        maxWorkers: febs_utils_1.getDefaultCPUUtilization(),
    }).map(getFileSize);
    return parallelFileList.then((sizes) => zipObject_1.default(map_1.default(paths, getNormalizedFileName), sizes));
}
async function getInputBundleStats(config) {
    let jsStats = {};
    if (config.locale.includes(i18n_locale_list_1.locales.defaultLocale)) {
        try {
            const inputStatsFilename = path_1.default.join(config.paths.dist, 'webpack-input-stats.json');
            jsStats = await bundleStats_1.getBundleInputSizes(inputStatsFilename);
        }
        catch (err) {
            febs_logger_1.default.error(err);
            febs_logger_1.default.debug('Input bundle sizes and size diffs were not reported.');
        }
    }
    else {
        febs_logger_1.default.debug('No bundle stats are collected on non-default locale build');
    }
    return jsStats;
}
async function getScriptSizeMetrics(config) {
    const buildNumber = statsReporter_1.getBuildNumber();
    const cssPaths = getCSSFiles(config.paths.dist);
    const jsPaths = getJSFiles(config.paths.dist);
    const cssFileSizes = await getSizesMap(cssPaths);
    const jsFileSizes = await getSizesMap(jsPaths);
    const css = mapValues_1.default(cssFileSizes, ({ size }) => size);
    const js = mapValues_1.default(jsFileSizes, ({ size }) => size);
    const cssGzipped = mapValues_1.default(cssFileSizes, ({ gzipSize }) => gzipSize);
    const jsGzipped = mapValues_1.default(jsFileSizes, ({ gzipSize }) => gzipSize);
    const cssTotal = reduce_1.default(css, utils_1.sum, 0);
    const jsTotal = reduce_1.default(js, utils_1.sum, 0);
    const cssGzippedTotal = reduce_1.default(cssGzipped, utils_1.sum, 0);
    const jsGzippedTotal = reduce_1.default(jsGzipped, utils_1.sum, 0);
    const jsStats = await getInputBundleStats(config);
    const jsMinDiff = bundleStats_1.diffBundleSizes(jsStats, bundleStats_1.formatAsBundleStats(js));
    return {
        build: buildNumber,
        css,
        cssGzipped,
        cssGzippedTotal,
        cssTotal,
        js,
        jsGzipped,
        jsGzippedTotal,
        jsMinDiff,
        jsStats,
        jsTotal,
    };
}
exports.default = getScriptSizeMetrics;
//# sourceMappingURL=getScriptSizeMetrics.js.map