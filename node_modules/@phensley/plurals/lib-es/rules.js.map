{"version":3,"file":"rules.js","sourceRoot":"","sources":["../src/rules.ts"],"names":[],"mappings":"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","sourcesContent":["import { coerceDecimal, Decimal, DecimalArg } from '@phensley/decimal';\nimport { NumberOperands } from './operands';\n\nimport { Expr, Rule } from './types';\n\nexport type RuleMap = { [x: string]: Rule[] };\n\nexport type RangeMap = number | { [x: number]: number };\n\nexport type Operand = 'n' | 'i' | 'v' | 'w' | 'f' | 't' | 'c';\n\n// Notation for categories in compact plural rules\nconst CATEGORIES: string[] = ['zero', 'one', 'two', 'few', 'many', 'other'];\n\nconst arg = (n: DecimalArg, c: number = 0) => new NumberOperands(coerceDecimal(n), c);\n\n/**\n * Plural operations for a given language.\n *\n * @public\n */\nexport interface PluralRules {\n  operands(d: Decimal): NumberOperands;\n  cardinal(n: DecimalArg, c?: number): string;\n  ordinal(n: DecimalArg): string;\n  range(start: DecimalArg, end: DecimalArg): string;\n}\n\n/**\n * Set of all cardinal and ordinal plural rules, and the array of expression\n * fragments the rules reference.\n *\n * @internal\n */\nexport class PluralRulesImpl implements PluralRules {\n  constructor(\n    private expressions: Expr[],\n    private cardinals: Rule[],\n    private ordinals: Rule[],\n    private ranges: RangeMap,\n  ) {}\n\n  operands(d: Decimal): NumberOperands {\n    return new NumberOperands(d);\n  }\n\n  cardinal(n: DecimalArg, c: number = 0): string {\n    return CATEGORIES[this.evaluate(arg(n, c), this.cardinals)];\n  }\n\n  ordinal(n: DecimalArg): string {\n    return CATEGORIES[this.evaluate(arg(n), this.ordinals)];\n  }\n\n  range(start: DecimalArg, end: DecimalArg): string {\n    if (typeof this.ranges === 'number') {\n      return CATEGORIES[this.ranges];\n    }\n    const s = this.evaluate(arg(start), this.cardinals);\n    const e = this.evaluate(arg(end), this.cardinals);\n    const cat = this.ranges[((1 << s) << 5) + (1 << e)];\n    return CATEGORIES[cat] || 'other';\n  }\n\n  private evaluate(operands: NumberOperands, rules: Rule[]): number {\n    if (rules) {\n      for (const rule of rules) {\n        if (this.execute(operands, rule[1])) {\n          return rule[0];\n        }\n      }\n    }\n    return 5;\n  }\n\n  private execute(operands: NumberOperands, conditions: number[][]): boolean {\n    // Evaluate each condition and OR them together.\n    const len = conditions.length;\n    for (let i = 0; i < len; i++) {\n      const cond = conditions[i];\n\n      // Evaluate the inner expressions and AND them together.\n      let res = true;\n      for (let j = 0; j < cond.length; j++) {\n        const expr = this.expressions[cond[j]];\n        res = res && evaluateExpr(operands, expr);\n        if (!res) {\n          break;\n        }\n      }\n      if (res) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport const evaluateExpr = (operands: NumberOperands, expr: Expr): boolean => {\n  const operand = expr[0]!;\n  let n: number = operands[operand as Operand];\n\n  // The N = X..Y syntax means N matches an integer from X to Y inclusive\n  // Operand 'n' must always be compared as an integer, so if it has any non-zero decimal\n  // parts we must set integer = false.\n  const integer = operand === 'n' ? operands.w === 0 : true;\n\n  const mod = expr[1];\n  if (mod) {\n    n = n % mod;\n  }\n\n  const ranges = expr[3];\n  let res = false;\n  for (let i = 0; i < ranges.length; i++) {\n    const elem = ranges[i];\n    if (typeof elem === 'number') {\n      res = res || (integer && n === elem);\n    } else {\n      res = res || (integer && elem[0] <= n && n <= elem[1]);\n    }\n  }\n  return expr[2] ? res : !res;\n};\n"]}