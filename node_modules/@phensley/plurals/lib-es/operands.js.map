{"version":3,"file":"operands.js","sourceRoot":"","sources":["../src/operands.ts"],"names":[],"mappings":"AAEA;;GAEG;AACH,MAAM,CAAC,IAAM,UAAU,GAAG,UAAC,CAAS;IAClC,IAAI,CAAC,2BAAe,EAAE,CAAC;QACrB,IAAI,CAAC,yBAAe,EAAE,CAAC;YACrB,OAAO,CAAC,wBAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClC,CAAC;QACD,OAAO,CAAC,0BAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC;IACD,IAAI,CAAC,6BAAe,EAAE,CAAC;QACrB,OAAO,CAAC,4BAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC;IACD,OAAO,CAAC,8BAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC;AAkBF,IAAM,QAAQ,GAAG;;;;;;;;;;CAUhB,CAAC;AAEF,mEAAmE;AACnE,gEAAgE;AAChE,0CAA0C;AAC1C,IAAM,KAAK,GAAG,cAAc,CAAC;AAE7B,IAAM,MAAM,GAA6B,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AAI7E;;;;;;;;;;;;;;;;GAgBG;AACH;IASE;;;OAGG;IACH,wBAAY,CAAU,EAAE,CAAa;QAAb,kBAAA,EAAA,KAAa;QAZrC,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QACd,MAAC,GAAW,CAAC,CAAC;QAOZ,IAAM,KAAK,GAAG,CAAC,CAAC,UAAU,EAAE,CAAC;QAC7B,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,IAAI,EAAE,CAAC;YACT,OAAO;QACT,CAAC;QAED,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAEnB,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAM,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC;QACrB,IAAM,SAAS,GAAG,IAAI,4BAAoB,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAEpE,iBAAiB;QACjB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAM,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,CAAC,GAAG,CAAC,CAAC;QAEV,iCAAiC;QACjC,sEAAsE;QACtE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;YACV,CAAC,GAAG,CAAC,CAAC;QACR,CAAC;QAED,uBAAuB;QACvB,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,uBAAuB;QACvB,IAAI,CAAC,GAAG,IAAI,CAAC;QAEb,wCAAwC;QACxC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEV,IAAI,SAAS,GAAG,SAAS,GAAG,GAAG,CAAC;QAEhC,qDAAqD;QACrD,IAAI,SAAS,GAAG,CAAC,EAAE,CAAC;YAClB,SAAS,GAAG,CAAC,CAAC;QAChB,CAAC;QAED,2CAA2C;QAC3C,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YAChB,IAAM,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,2BAAmB,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC7D,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC;YAEd,mDAAmD;YACnD,+BAA+B;YAC/B,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;gBACd,IAAM,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAM,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gBAEhC,IAAI,SAAS,GAAG,CAAC,EAAE,CAAC;oBAClB,eAAe;oBACf,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;oBAEf,2DAA2D;oBAC3D,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC;wBACd,iEAAiE;wBACjE,mDAAmD;wBACnD,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;oBAC1B,CAAC;oBACD,SAAS,EAAE,CAAC;gBACd,CAAC;qBAAM,CAAC;oBACN,eAAe;oBACf,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;wBACZ,KAAK,EAAE,CAAC;oBACV,CAAC;yBAAM,CAAC;wBACN,KAAK,GAAG,CAAC,CAAC;oBACZ,CAAC;oBACD,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;gBACjB,CAAC;gBAED,4DAA4D;gBAC5D,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC;oBACd,MAAM,KAAK,CAAC;gBACd,CAAC;gBAED,CAAC,IAAI,CAAC,CAAC;gBACP,CAAC,EAAE,CAAC;YACN,CAAC;YACD,CAAC,EAAE,CAAC;QACN,CAAC;QAED,yBAAyB;QACzB,OAAO,GAAG,GAAG,CAAC,EAAE,CAAC;YACf,CAAC,IAAI,EAAE,CAAC;YACR,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC;gBACd,iEAAiE;gBACjE,mDAAmD;gBACnD,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;YAC1B,CAAC;YACD,GAAG,EAAE,CAAC;QACR,CAAC;QAED,oDAAoD;QACpD,IAAI,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC;YAC1C,CAAC,GAAG,CAAC,CAAC;QACR,CAAC;aAAM,CAAC;YACN,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YACd,CAAC,GAAG,CAAC,CAAC;YACN,OAAO,KAAK,GAAG,CAAC,EAAE,CAAC;gBACjB,CAAC,IAAI,EAAE,CAAC;gBACR,KAAK,EAAE,CAAC;YACV,CAAC;QACH,CAAC;QAED,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACb,CAAC;IAED,iCAAQ,GAAR;QAAA,iBAEC;QADC,OAAO,MAAM,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,UAAG,CAAC,eAAK,KAAI,CAAC,CAAC,CAAC,CAAE,EAAlB,CAAkB,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1D,CAAC;IACH,qBAAC;AAAD,CAAC,AAvID,IAuIC","sourcesContent":["import { Decimal } from '@phensley/decimal';\n\n/**\n * Returns the number of digits in w, where w < RADIX.\n */\nexport const digitCount = (w: number): number => {\n  if (w < Constants.P4) {\n    if (w < Constants.P2) {\n      return w < Constants.P1 ? 1 : 2;\n    }\n    return w < Constants.P3 ? 3 : 4;\n  }\n  if (w < Constants.P6) {\n    return w < Constants.P5 ? 5 : 6;\n  }\n  return w < Constants.P7 ? 7 : 8;\n};\n\nconst enum Constants {\n  // 10^7 < sqrt(Number.MAX_SAFE_INTEGER)\n  RADIX = 1e7,\n  RDIGITS = 7,\n\n  P0 = 1,\n  P1 = 10,\n  P2 = 100,\n  P3 = 1000,\n  P4 = 10000,\n  P5 = 100000,\n  P6 = 1000000,\n  P7 = 10000000,\n  P8 = 100000000,\n}\n\nconst POWERS10 = [\n  Constants.P0,\n  Constants.P1,\n  Constants.P2,\n  Constants.P3,\n  Constants.P4,\n  Constants.P5,\n  Constants.P6,\n  Constants.P7,\n  Constants.P8,\n];\n\n// When a number crosses this limit we reduce it to avoid overflow.\n// This limit is chosen so that a number <= this limit multipled\n// by 10 will still be < MAX_SAFE_INTEGER.\nconst LIMIT = 10000000000000;\n\nconst FIELDS: (keyof NumberOperands)[] = ['n', 'i', 'v', 'w', 'f', 't', 'c'];\n\nexport type Operand = 'n' | 'i' | 'v' | 'w' | 'f' | 't' | 'c';\n\n/**\n * Operands for use in evaluating localized plural rules:\n * See: http://www.unicode.org/reports/tr35/tr35-numbers.html#Plural_Operand_Meanings\n *\n * symbol    value\n * ----------------\n *   n       absolute value of the source number (integer and decimals)\n *   i       integer digits of n\n *   v       number of visible fraction digits in n, with trailing zeros\n *   w       number of visible fraction digits in n, without trailing zeros\n *   f       visible fractional digits in n, with trailing zeros\n *   t       visible fractional digits in n, without trailing zeros\n *   c       compact decimal exponent value\n *   e       synonym for 'c', may be redefined in the future\n *\n * @public\n */\nexport class NumberOperands {\n  n: number = 0;\n  i: number = 0;\n  v: number = 0;\n  w: number = 0;\n  f: number = 0;\n  t: number = 0;\n  c: number = 0;\n\n  /**\n   * Compute the plural operands for the Decimal `d` with optional compact\n   * exponent `c`.\n   */\n  constructor(d: Decimal, c: number = 0) {\n    const props = d.properties();\n    const flag = props[3];\n    if (flag) {\n      return;\n    }\n\n    const data = props[0];\n    let exp = props[2];\n\n    const len = data.length;\n    const last = len - 1;\n    const precision = last * Constants.RDIGITS + digitCount(data[last]);\n\n    // Local operands\n    let n = 0;\n    const v = exp < 0 ? -exp : 0;\n    let w = 0;\n    let f = 0;\n    let t = 0;\n\n    // Compact decimal exponent value\n    // See https://www.unicode.org/reports/tr35/tr35-numbers.html#Operands\n    if (c < 0) {\n      c = 0;\n    }\n\n    // Count trailing zeros\n    let trail = 0;\n\n    // Index of radix digit\n    let x = last;\n\n    // Index of decimal digit in radix digit\n    let y = 0;\n\n    let intdigits = precision + exp;\n\n    // Leading decimal zeros aren't part of the operands.\n    if (intdigits < 0) {\n      intdigits = 0;\n    }\n\n    // Start at most-significant digit to least\n    outer: while (x >= 0) {\n      let r = data[x];\n      const count = x !== last ? Constants.RDIGITS : digitCount(r);\n      y = count - 1;\n\n      // Scan each decimal digit of the radix number from\n      // most- to least- significant.\n      while (y >= 0) {\n        const p = POWERS10[y];\n        const q = (r / POWERS10[y]) | 0;\n\n        if (intdigits > 0) {\n          // Integer part\n          n = n * 10 + q;\n\n          // If the integer digits exceed the limit we apply modulus.\n          if (n > LIMIT) {\n            // Stay below the limit but preserve (a) the magnitude and (b) as\n            // many of the least-significant digits as possible\n            n = (n % LIMIT) + LIMIT;\n          }\n          intdigits--;\n        } else {\n          // Decimal part\n          if (q === 0) {\n            trail++;\n          } else {\n            trail = 0;\n          }\n          f = f * 10 + q;\n        }\n\n        // If the decimal digits exceed our limit we bail out early.\n        if (f > LIMIT) {\n          break outer;\n        }\n\n        r %= p;\n        y--;\n      }\n      x--;\n    }\n\n    // Trailing integer zeros\n    while (exp > 0) {\n      n *= 10;\n      if (n > LIMIT) {\n        // Stay below the limit but preserve (a) the magnitude and (b) as\n        // many of the least-significant digits as possible\n        n = (n % LIMIT) + LIMIT;\n      }\n      exp--;\n    }\n\n    // Special case for zero with exponent, e.g. '0.00'.\n    if (len === 1 && data[0] === 0 && exp < 0) {\n      w = 0;\n    } else {\n      w = v - trail;\n      t = f;\n      while (trail > 0) {\n        t /= 10;\n        trail--;\n      }\n    }\n\n    this.n = n;\n    this.i = n;\n    this.v = v;\n    this.w = w;\n    this.f = f;\n    this.t = t;\n    this.c = c;\n  }\n\n  toString(): string {\n    return FIELDS.map((f) => `${f}: ${this[f]}`).join(', ');\n  }\n}\n"]}