{"version":3,"file":"arrows.js","sourceRoot":"","sources":["../src/arrows.ts"],"names":[],"mappings":"","sourcesContent":["import { PrimitiveBundle } from './bundle';\n\n/**\n * Maps a name to a key index.\n *\n * @public\n */\nexport interface KeyIndexMap {\n  [name: string]: KeyIndex<string>;\n}\n\n/**\n * Indexes each string in an array to its offset in the array.\n *\n * @public\n */\nexport interface KeyIndex<T extends string> {\n  readonly index: { [P in T]: number };\n  readonly keys: T[];\n  readonly size: number;\n  readonly last: number;\n  get(key: T): number;\n}\n\n/**\n * Function for fetching a single field.\n *\n * @public\n */\nexport interface FieldArrow {\n  readonly offset: number;\n  get(bundle: PrimitiveBundle): string;\n}\n\n/**\n * Function for entering a new scope.\n *\n * @public\n */\nexport interface ScopeArrow<T extends string, R> {\n  readonly map: { [P in T]: R };\n  get(key: T): R | undefined;\n}\n\n/**\n * Function for fetching a field based on plural category and\n * number of digits.\n *\n * @public\n */\nexport interface DigitsArrow<T extends string> {\n  readonly offset: number;\n  readonly index: KeyIndex<T>;\n  readonly values: number[];\n  readonly size2: number;\n\n  /**\n   * Gets the field for the given plural category and number of integer digits.\n   */\n  get(bundle: PrimitiveBundle, key: T, digits: number): [string, number];\n}\n\n/**\n * Function representing a 1-dimensional vector.\n *\n * @public\n */\nexport interface Vector1Arrow<T extends string> {\n  /**\n   * Indicates this vector exists in the bundle.\n   */\n  exists(bundle: PrimitiveBundle): boolean;\n\n  /**\n   * Fast way to check if a key is valid, even if it has no value.\n   */\n  valid(key: T): boolean;\n\n  /**\n   * Gets the field at the corresponding offset of the given key.\n   */\n  get(bundle: PrimitiveBundle, key: T | T[]): string;\n\n  /**\n   * Full mapping of all keys to the corresponding fields.\n   */\n  mapping(bundle: PrimitiveBundle): { [P in T]: string };\n}\n\n/**\n * Function representing a 2-dimensional vector.\n *\n * @public\n */\nexport interface Vector2Arrow<T extends string, S extends string> {\n  /**\n   * Indicates this vector exists in the bundle.\n   */\n  exists(bundle: PrimitiveBundle): boolean;\n\n  /**\n   * Fast way to check if a key is valid, even if it has no value.\n   */\n  valid(key1: T | T[], key2: S | S[]): boolean;\n\n  /**\n   * Gets the field at the corresponding offset [key1, key2]\n   */\n  get(bundle: PrimitiveBundle, key1: T | T[], key2: S | S[]): string;\n\n  /**\n   * Full mapping of all keys to the corresponding fields.\n   */\n  mapping(bundle: PrimitiveBundle): { [P in T]: { [Q in S]: string } };\n}\n\n/**\n * Function representing a 3-dimensional vector.\n *\n * @public\n */\nexport interface Vector3Arrow<T extends string, S extends string, U extends string> {\n  /**\n   * Indicates this vector exists in the bundle.\n   */\n  exists(bundle: PrimitiveBundle): boolean;\n\n  /**\n   * Gets the field at the corresponding offset [key1, key2, key3]\n   */\n  get(bundle: PrimitiveBundle, key1: T | T[], key2: S | S[], key3: U | U[]): string;\n\n  /**\n   * Full mapping of all keys to the corresponding fields.\n   */\n  mapping(bundle: PrimitiveBundle): { [P in T]: { [Q in S]: { [R in U]: string } } };\n}\n"]}