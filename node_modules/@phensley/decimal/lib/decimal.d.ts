import { DecimalFormatter, Part } from './format';
import { DecimalFlag, MathContext, RoundingModeType } from './types';
declare const enum Op {
    ADDITION = 0,
    SUBTRACTION = 1,
    MULTIPLICATION = 2,
    DIVISION = 3,
    MOD = 4
}
/**
 * Latin decimal digits.
 *
 * @public
 */
export declare const DECIMAL_DIGITS: string[];
/**
 * Valid argument for constructing a Decimal value.
 *
 * @public
 */
export type DecimalArg = number | string | Decimal;
/**
 * Converts a valid argument into a Decimal value.
 *
 * @public
 */
export declare const coerceDecimal: (n: DecimalArg) => Decimal;
/**
 * Arbitrary precision decimal type.
 *
 * @public
 */
export declare class Decimal {
    protected data: number[];
    protected sign: number;
    protected _exp: number;
    protected flag: DecimalFlag;
    constructor(num: DecimalArg);
    /**
     * Return the decimal's exponent.
     */
    exp(): number;
    /**
     * Return true if this decimal is not a number (NaN).
     */
    isNaN(): boolean;
    /**
     * Return true if this decimal is finite (not infinity or NaN).
     */
    isFinite(): boolean;
    /**
     * Return true if this decimal is positive or negative infinity.
     */
    isInfinity(): boolean;
    /**
     * Compare decimal u to v, returning the following:
     *
     *  -1   if  u &lt; v
     *   0   if  u = v
     *   1   if  u &gt; v
     *
     * If the abs flag is true compare the absolute values.
     *
     * Any NAN argument will always return -1.
     */
    compare(v: DecimalArg, abs?: boolean): number;
    /**
     * Return the raw internal properties of the number. Use with caution.
     */
    properties(): [number[], number, number, number];
    /**
     * Return the absolute value of the number.
     */
    abs(): Decimal;
    /**
     * Invert this number's sign.
     */
    negate(): Decimal;
    /**
     * Indicates this number is negative.
     */
    isNegative(): boolean;
    /**
     * Signum.
     */
    signum(): number;
    /**
     * Check if this number can be represented as an integer without loss of precision.
     * For example, '12.000' is the same number as '12'.
     */
    isInteger(): boolean;
    /**
     * Number is exactly zero. Exponent may exist, e.g. "0e-2" is "0.00".
     */
    isZero(): boolean;
    /**
     * Return the integer part.
     */
    toInteger(): Decimal;
    /**
     * Adds v.
     */
    add(v: DecimalArg): Decimal;
    /**
     * Subtracts v.
     */
    subtract(v: DecimalArg): Decimal;
    /**
     * Multiplies by v with optional math context.
     */
    multiply(v: DecimalArg, context?: MathContext): Decimal;
    /**
     * Divide by v with optional math context.
     */
    divide(v: DecimalArg, context?: MathContext): Decimal;
    /**
     * Divide by v and return the quotient and remainder.
     */
    divmod(v: DecimalArg): [Decimal, Decimal];
    /**
     * Divide by v and return the remainder.
     */
    mod(v: DecimalArg): Decimal;
    /**
     * Number of trailing zeros.
     */
    trailingZeros(): number;
    /**
     * Strip all trailing zeros.
     */
    stripTrailingZeros(): Decimal;
    /**
     * Return a scientific representation of the number,
     * Decimal coefficient and adjusted exponent.
     */
    scientific(minIntDigits?: number): [Decimal, number];
    /**
     * Number of digits in the unscaled value.
     */
    precision(): number;
    /**
     * Scale is the number of digits to the right of the decimal point.
     */
    scale(): number;
    /**
     * Number of integer digits, 1 or higher.
     */
    integerDigits(): number;
    /**
     * Returns a new number with the given scale, shifting the coefficient as needed.
     */
    setScale(scale: number, roundingMode?: RoundingModeType): Decimal;
    /**
     * Adjusted exponent for alignment. Two numbers with the same aligned exponent are
     * aligned for arithmetic operations. If the aligned exponents do not match one
     * number must be shifted.
     */
    alignexp(): number;
    /**
     * Move the decimal point -n (left) or +n (right) places. Does not change
     * precision, only affects the exponent.
     */
    movePoint(n: number): Decimal;
    /**
     * Shifts all digits to the left, increasing the precision.
     */
    shiftleft(shift: number): Decimal;
    /**
     * Shifts all digits to the right, reducing the precision. Result is rounded
     * using the given rounding mode.
     */
    shiftright(shift: number, mode?: RoundingModeType): Decimal;
    /**
     * Increment the least-significant integer digit.
     */
    increment(): Decimal;
    /**
     * Decrement the least-significant integer digit.
     */
    decrement(): Decimal;
    /**
     * Format the number to a string, using fixed point.
     */
    toString(): string;
    /**
     * Format this number to scientific notation as a string.
     */
    toScientificString(minIntegers?: number): string;
    /**
     * Format this number to an array of parts.
     */
    toParts(): Part[];
    /**
     * Format this number to scientific notation as an array of parts.
     */
    toScientificParts(minIntegers?: number): Part[];
    /**
     * Low-level formatting of string and Part[] forms.
     */
    format<R>(formatter: DecimalFormatter<R>, decimal: string, group: string, minInt: number, minGroup: number, priGroup: number, secGroup: number, zeroScale: boolean, digits?: string[]): void;
    protected formatFlags(): string;
    protected formatFlagsParts(): Part[];
    protected formatString(d: Decimal, minInt: number): string;
    protected formatParts(d: Decimal, minInt: number): Part[];
    /**
     * Handle setting of flags for operations per the IEEE-754-2008 specification.
     * These rules are also referenced in the EcmaScript specification:
     *
     * 12.7.3.1 - Applying the mul operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-mul-operator
     *
     * 12.7.3.2 - Applying the div operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-div-operator
     *
     * 12.7.3.3 - Applying the mod operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-mod-operator
     *
     * 12.8.5 - Applying the additive operators to numbers:
     * https://tc39.github.io/ecma262/#sec-applying-the-additive-operators-to-numbers
     *
     */
    protected handleFlags(op: Op, v: Decimal): Decimal | undefined;
    protected static fromRaw(sign: number, _exp: number, data: number[], flag: DecimalFlag): Decimal;
    /**
     * Mutating in-place shift left.
     */
    protected _shiftleft(shift: number): void;
    /**
     * Mutating in-place shift right.
     */
    protected _shiftright(shift: number, mode: RoundingModeType): void;
    protected _setScale(scale: number, roundingMode?: RoundingModeType): void;
    protected _stripTrailingZeros(): void;
    /**
     * Trim leading zeros from a result and reset sign and exponent accordingly.
     */
    protected trim(): Decimal;
    /**
     * Increment the least-significant digit of the coefficient.
     */
    protected _increment(): void;
    /**
     * Return a rounding indicator for a given rounding mode,
     */
    protected round(rnd: number, rest: number, mode: RoundingModeType): number;
    /**
     * Return true if this instance is odd.
     */
    protected isodd(): boolean;
    /**
     * Addition and subtraction.
     */
    protected addsub(u: Decimal, v: Decimal, vsign: number): Decimal;
    /**
     * Parse a number or string setting the fields on the current instance.
     */
    protected parse(arg: string | number): void;
    /**
     * Parse a string into a Decimal.
     *
     * Expects strings of the form:
     *    "[-+][digits][.][digits][eE][-+][digits]"
     * or:
     *    "[nN]a[nN]"        for a NaN
     *    "[-+]?[iI]nfinity" for positive or negative infinity
     */
    protected _parse(str: string): string | undefined;
}
/**
 * Common Decimal values as constants.
 *
 * @public
 */
export declare const DecimalConstants: {
    ZERO: Decimal;
    ONE: Decimal;
    TWO: Decimal;
    PI: Decimal;
    E: Decimal;
    NAN: Decimal;
    POSITIVE_INFINITY: Decimal;
    NEGATIVE_INFINITY: Decimal;
};
export {};
