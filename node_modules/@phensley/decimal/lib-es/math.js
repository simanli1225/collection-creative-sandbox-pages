import { POWERS10 } from './types';
/**
 * Knuth TAoCP 4.3.1 Algorithm A
 * Addition of nonnegative n-place integers u and v, returning the sum w.
 * Numbers must already be aligned and length u >= length v.
 */
export var add = function (u, v) {
    var vlen = v.length;
    var n = u.length;
    var w = new Array(n);
    // A1. Initialize
    var j = 0;
    var k = 0;
    while (j < n) {
        // v may be shorter than u
        var vj = j < vlen ? v[j] : 0;
        // A2. Add digits
        var z = u[j] + vj + k;
        w[j] = z % 10000000 /* Constants.RADIX */;
        // .. k is being set to 1 or 0, to carry
        k = (z / 10000000 /* Constants.RADIX */) | 0;
        // A3. Loop on j
        j++;
    }
    if (k === 1) {
        w.push(k);
    }
    return w;
};
/**
 * Knuth TAoCP 4.3.1 Algorithm S
 * Subtraction of nonnegative n-place integers u >= v, returning the sum w.
 * Numbers must already be aligned and length u >= length v.
 */
export var subtract = function (u, v) {
    var m = u.length;
    var n = v.length;
    var w = new Array(m);
    // S1. Initialize
    var j = 0;
    var k = 0;
    // S2. Subtract digits
    while (j < n) {
        var z = u[j] - v[j] - k;
        w[j] = z < 0 ? z + 10000000 /* Constants.RADIX */ : z;
        // k is set to 1 or 0, indicating a borrow
        k = z < 0 ? 1 : 0;
        j++;
        // S3. Loop on j
    }
    // Propagate the borrow flag up
    while (k && j < m) {
        var z = u[j] - k;
        w[j] = z < 0 ? z + 10000000 /* Constants.RADIX */ : z;
        k = z < 0 ? 1 : 0;
        j++;
    }
    // Borrow done, copy remainder of larger number
    while (j < m) {
        w[j] = u[j];
        j++;
    }
    return w;
};
/**
 * Knuth TAoCP 4.3.1 Algorithm M
 * Multiplication of nonnegative integers u and v, returning the product w.
 */
export var multiply = function (u, v) {
    var m = u.length;
    var n = v.length;
    // M1. Initialize, set w all to zero
    var w = new Array(n + m);
    w.fill(0);
    // Skip M2. Zero multiplier check, just follow the algorithm/
    var i = 0;
    var j = 0;
    var k = 0;
    while (j < n) {
        // M3. Initialize i
        i = 0;
        k = 0;
        while (i < m) {
            // M4. Multiply and add
            var p = k + w[i + j] + u[i] * v[j];
            k = (p / 10000000 /* Constants.RADIX */) | 0;
            w[i + j] = p - k * 10000000 /* Constants.RADIX */;
            // M5. Loop on i
            i++;
        }
        // Final carry
        w[j + m] = k;
        // M6. Loop on j
        j++;
    }
    return w;
};
/**
 * Multiplication of a nonnegative integer u by a single word v, returning the product w.
 * See TAoCP 4.3.1 exercise 13.
 */
export var multiplyword = function (w, u, n, v) {
    var i = 0;
    var k = 0;
    for (i = 0; i < n; i++) {
        var p = k + u[i] * v;
        k = (p / 10000000 /* Constants.RADIX */) | 0;
        w[i] = p - k * 10000000 /* Constants.RADIX */;
    }
    if (k > 0) {
        w[i] = k;
    }
};
/**
 * Knuth TAoCP 4.3.1 Algorithm D
 * Division of nonnegative integer u by v, returning the quotient q and remainder r.
 */
export var divide = function (uc, vc) {
    var n = vc.length;
    var m = uc.length - n;
    if (n === 1) {
        return divideword(uc, vc[0]);
    }
    var nplusm = n + m;
    if (nplusm < n) {
        throw new Error("n + m must be >= n, got ".concat(m));
    }
    // Storage for copy of u which is modified in place, and v which needs an
    // extra digit.
    var u = uc.slice();
    u.push(0);
    var v = vc.slice();
    v.push(0);
    // Storage for quotient and remainder.
    var q = new Array(nplusm + 1);
    q.fill(0);
    // D1. Normalize
    var d = (10000000 /* Constants.RADIX */ / (v[n - 1] + 1)) | 0;
    if (d !== 1) {
        multiplyword(u, uc, nplusm, d);
        multiplyword(v, vc, n, d);
    }
    var k = 0;
    var p = 0;
    var hi = 0;
    var lo = 0;
    var j = m;
    while (j >= 0) {
        // D3. Calculate q̂ and r̂.
        p = u[j + n - 1] + u[j + n] * 10000000 /* Constants.RADIX */;
        var qhat = (p / v[n - 1]) | 0;
        var rhat = p - qhat * v[n - 1];
        while (true) {
            // D3. Test if q̂ = radix ...
            if (qhat < 10000000 /* Constants.RADIX */) {
                var z = qhat * v[n - 2];
                hi = (z / 10000000 /* Constants.RADIX */) | 0;
                lo = z - hi * 10000000 /* Constants.RADIX */;
                if (hi <= rhat) {
                    if (hi !== rhat || lo <= u[j + n - 2]) {
                        break;
                    }
                }
            }
            // D3. ... decrease q̂ by 1, increase r̂ by v[n - 1]
            qhat--;
            rhat += v[n - 1];
            if (rhat >= 10000000 /* Constants.RADIX */) {
                break;
            }
        }
        // D4. Multiply and subtract.
        var i = 0;
        k = 0;
        for (i = 0; i <= n; i++) {
            // Multiply.
            p = qhat * v[i] + k;
            hi = (p / 10000000 /* Constants.RADIX */) | 0;
            lo = p - hi * 10000000 /* Constants.RADIX */;
            // Subtract and determine carry.
            var x = u[i + j] - lo;
            k = x < 0 ? 1 : 0;
            u[i + j] = k ? x + 10000000 /* Constants.RADIX */ : x;
            k += hi;
        }
        // Set the j-th quotient digit
        q[j] = qhat;
        // D5. Test remainder of D4.
        if (k > 0) {
            // D6. Add back. Quotient digit is too large by 1.
            q[j] -= 1;
            addhelper(u, j, v, n + 1, n);
        }
        // D7. Loop on j.
        j--;
    }
    // D8. Unnormalize remainder.
    k = 0;
    var r = new Array(n);
    r.fill(0);
    for (var i = n - 1; i >= 0; i--) {
        p = u[i] + k * 10000000 /* Constants.RADIX */;
        r[i] = (p / d) | 0;
        k = p - r[i] * d;
    }
    return [q, r];
};
/**
 * Knuth TAoCP 4.3.1 Exercise 16
 * Division of a nonnegative integer u by a single word v, returning the quotient q
 * and remainder r.
 */
var divideword = function (u, v) {
    var n = u.length;
    var q = new Array(n);
    q.fill(0);
    var r = 0;
    for (var i = n - 1; i >= 0; i--) {
        var p = u[i] + r * 10000000 /* Constants.RADIX */;
        q[i] = (p / v) | 0;
        r = p - q[i] * v;
    }
    return [q, [r]];
};
/**
 * divide() "add back" helper, adds v to u.
 */
var addhelper = function (u, j, v, m, n) {
    var i = 0;
    var k = 0;
    var s = 0;
    while (i < n) {
        s = u[i + j] + (v[i] + k);
        k = s >= 10000000 /* Constants.RADIX */ ? 1 : 0;
        u[i + j] = k ? s - 10000000 /* Constants.RADIX */ : s;
        i++;
    }
    while (k && i < m) {
        s = u[i + j] + k;
        k = s === 10000000 /* Constants.RADIX */ ? 1 : /* istanbul ignore next */ 0;
        u[i + j] = k === 1 ? s - 10000000 /* Constants.RADIX */ : /* istanbul ignore next */ s;
        i++;
    }
    // Final carry is ignored
};
/**
 * Starting at the end of the array, remove all contiguous zeros except
 * the last.
 */
export var trimLeadingZeros = function (data) {
    var i = data.length - 1;
    while (i > 0 && data[i] === 0) {
        data.pop();
        i--;
    }
};
/**
 * Reusable quotient and remainder for repeated divmod operations.
 */
var DivMod = /** @class */ (function () {
    function DivMod() {
        // [quotient, remainder]
        this.s = [0, 0];
    }
    DivMod.prototype.pow10 = function (n, exp) {
        return divpow10(this.s, n, exp);
    };
    /**
     * Divide and modulus n by w. Result is [quotient, remainder].
     */
    DivMod.prototype.word = function (n, w) {
        return divword(this.s, n, w);
    };
    return DivMod;
}());
export { DivMod };
/**
 * Divide and modulus n by 10^exp. Store result in d = [quotient, remainder].
 */
export var divpow10 = function (d, n, exp) {
    var p = POWERS10[exp];
    d[0] = (n / p) | 0;
    d[1] = n - d[0] * p;
    return d;
};
/**
 * Divide and modulus by w. Store result in d = [quotient, remainder].
 */
export var divword = function (_d, n, div) {
    var q = (n / div) | 0;
    var r = n - q * div;
    return [q, r];
};
//# sourceMappingURL=math.js.map