import { add, divide, multiply, subtract, trimLeadingZeros, DivMod } from './math';
import { allzero, compare, digitCount } from './operations';
import { PartsDecimalFormatter, StringDecimalFormatter } from './format';
import { POWERS10 } from './types';
var floor = Math.floor;
var GROUP_NOOP = function () {
    // nothing
};
var DEFAULT_PRECISION = 28;
var EMPTY = [];
var NAN_VALUES = new Set(['nan', 'NaN']);
var POS_INFINITY = new Set(['infinity', '+infinity', 'Infinity', '+Infinity']);
var NEG_INFINITY = new Set(['-infinity', '-Infinity']);
/**
 * Latin decimal digits.
 *
 * @public
 */
export var DECIMAL_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
/**
 * Converts a valid argument into a Decimal value.
 *
 * @public
 */
export var coerceDecimal = function (n) {
    return typeof n === 'number' || typeof n === 'string' ? new Decimal(n) : n;
};
/**
 * Parses and interprets a math context argument, with appropriate defaults.
 */
var parseMathContext = function (rounding, context) {
    var usePrecision = true;
    var scaleprec = DEFAULT_PRECISION;
    if (context !== undefined) {
        if (context.scale !== undefined) {
            scaleprec = context.scale;
            usePrecision = false;
        }
        else if (context.precision !== undefined) {
            scaleprec = Math.max(context.precision, 0);
        }
        if (context.round !== undefined) {
            rounding = context.round;
        }
    }
    return [usePrecision, scaleprec, rounding];
};
/**
 * Return the storage space needed to hold a given number of digits.
 */
var size = function (n) {
    var q = (n / 7 /* Constants.RDIGITS */) | 0;
    var r = n - q * 7 /* Constants.RDIGITS */;
    return r === 0 ? q : q + 1;
};
/**
 * Arbitrary precision decimal type.
 *
 * @public
 */
var Decimal = /** @class */ (function () {
    function Decimal(num) {
        this.data = EMPTY;
        this.sign = 0;
        this._exp = 0;
        this.flag = 0 /* DecimalFlag.NONE */;
        if (typeof num === 'string' || typeof num === 'number') {
            this.parse(num);
        }
        else {
            this.data = num.data.slice();
            this.sign = num.sign;
            this._exp = num._exp;
            this.flag = num.flag;
        }
    }
    /**
     * Return the decimal's exponent.
     */
    Decimal.prototype.exp = function () {
        return this._exp;
    };
    /**
     * Return true if this decimal is not a number (NaN).
     */
    Decimal.prototype.isNaN = function () {
        return this.flag === 1 /* DecimalFlag.NAN */;
    };
    /**
     * Return true if this decimal is finite (not infinity or NaN).
     */
    Decimal.prototype.isFinite = function () {
        return this.flag === 0;
    };
    /**
     * Return true if this decimal is positive or negative infinity.
     */
    Decimal.prototype.isInfinity = function () {
        return this.flag === 2 /* DecimalFlag.INFINITY */;
    };
    /**
     * Compare decimal u to v, returning the following:
     *
     *  -1   if  u &lt; v
     *   0   if  u = v
     *   1   if  u &gt; v
     *
     * If the abs flag is true compare the absolute values.
     *
     * Any NAN argument will always return -1.
     */
    Decimal.prototype.compare = function (v, abs) {
        if (abs === void 0) { abs = false; }
        var u = this;
        v = coerceDecimal(v);
        if (u.flag || v.flag) {
            // NAN is never equal to itself or any other value
            if (u.flag === 1 /* DecimalFlag.NAN */ || v.flag === 1 /* DecimalFlag.NAN */) {
                return -1;
            }
            // INFINITY
            // Infinities can be equal if their sign matches
            if (u.flag === v.flag) {
                return u.sign === v.sign ? 0 : u.sign === -1 ? -1 : 1;
            }
            // Negative infinity before all other values
            // Positive infinity after all other values
            return u.flag === 2 /* DecimalFlag.INFINITY */ ? (u.sign === -1 ? -1 : 1) : v.sign === -1 ? 1 : -1;
        }
        u = u.stripTrailingZeros();
        v = v.stripTrailingZeros();
        var uz = u.isZero();
        var vz = v.isZero();
        if (uz && vz) {
            return 0;
        }
        var us = u.sign;
        var vs = v.sign;
        if (!abs && us !== vs) {
            return us === -1 ? -1 : 1;
        }
        var ue = u.alignexp();
        var ve = v.alignexp();
        if (ue !== ve) {
            if (abs) {
                return ue < ve ? -1 : 1;
            }
            return ue < ve ? -1 * us : us;
        }
        if (u._exp !== v._exp) {
            var shift = u._exp - v._exp;
            if (shift > 0) {
                // Data cannot be equal here
                return -compare(v.data, u.data, shift);
            }
            return compare(u.data, v.data, -shift);
        }
        // Same number of radix digits.
        var i = u.data.length - 1;
        while (i >= 0) {
            var a = u.data[i];
            var b = v.data[i];
            if (a !== b) {
                return (a < b ? -1 : 1) * (abs ? 1 : u.sign);
            }
            i--;
        }
        // Equal
        return 0;
    };
    /**
     * Return the raw internal properties of the number. Use with caution.
     */
    Decimal.prototype.properties = function () {
        return [this.data, this.sign, this._exp, this.flag];
    };
    /**
     * Return the absolute value of the number.
     */
    Decimal.prototype.abs = function () {
        return this.sign === -1 ? Decimal.fromRaw(-this.sign, this._exp, this.data, this.flag) : this;
    };
    /**
     * Invert this number's sign.
     */
    Decimal.prototype.negate = function () {
        return this.isNaN() ? this : Decimal.fromRaw(-this.sign, this._exp, this.data, this.flag);
    };
    /**
     * Indicates this number is negative.
     */
    Decimal.prototype.isNegative = function () {
        return this.sign === -1;
    };
    /**
     * Signum.
     */
    Decimal.prototype.signum = function () {
        return this.isZero() ? 0 : this.sign;
    };
    /**
     * Check if this number can be represented as an integer without loss of precision.
     * For example, '12.000' is the same number as '12'.
     */
    Decimal.prototype.isInteger = function () {
        if (this.flag) {
            return false;
        }
        return this._exp + this.trailingZeros() >= 0;
    };
    /**
     * Number is exactly zero. Exponent may exist, e.g. "0e-2" is "0.00".
     */
    Decimal.prototype.isZero = function () {
        return !this.flag && this.data.length === 1 && this.data[0] === 0;
    };
    /**
     * Return the integer part.
     */
    Decimal.prototype.toInteger = function () {
        return this.flag ? this : this.setScale(0, 'down');
    };
    /**
     * Adds v.
     */
    Decimal.prototype.add = function (v) {
        v = coerceDecimal(v);
        var r = this.handleFlags(0 /* Op.ADDITION */, v);
        if (r === undefined) {
            if (this.isZero()) {
                return v;
            }
            return v.isZero() ? this : this.addsub(this, v, v.sign);
        }
        return r;
    };
    /**
     * Subtracts v.
     */
    Decimal.prototype.subtract = function (v) {
        v = coerceDecimal(v);
        var r = this.handleFlags(1 /* Op.SUBTRACTION */, v);
        if (r === undefined) {
            if (this.isZero()) {
                return v.negate();
            }
            return v.isZero() ? this : this.addsub(this, v, -v.sign);
        }
        return r;
    };
    /**
     * Multiplies by v with optional math context.
     */
    Decimal.prototype.multiply = function (v, context) {
        var _a = parseMathContext('half-even', context), usePrecision = _a[0], scaleprec = _a[1], rounding = _a[2];
        v = coerceDecimal(v);
        var r = this.handleFlags(2 /* Op.MULTIPLICATION */, v);
        if (r !== undefined) {
            return r;
        }
        var u = this;
        var w = new Decimal(ZERO);
        w.sign = u.sign === v.sign ? 1 : -1;
        w._exp = u._exp + v._exp;
        var uz = u.isZero();
        var vz = v.isZero();
        if (uz || vz) {
            if (!usePrecision) {
                w._setScale(scaleprec);
            }
            return w;
        }
        w.data = multiply(u.data, v.data);
        w.sign = u.sign === v.sign ? 1 : -1;
        w.trim();
        // Adjust coefficient to match precision
        if (usePrecision) {
            var delta = w.precision() - scaleprec;
            if (delta > 0) {
                w._shiftright(delta, rounding);
            }
        }
        else {
            w._setScale(scaleprec, rounding);
        }
        return w;
    };
    /**
     * Divide by v with optional math context.
     */
    Decimal.prototype.divide = function (v, context) {
        v = coerceDecimal(v);
        var r = this.handleFlags(3 /* Op.DIVISION */, v);
        if (r !== undefined) {
            return r;
        }
        var _a = parseMathContext('half-even', context), usePrecision = _a[0], scaleprec = _a[1], rounding = _a[2];
        var w;
        var u = this;
        var sign = u.sign === v.sign ? 1 : -1;
        var shift = usePrecision
            ? v.precision() - u.precision() + scaleprec + 2
            : v.precision() + u.precision() + Math.abs(scaleprec) + 2;
        var exp = u._exp - v._exp - shift;
        if (shift > 0) {
            u = u.shiftleft(shift);
        }
        else if (shift < 0) {
            v = v.shiftleft(-shift);
        }
        var _b = divide(u.data, v.data), q = _b[0], rem = _b[1];
        w = Decimal.fromRaw(sign, exp, q, 0);
        w.trim();
        var hasrem = rem.length && !allzero(rem, rem.length);
        if (hasrem) {
            var lsd = w.data[0] % 10;
            if (lsd === 0 || lsd === 5) {
                w.data[0]++;
            }
        }
        if (usePrecision) {
            // Adjust precision to match context
            var delta = w.precision() - scaleprec;
            if (delta > 0) {
                w._shiftright(delta, rounding);
            }
        }
        else {
            // Adjust scale to match context
            w._setScale(scaleprec, rounding);
        }
        if (usePrecision) {
            w._stripTrailingZeros();
        }
        return w;
    };
    /**
     * Divide by v and return the quotient and remainder.
     */
    Decimal.prototype.divmod = function (v) {
        v = coerceDecimal(v);
        var rq = this.handleFlags(3 /* Op.DIVISION */, v);
        if (rq !== undefined) {
            var rm = this.handleFlags(4 /* Op.MOD */, v);
            return [rq, rm];
        }
        var u = this;
        var exp = u._exp > v._exp ? v._exp : u._exp;
        if (u._exp !== v._exp) {
            var shift = u._exp - v._exp;
            if (shift > 0) {
                u = u.shiftleft(shift);
            }
            else {
                v = v.shiftleft(-shift);
            }
        }
        // Ensure u digits are >= v
        var dsize = v.data.length - u.data.length;
        if (dsize > 0) {
            if (u === this) {
                u = new Decimal(u);
            }
            for (var i = 0; i < dsize; i++) {
                u.data.push(0);
            }
        }
        var _a = divide(u.data, v.data), qd = _a[0], rd = _a[1];
        var q = new Decimal(ZERO);
        q.data = qd;
        q.sign = u.sign === v.sign ? 1 : -1;
        var r = new Decimal(ZERO);
        r.data = rd;
        r.sign = u.sign;
        r._exp = exp;
        return [q.trim(), r.trim()];
    };
    /**
     * Divide by v and return the remainder.
     */
    Decimal.prototype.mod = function (v) {
        v = coerceDecimal(v);
        var r = this.handleFlags(4 /* Op.MOD */, v);
        return r === undefined ? this.divmod(v)[1] : r;
    };
    /**
     * Number of trailing zeros.
     */
    Decimal.prototype.trailingZeros = function () {
        if (this.flag) {
            return 0;
        }
        var d = this.data;
        var len = d.length;
        var r = 0;
        for (var i = 0; i < len; i++) {
            if (d[i] !== 0) {
                var n = d[i];
                r = i * 7 /* Constants.RDIGITS */;
                while (n % 10 === 0) {
                    n /= 10 | 0;
                    r++;
                }
                break;
            }
        }
        return r;
    };
    /**
     * Strip all trailing zeros.
     */
    Decimal.prototype.stripTrailingZeros = function () {
        if (this.flag) {
            return this;
        }
        var r = new Decimal(this);
        r._stripTrailingZeros();
        return r;
    };
    /**
     * Return a scientific representation of the number,
     * Decimal coefficient and adjusted exponent.
     */
    Decimal.prototype.scientific = function (minIntDigits) {
        if (minIntDigits === void 0) { minIntDigits = 1; }
        if (this.flag) {
            return [this, 0];
        }
        minIntDigits = minIntDigits <= 1 ? 1 : minIntDigits;
        var exp = -(this.precision() - 1) + (minIntDigits - 1);
        // ensure exponent is not negative zero
        var coeff = Decimal.fromRaw(this.sign, exp === 0 ? 0 : exp, this.data, this.flag);
        return [coeff, this._exp - coeff._exp];
    };
    /**
     * Number of digits in the unscaled value.
     */
    Decimal.prototype.precision = function () {
        if (this.flag) {
            return 0;
        }
        var len = this.data.length;
        return (len - 1) * 7 /* Constants.RDIGITS */ + digitCount(this.data[len - 1]);
    };
    /**
     * Scale is the number of digits to the right of the decimal point.
     */
    Decimal.prototype.scale = function () {
        return this.flag ? 0 : this._exp === 0 ? 0 : -this._exp;
    };
    /**
     * Number of integer digits, 1 or higher.
     */
    Decimal.prototype.integerDigits = function () {
        return this.flag ? 0 : Math.max(this.precision() + this._exp, 1);
    };
    /**
     * Returns a new number with the given scale, shifting the coefficient as needed.
     */
    Decimal.prototype.setScale = function (scale, roundingMode) {
        if (roundingMode === void 0) { roundingMode = 'half-even'; }
        if (this.flag) {
            return this;
        }
        var r = new Decimal(this);
        r._setScale(floor(scale), roundingMode);
        return r;
    };
    /**
     * Adjusted exponent for alignment. Two numbers with the same aligned exponent are
     * aligned for arithmetic operations. If the aligned exponents do not match one
     * number must be shifted.
     */
    Decimal.prototype.alignexp = function () {
        return this.flag ? 0 : this._exp + this.precision() - 1;
    };
    /**
     * Move the decimal point -n (left) or +n (right) places. Does not change
     * precision, only affects the exponent.
     */
    Decimal.prototype.movePoint = function (n) {
        if (this.flag) {
            return this;
        }
        var w = new Decimal(this);
        w._exp += floor(n);
        return w;
    };
    /**
     * Shifts all digits to the left, increasing the precision.
     */
    Decimal.prototype.shiftleft = function (shift) {
        if (this.flag) {
            return this;
        }
        var w = new Decimal(this);
        w._shiftleft(floor(shift));
        return w;
    };
    /**
     * Shifts all digits to the right, reducing the precision. Result is rounded
     * using the given rounding mode.
     */
    Decimal.prototype.shiftright = function (shift, mode) {
        if (mode === void 0) { mode = 'half-even'; }
        if (this.flag) {
            return this;
        }
        var w = new Decimal(this);
        w._shiftright(floor(shift), mode);
        return w;
    };
    /**
     * Increment the least-significant integer digit.
     */
    Decimal.prototype.increment = function () {
        if (this.flag) {
            return this;
        }
        var r = new Decimal(this);
        if (r.sign === -1 || r._exp !== 0) {
            return r.add(DecimalConstants.ONE);
        }
        r._increment();
        return r;
    };
    /**
     * Decrement the least-significant integer digit.
     */
    Decimal.prototype.decrement = function () {
        return this.flag ? this : this.subtract(DecimalConstants.ONE);
    };
    /**
     * Format the number to a string, using fixed point.
     */
    Decimal.prototype.toString = function () {
        return this.flag ? this.formatFlags() : this.formatString(this, 1);
    };
    /**
     * Format this number to scientific notation as a string.
     */
    Decimal.prototype.toScientificString = function (minIntegers) {
        if (minIntegers === void 0) { minIntegers = 1; }
        if (this.flag) {
            return this.formatFlags();
        }
        var _a = this.scientific(minIntegers), coeff = _a[0], exp = _a[1];
        var r = this.formatString(coeff, minIntegers);
        return coeff.isZero() ? r : exp === 0 ? r : r + "E".concat(exp > 0 ? '+' : '').concat(exp);
    };
    /**
     * Format this number to an array of parts.
     */
    Decimal.prototype.toParts = function () {
        return this.flag ? this.formatFlagsParts() : this.formatParts(this, 1);
    };
    /**
     * Format this number to scientific notation as an array of parts.
     */
    Decimal.prototype.toScientificParts = function (minIntegers) {
        if (minIntegers === void 0) { minIntegers = 1; }
        if (this.flag) {
            return this.formatFlagsParts();
        }
        var _a = this.scientific(minIntegers), coeff = _a[0], exp = _a[1];
        var r = this.formatParts(coeff, minIntegers);
        if (coeff.isZero() || exp === 0) {
            return r;
        }
        var sign = exp < 0 ? { type: 'minus', value: '-' } : { type: 'plus', value: '+' };
        return r.concat([{ type: 'exp', value: 'E' }, sign, { type: 'integer', value: "".concat(Math.abs(exp)) }]);
    };
    /**
     * Low-level formatting of string and Part[] forms.
     */
    Decimal.prototype.format = function (formatter, decimal, group, minInt, minGroup, priGroup, secGroup, zeroScale, digits) {
        if (digits === void 0) { digits = DECIMAL_DIGITS; }
        // Determine if grouping is enabled, and set the primary and
        // secondary group sizes.
        var grouping = group !== '';
        if (secGroup <= 0) {
            secGroup = priGroup;
        }
        var exp = this._exp;
        // Determine how many integer digits to emit. If integer digits is
        // larger than the integer coefficient we emit leading zeros.
        var int = this.data.length === 1 && this.data[0] === 0 ? 1 : this.precision() + exp;
        if (minInt <= 0 && this.compare(ONE, true) === -1) {
            // If the number is between 0 and 1 and format requested minimum
            // integer digits of zero, don't emit a leading zero digit.
            int = 0;
        }
        else {
            int = Math.max(int, minInt);
        }
        // Array to append digits in reverse order
        var len = this.data.length;
        var groupSize = priGroup;
        var emitted = 0;
        // Determine if grouping should be active.
        var groupFunc = GROUP_NOOP;
        if (grouping && priGroup > 0 && int >= minGroup + priGroup) {
            groupFunc = function () {
                if (emitted > 0 && emitted % groupSize === 0) {
                    // Push group character, reset emitted digits, and switch
                    // to secondary grouping size.
                    formatter.add(group);
                    emitted = 0;
                    groupSize = secGroup;
                }
            };
        }
        // Push trailing zeros for a positive exponent, only if the number
        // is non-zero
        var zeros = exp;
        if (!(this.data.length === 1 && this.data[0] === 0)) {
            while (zeros > 0) {
                formatter.add(digits[0]);
                emitted++;
                groupFunc();
                int--;
                zeros--;
            }
        }
        else if (zeroScale && exp < 0) {
            // Handle sign of zero which means we have exactly '0'. If we
            // have the 'zeroScale' flag set, a negative exponent here will
            // emit zeros after the decimal point.
            while (exp < 0) {
                exp++;
                formatter.add(digits[0]);
            }
            formatter.add(decimal);
        }
        // Scan coefficient from least- to most-significant digit.
        var last = len - 1;
        for (var i = 0; i < len; i++) {
            // Count the decimal digits c in this radix digit d
            var d = this.data[i];
            var c = i === last ? digitCount(d) : 7 /* Constants.RDIGITS */;
            // Loop over the decimal digits
            for (var j = 0; j < c; j++) {
                // Push decimal digit
                formatter.add(digits[d % 10]);
                d = (d / 10) | 0;
                // When we've reached exponent of 0, push the decimal point.
                exp++;
                if (exp === 0) {
                    formatter.add(decimal);
                }
                // Decrement integer, increment emitted digits when exponent is positive, to
                // trigger grouping logic. We only do this once exp has become positive to
                // avoid counting emitted digits for decimal part.
                if (exp > 0) {
                    emitted++;
                    int--;
                    if (int > 0) {
                        groupFunc();
                    }
                }
            }
        }
        // If exponent still negative, emit leading decimal zeros
        // if (!(this.data.length === 1 && this.data[0] === 0)) {
        while (exp < 0) {
            formatter.add(digits[0]);
            // When we've reached exponent of 0, push the decimal point
            exp++;
            if (exp === 0) {
                formatter.add(decimal);
            }
        }
        // }
        // Leading integer zeros
        while (int > 0) {
            formatter.add(digits[0]);
            emitted++;
            int--;
            if (int > 0) {
                groupFunc();
            }
        }
    };
    Decimal.prototype.formatFlags = function () {
        switch (this.flag) {
            case 1 /* DecimalFlag.NAN */:
                return 'NaN';
            case 2 /* DecimalFlag.INFINITY */:
            default:
                return this.sign === 1 ? 'Infinity' : '-Infinity';
        }
    };
    Decimal.prototype.formatFlagsParts = function () {
        switch (this.flag) {
            case 1 /* DecimalFlag.NAN */:
                return [{ type: 'nan', value: 'NaN' }];
            case 2 /* DecimalFlag.INFINITY */:
            default:
                var s = this.sign === 1 ? 'Infinity' : '-Infinity';
                return [{ type: 'infinity', value: s }];
        }
    };
    Decimal.prototype.formatString = function (d, minInt) {
        var f = new StringDecimalFormatter();
        d.format(f, '.', '', minInt, 1, 3, 3, true);
        var r = f.render();
        return d.sign === -1 ? '-' + r : r;
    };
    Decimal.prototype.formatParts = function (d, minInt) {
        var f = new PartsDecimalFormatter('.', '');
        d.format(f, '.', '', minInt, 1, 3, 3, true);
        var r = f.render();
        return d.sign === -1 ? [{ type: 'minus', value: '-' }].concat(r) : r;
    };
    /**
     * Handle setting of flags for operations per the IEEE-754-2008 specification.
     * These rules are also referenced in the EcmaScript specification:
     *
     * 12.7.3.1 - Applying the mul operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-mul-operator
     *
     * 12.7.3.2 - Applying the div operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-div-operator
     *
     * 12.7.3.3 - Applying the mod operator:
     * https://tc39.github.io/ecma262/#sec-applying-the-mod-operator
     *
     * 12.8.5 - Applying the additive operators to numbers:
     * https://tc39.github.io/ecma262/#sec-applying-the-additive-operators-to-numbers
     *
     */
    Decimal.prototype.handleFlags = function (op, v) {
        var u = this;
        var uflag = u.flag;
        var vflag = v.flag;
        // Any operation involving a NAN returns a NAN
        if (uflag === 1 /* DecimalFlag.NAN */ || vflag === 1 /* DecimalFlag.NAN */) {
            return NAN;
        }
        var uinf = uflag === 2 /* DecimalFlag.INFINITY */;
        var vinf = vflag === 2 /* DecimalFlag.INFINITY */;
        var uzero = u.isZero();
        var vzero = v.isZero();
        switch (op) {
            case 0 /* Op.ADDITION */:
                if (uinf && vinf) {
                    return u.sign === v.sign ? (u.sign === 1 ? POSITIVE_INFINITY : NEGATIVE_INFINITY) : NAN;
                }
                else if (uinf || vinf) {
                    return uinf ? u : v;
                }
                break;
            case 1 /* Op.SUBTRACTION */:
                if (uinf && vinf) {
                    return u.sign === v.sign ? NAN : u.sign === 1 ? POSITIVE_INFINITY : NEGATIVE_INFINITY;
                }
                else if (uinf || vinf) {
                    return uinf
                        ? u.sign === 1
                            ? POSITIVE_INFINITY
                            : NEGATIVE_INFINITY
                        : v.sign === 1
                            ? NEGATIVE_INFINITY
                            : POSITIVE_INFINITY;
                }
                break;
            case 2 /* Op.MULTIPLICATION */:
                if (uinf) {
                    return vzero ? NAN : u.sign === v.sign ? POSITIVE_INFINITY : NEGATIVE_INFINITY;
                }
                if (vinf) {
                    return uzero ? NAN : u.sign === v.sign ? POSITIVE_INFINITY : NEGATIVE_INFINITY;
                }
                break;
            case 3 /* Op.DIVISION */:
                if (uinf && vinf) {
                    return NAN;
                }
                if (uinf) {
                    return vzero
                        ? u.sign === 1
                            ? POSITIVE_INFINITY
                            : NEGATIVE_INFINITY
                        : u.sign === v.sign
                            ? POSITIVE_INFINITY
                            : NEGATIVE_INFINITY;
                }
                if (vinf) {
                    return ZERO;
                }
                if (vzero) {
                    return uzero ? NAN : u.sign === 1 ? POSITIVE_INFINITY : NEGATIVE_INFINITY;
                }
                break;
            case 4 /* Op.MOD */:
                if (uinf || vzero) {
                    return NAN;
                }
                if (!uinf && vinf) {
                    return u;
                }
                if (uzero && !vzero && !vinf) {
                    return u;
                }
                break;
        }
        return undefined;
    };
    Decimal.fromRaw = function (sign, _exp, data, flag) {
        return new this({ sign: sign, _exp: _exp, data: data, flag: flag });
    };
    /**
     * Mutating in-place shift left.
     */
    Decimal.prototype._shiftleft = function (shift) {
        if (shift <= 0) {
            return;
        }
        var w = this;
        var prec = w.precision();
        var data = w.data.slice();
        // w.data.fill(0);
        var m = data.length;
        // Compute the shift in terms of our radix.
        var q = (shift / 7 /* Constants.RDIGITS */) | 0;
        var r = shift - q * 7 /* Constants.RDIGITS */;
        // Expand w to hold shifted result and zero all elements.
        var n = size(prec + shift);
        w.data = new Array(n);
        w.data.fill(0);
        // Trivial case where shift is a multiple of our radix.
        if (r === 0) {
            while (--m >= 0) {
                w.data[m + q] = data[m];
            }
            return;
        }
        // Shift divided by radix leaves a remainder.
        var powlo = POWERS10[r];
        var powhi = POWERS10[7 /* Constants.RDIGITS */ - r];
        var hi = 0;
        var lo = 0;
        var loprev = 0;
        n--;
        m--;
        hi = (data[m] / powhi) | 0;
        loprev = data[m] - hi * powhi;
        if (hi !== 0) {
            w.data[n] = hi;
            n--;
        }
        m--;
        // Divmod each element of u, copying the hi/lo parts to w.
        for (; m >= 0; m--, n--) {
            hi = (data[m] / powhi) | 0;
            lo = data[m] - hi * powhi;
            w.data[n] = powlo * loprev + hi;
            loprev = lo;
        }
        w.data[q] = powlo * loprev;
    };
    /**
     * Mutating in-place shift right.
     */
    Decimal.prototype._shiftright = function (shift, mode) {
        var _a, _b, _c;
        if (shift <= 0) {
            return;
        }
        if (this.isZero()) {
            this._exp += shift;
            return;
        }
        var w = this;
        var prec = w.precision();
        // Check if shift exceeds precision, so all digits are shifted to
        // zero with no rounding possible. Just set zero and bump the exponent.
        if (prec < shift) {
            w.data = [0];
            w._exp += shift;
            return;
        }
        // We only want to round up when there is a free zero integer
        // digit to the left. We do this when the number is < 0 or
        // we're not shifting out all of the digits.
        var round = w.alignexp() < 0 || prec !== shift;
        var div = new DivMod();
        var _d = div.word(shift, 7 /* Constants.RDIGITS */), q = _d[0], r = _d[1];
        var data = w.data.slice();
        w.data.fill(0);
        // check if we divided evenly
        var i = 0, j = 0;
        var rnd = 0, rest = 0;
        if (r === 0) {
            // q is always non-zero here, else there would be no shift
            _a = div.pow10(data[q - 1], 7 /* Constants.RDIGITS */ - 1), rnd = _a[0], rest = _a[1];
            if (rest === 0) {
                rest = allzero(data, q - 1) === 0 ? 1 : 0;
            }
            for (j = 0; j < data.length - q; j++) {
                w.data[j] = data[q + j];
            }
        }
        else {
            var hiprev = 0;
            var ph = POWERS10[7 /* Constants.RDIGITS */ - r];
            // q is always < data.length here; otherwise r == 0
            _b = div.pow10(data[q], r), hiprev = _b[0], rest = _b[1];
            _c = div.pow10(rest, r - 1), rnd = _c[0], rest = _c[1];
            if (rest === 0 && q > 0) {
                rest = allzero(data, q) === 0 ? 1 : 0;
            }
            for (j = 0, i = q + 1; i < data.length; i++, j++) {
                var _e = div.pow10(data[i], r), hi = _e[0], lo = _e[1];
                w.data[j] = ph * lo + hiprev;
                hiprev = hi;
            }
            if (hiprev !== 0) {
                w.data[j] = hiprev;
            }
        }
        w.trim();
        w._exp += shift;
        if (round && w.round(rnd, rest, mode)) {
            // If precision changes due to rounding, subtract from exponent
            w._increment();
        }
    };
    Decimal.prototype._setScale = function (scale, roundingMode) {
        if (roundingMode === void 0) { roundingMode = 'half-even'; }
        var diff = scale - this.scale();
        if (diff > 0) {
            this._shiftleft(diff);
        }
        else {
            this._shiftright(-diff, roundingMode);
        }
        this._exp = scale === 0 ? 0 : -scale;
        this.trim();
    };
    Decimal.prototype._stripTrailingZeros = function () {
        var n = 0;
        // Special case for zero with negative exponent
        if (this.data.length === 1 && this.data[0] === 0 && this._exp < 0) {
            n = -this._exp;
        }
        else {
            n = this.trailingZeros();
        }
        if (n > 0) {
            this._shiftright(n, 'down');
        }
    };
    /**
     * Trim leading zeros from a result and reset sign and exponent accordingly.
     */
    Decimal.prototype.trim = function () {
        trimLeadingZeros(this.data);
        return this;
    };
    /**
     * Increment the least-significant digit of the coefficient.
     */
    Decimal.prototype._increment = function () {
        var d = this.data;
        var len = d.length;
        var s = 0;
        var k = 1;
        for (var i = 0; k === 1 && i < len; i++) {
            s = d[i] + k;
            k = s === 10000000 /* Constants.RADIX */ ? 1 : 0;
            d[i] = k ? 0 : s;
        }
        if (k === 1) {
            d.push(1);
        }
    };
    /**
     * Return a rounding indicator for a given rounding mode,
     */
    Decimal.prototype.round = function (rnd, rest, mode) {
        if (rest !== 0 && (rnd === 0 || rnd === 5)) {
            rnd++;
        }
        switch (mode) {
            case 'up':
                // round away from zero
                return Number(rnd !== 0);
            case 'down':
                // round towards zero
                return 0;
            case 'ceiling':
                // round towards positive infinity
                return Number(!(rnd === 0 || this.sign === -1));
            case 'floor':
                // round towards negative infinity
                return Number(!(rnd === 0 || this.sign >= 0));
            case 'half-up':
                // if n >= 5 round up; otherwise round down
                return Number(rnd >= 5);
            case 'half-down':
                // if n > 5 round up; otherwise round down
                return Number(rnd > 5);
            case 'half-even':
                // if n = 5 and digit to left of n is odd round up; if even round down
                return Number(rnd > 5 || (rnd === 5 && this.isodd()));
            default:
                return 0;
        }
    };
    /**
     * Return true if this instance is odd.
     */
    Decimal.prototype.isodd = function () {
        return this.data.length > 0 && this.data[0] % 2 === 1;
    };
    /**
     * Addition and subtraction.
     */
    Decimal.prototype.addsub = function (u, v, vsign) {
        var _a, _b, _c;
        var m = u; // m = bigger
        var n = v; // n = smaller
        var swap = 0;
        if (m._exp < n._exp) {
            _a = [n, m], m = _a[0], n = _a[1];
            swap++;
        }
        var shift = m._exp - n._exp;
        m = m.shiftleft(shift);
        var w = new Decimal(ZERO);
        w._exp = n._exp;
        if (m.data.length < n.data.length) {
            _b = [n, m], m = _b[0], n = _b[1];
            swap++;
        }
        if (u.sign === vsign) {
            w.data = add(m.data, n.data);
            w.sign = vsign;
        }
        else {
            var ulen = m.data.length;
            var vlen = n.data.length;
            if (ulen === vlen) {
                for (var i = ulen - 1; i >= 0; i--) {
                    if (m.data[i] !== n.data[i]) {
                        if (m.data[i] < n.data[i]) {
                            _c = [n, m], m = _c[0], n = _c[1];
                            swap++;
                        }
                        break;
                    }
                }
            }
            w.data = subtract(m.data, n.data);
            w.sign = (swap & 1) === 1 ? vsign : m.sign;
        }
        return w.trim();
    };
    /**
     * Parse a number or string setting the fields on the current instance.
     */
    Decimal.prototype.parse = function (arg) {
        if (typeof arg === 'number') {
            if (isNaN(arg)) {
                this.flag = 1 /* DecimalFlag.NAN */;
                return;
            }
            if (!isFinite(arg)) {
                this.flag = 2 /* DecimalFlag.INFINITY */;
                this.sign = arg === Infinity ? 1 : -1;
                return;
            }
        }
        var str = typeof arg === 'string' ? arg : arg.toString();
        var msg = this._parse(str);
        if (msg !== undefined) {
            throw new Error(msg);
        }
    };
    /**
     * Parse a string into a Decimal.
     *
     * Expects strings of the form:
     *    "[-+][digits][.][digits][eE][-+][digits]"
     * or:
     *    "[nN]a[nN]"        for a NaN
     *    "[-+]?[iI]nfinity" for positive or negative infinity
     */
    Decimal.prototype._parse = function (str) {
        if (NAN_VALUES.has(str)) {
            this.flag = 1 /* DecimalFlag.NAN */;
            return;
        }
        if (POS_INFINITY.has(str)) {
            this.flag = 2 /* DecimalFlag.INFINITY */;
            this.sign = 1;
            return;
        }
        if (NEG_INFINITY.has(str)) {
            this.flag = 2 /* DecimalFlag.INFINITY */;
            this.sign = -1;
            return;
        }
        // Local variables to accumulate digits, sign and exponent
        var data = [];
        // Default sign is 1. Negative sign is -1. NaN sign is 0.
        var sign = 1;
        var exp = 0;
        // Flags to control parsing, raise errors.
        var flags = 0;
        // Current number being parsed.
        var n = 0;
        // Index of power for current digit.
        var z = 0;
        // Pointer to the current character being parsed.
        var i = str.length - 1;
        // Total number of digits parsed.
        var dig = 0;
        // We parse from the end to avoid multiple passes or splitting of the
        // input string.
        while (i >= 0) {
            var code = str.charCodeAt(i);
            switch (code) {
                case 69 /* Chars.ELOWER */:
                case 101 /* Chars.EUPPER */:
                    if (flags & 4 /* ParseFlags.EXP */) {
                        return "Extra exponent character at ".concat(i);
                    }
                    if (data.length > 0) {
                        // Exponent is currently limited to the size of Constants.RADIX
                        return 'Exponent too large';
                    }
                    if (dig === 0) {
                        return 'Exponent not provided';
                    }
                    // Indicate we have an exponent, and clear the sign flag.
                    flags |= 4 /* ParseFlags.EXP */;
                    flags &= ~1 /* ParseFlags.SIGN */;
                    // Copy the parsed number to the exponent and reset the digit count.
                    dig = 0;
                    exp = sign === -1 ? -n : n;
                    sign = 1;
                    n = 0;
                    z = 0;
                    break;
                case 45 /* Chars.MINUS */:
                case 43 /* Chars.PLUS */:
                    if (dig === 0) {
                        return 'Found a bare sign symbol';
                    }
                    if (flags & 1 /* ParseFlags.SIGN */) {
                        return "Duplicate sign character at ".concat(i);
                    }
                    sign = code === 45 /* Chars.MINUS */ ? -1 : 1;
                    flags |= 1 /* ParseFlags.SIGN */;
                    break;
                case 46 /* Chars.DOT */:
                    if (flags & 2 /* ParseFlags.POINT */) {
                        return "Extra radix point seen at ".concat(i);
                    }
                    flags |= 2 /* ParseFlags.POINT */;
                    exp -= dig;
                    break;
                case 48 /* Chars.DIGIT0 */:
                case 49 /* Chars.DIGIT1 */:
                case 50 /* Chars.DIGIT2 */:
                case 51 /* Chars.DIGIT3 */:
                case 52 /* Chars.DIGIT4 */:
                case 53 /* Chars.DIGIT5 */:
                case 54 /* Chars.DIGIT6 */:
                case 55 /* Chars.DIGIT7 */:
                case 56 /* Chars.DIGIT8 */:
                case 57 /* Chars.DIGIT9 */:
                    n += (code - 48 /* Chars.DIGIT0 */) * POWERS10[z];
                    z++;
                    dig++;
                    if (z === 7 /* Constants.RDIGITS */) {
                        data.push(n);
                        n = 0;
                        z = 0;
                    }
                    break;
                default:
                    return "Unexpected character at ".concat(i, ": ").concat(str[i]);
            }
            i--;
        }
        if (dig === 0) {
            return 'Number must include at least 1 digit';
        }
        data.push(n);
        this.data = data;
        this.sign = sign === -1 ? -1 : 1;
        this._exp = exp;
        this.trim();
        return undefined;
    };
    return Decimal;
}());
export { Decimal };
var ZERO = new Decimal('0');
var ONE = new Decimal('1');
var TWO = new Decimal('2');
// 105 digits of pi - https://oeis.org/A000796/constant
var PI = new Decimal('3.141592653589793238462643383279502884197169399375105' + '82097494459230781640628620899862803482534211706798214');
// 105 digits of e - https://oeis.org/A001113/constant
var E = new Decimal('2.718281828459045235360287471352662497757247093699959' + '57496696762772407663035354759457138217852516642742746');
var NAN = new Decimal(NaN);
var NEGATIVE_INFINITY = new Decimal(-Infinity);
var POSITIVE_INFINITY = new Decimal(Infinity);
/**
 * Common Decimal values as constants.
 *
 * @public
 */
export var DecimalConstants = {
    ZERO: ZERO,
    ONE: ONE,
    TWO: TWO,
    PI: PI,
    E: E,
    NAN: NAN,
    POSITIVE_INFINITY: POSITIVE_INFINITY,
    NEGATIVE_INFINITY: NEGATIVE_INFINITY,
};
//# sourceMappingURL=decimal.js.map