/**
 * Knuth TAoCP 4.3.1 Algorithm A
 * Addition of nonnegative n-place integers u and v, returning the sum w.
 * Numbers must already be aligned and length u >= length v.
 */
export declare const add: (u: number[], v: number[]) => number[];
/**
 * Knuth TAoCP 4.3.1 Algorithm S
 * Subtraction of nonnegative n-place integers u >= v, returning the sum w.
 * Numbers must already be aligned and length u >= length v.
 */
export declare const subtract: (u: number[], v: number[]) => number[];
/**
 * Knuth TAoCP 4.3.1 Algorithm M
 * Multiplication of nonnegative integers u and v, returning the product w.
 */
export declare const multiply: (u: number[], v: number[]) => number[];
/**
 * Multiplication of a nonnegative integer u by a single word v, returning the product w.
 * See TAoCP 4.3.1 exercise 13.
 */
export declare const multiplyword: (w: number[], u: number[], n: number, v: number) => void;
/**
 * Knuth TAoCP 4.3.1 Algorithm D
 * Division of nonnegative integer u by v, returning the quotient q and remainder r.
 */
export declare const divide: (uc: number[], vc: number[]) => [number[], number[]];
/**
 * Starting at the end of the array, remove all contiguous zeros except
 * the last.
 */
export declare const trimLeadingZeros: (data: number[]) => void;
/**
 * Reusable quotient and remainder for repeated divmod operations.
 */
export declare class DivMod {
    private s;
    pow10(n: number, exp: number): number[];
    /**
     * Divide and modulus n by w. Result is [quotient, remainder].
     */
    word(n: number, w: number): number[];
}
/**
 * Divide and modulus n by 10^exp. Store result in d = [quotient, remainder].
 */
export declare const divpow10: (d: number[], n: number, exp: number) => number[];
/**
 * Divide and modulus by w. Store result in d = [quotient, remainder].
 */
export declare const divword: (_d: number[], n: number, div: number) => number[];
