/**
 * Parses a string into message code. The result can be used to evaluate the
 * message or serialized to JSON for later evaluation.
 *
 * @public
 */
export var parseMessagePattern = function (raw, matcher, disableEscapes) {
    return new MessagePatternParser(raw, matcher, disableEscapes).parse();
};
/**
 * Hand-implemented parser for ICU message format. Designed to be compact and
 * fast vs. other implementations.
 * The parser produces an instruction tree which can be cached for repeated
 * use, and is intended to be evaluated by a separate engine.
 *
 * Note: The 'choice' formatter is not implemented since it is deprecated.
 *
 * See ICU docs for details on syntax:
 * https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/MessageFormat.html
 *
 * Rationale
 *
 * The decision to hand-implement the parser was for 2 reasons:
 * 1. Avoiding extra runtime dependencies (parser generators, e.g. pegjs, etc)
 * 2. Provide control over the memory allocation, garbage generation, and other
 *    aspects that impact parser performance.
 *
 * A major consideration is size of the resulting parser code. The OpenJS project
 * 'messageformat-parser' which is generated by Peg.js is 30kB minified. It also
 * requires other dependencies for the plural calculations, where this is already
 * supported in our library via @phensley/plurals
 *
 * See:
 *   https://unpkg.com/messageformat-parser/parser.js
 */
var MessagePatternParser = /** @class */ (function () {
    function MessagePatternParser(raw, matcher, disableEscapes) {
        this.raw = raw;
        this.matcher = matcher;
        this.disableEscapes = disableEscapes;
    }
    MessagePatternParser.prototype.parse = function () {
        var t = this.raw;
        return this.outer({ t: t, s: 0, e: t.length });
    };
    MessagePatternParser.prototype.outer = function (r, argsub) {
        // this.matcher.debug('outer', r);
        var str = this.raw;
        // Accumulate parsed instruction nodes
        var n = [];
        // Accumulate plain text characters
        var buf = '';
        // Iterate until we reach the end of this range
        while (r.s < r.e) {
            var c = str[r.s];
            // Look for characters which mark the start of a special section
            switch (c) {
                case "{" /* Chars.LEFT */: {
                    // Push non-empty buffer
                    if (buf) {
                        n.push(textarg(buf, argsub));
                        buf = '';
                    }
                    var hidden = str[r.s + 1] === "-" /* Chars.MINUS */;
                    var k = this.seek(r.s, r.e);
                    if (k === -1) {
                        n.push(textarg(str.substring(r.s, r.e), argsub));
                        r.s = r.e;
                    }
                    else if (hidden) {
                        // Tag is hidden from processor, emit as text
                        n.push(text("{" /* Chars.LEFT */ + str.substring(r.s + 2, k + 1)));
                        // Skip over hidden tag
                        r.s = k;
                    }
                    else {
                        // Process tag interior
                        var child = this.inner({ t: r.t, s: r.s + 1, e: k });
                        if (!child) {
                            // If we're not in the outermost scope, push text
                            if (argsub !== undefined && r.s + 1 !== k) {
                                n.push(textarg(str.substring(r.s + 1, k), argsub));
                            }
                        }
                        else {
                            n.push(child);
                        }
                        // Skip over processed tag
                        r.s = k;
                    }
                    break;
                }
                case "'" /* Chars.APOS */: {
                    if (this.disableEscapes) {
                        buf += c;
                    }
                    else {
                        if (c === str[r.s + 1]) {
                            // Convert double apostrophe to single
                            buf += c;
                            r.s++;
                        }
                        else {
                            // Skip over apostrophe
                            r.s++;
                            // Capture string wrapped in apostrophes
                            var k = str.indexOf(c, r.s);
                            if (k === -1) {
                                k = r.e;
                            }
                            // Since this is escaped text, push text node without substituting '#'
                            buf += str.substring(r.s, k);
                            // Skip over escaped text
                            r.s = k;
                        }
                    }
                    break;
                }
                default:
                    // Append plain character to output buffer
                    buf += c;
                    break;
            }
            r.s++;
        }
        // Push any trailing characters
        if (buf) {
            n.push(textarg(buf, argsub));
        }
        // Flatten blocks
        return flatten(n);
    };
    MessagePatternParser.prototype.inner = function (r) {
        // this.matcher.debug('inner', r);
        var m = this.matcher;
        // Skip any optional leading spaces
        m.spaces(r);
        // See if we have any arguments. we must have at least one or
        // we fail this tag.
        var args = m.arguments(r);
        if (!args) {
            return undefined;
        }
        // Check if we're done..
        if (!m.spaces(r) || m.complete(r)) {
            // We have a simple argument.
            return [1 /* MessageOpType.ARG */, args[0]];
        }
        // See if any of our known formatters are present
        var name = m.formatter(r);
        if (!name) {
            return undefined;
        }
        m.spaces(r);
        // Execute logic to parse instructions by type
        switch (name) {
            case 'plural':
            case 'selectordinal':
                var type = name === 'plural' ? 0 /* PluralNumberType.CARDINAL */ : 1 /* PluralNumberType.ORDINAL */;
                return this.plural(args, type, m, r);
            case 'select':
                return this.select(args, m, r);
            default:
                return this.simple(args, name, m, r);
        }
        // This code should never be reached if the 'name' corresponds
        // to a valid formatter.
        /* istanbul ignore next */
        return NOOP;
    };
    /**
     * Parse a nested tag sequence '{' ... '}'
     */
    MessagePatternParser.prototype.tag = function (m, r, argsub) {
        // m.debug('  tag', r);
        m.spaces(r);
        // Ensure we see a tag start next
        if (m.char(r) !== "{" /* Chars.LEFT */) {
            return undefined;
        }
        var hidden = this.raw[r.s + 1] === "-" /* Chars.MINUS */;
        // Find matching end delimter
        var k = this.seek(r.s, r.e);
        // Note this can never be -1 since to get into
        // this code we must have parsed balanced '{' and '}' above.
        // if (k === -1) {
        //   return undefined;
        // }
        // Parse nested block and skip over it
        var node = hidden
            ? text("{" /* Chars.LEFT */ + this.raw.substring(r.s + 2, k + 1))
            : this.outer({ t: r.t, s: r.s + 1, e: k }, argsub);
        r.s = k + 1;
        return node;
    };
    /**
     * Parse a plural instruction.
     */
    MessagePatternParser.prototype.plural = function (args, type, m, r) {
        // m.debug('plural', r);
        // See if we have an offset argument
        var offset = m.pluralOffset(r);
        m.spaces(r);
        var choices = [];
        do {
            // Parse a plural choice
            var choice = m.pluralChoice(r);
            if (!choice) {
                break;
            }
            // Parse a tag into a block of instructions
            var block = this.tag(m, r, args[0]);
            if (!block) {
                return NOOP;
            }
            // Determine which choice node to construct
            var node = void 0;
            if (choice[0] === '=') {
                var num = choice.substring(1);
                node = [0 /* PluralChoiceType.EXACT */, num, block];
            }
            else {
                // Plural category match
                node = [1 /* PluralChoiceType.CATEGORY */, choice, block];
            }
            // Append and skip spaces
            choices.push(node);
            m.spaces(r);
        } while (!m.complete(r));
        // If we parsed no choices, emit a no-op
        return choices.length ? [2 /* MessageOpType.PLURAL */, args, offset, type, choices] : NOOP;
    };
    /**
     * Parse a select instruction.
     */
    MessagePatternParser.prototype.select = function (args, m, r) {
        var choices = [];
        do {
            // Parse an identifier to be used as the select choice
            var ident = m.identifier(r);
            if (!ident) {
                break;
            }
            // Parse a tag into a block of instructions
            var block = this.tag(m, r, args[0]);
            if (!block) {
                return NOOP;
            }
            // Append and skip to the next choice
            choices.push([ident, block]);
            m.spaces(r);
        } while (!m.complete(r));
        // If we parsed no choices, just emit a no-op
        return choices.length ? [3 /* MessageOpType.SELECT */, args, choices] : NOOP;
    };
    /**
     * Simple single-argument formatter with zero or more options.
     */
    MessagePatternParser.prototype.simple = function (args, name, m, r) {
        var options = m.options(r);
        return [6 /* MessageOpType.SIMPLE */, name, args, options];
    };
    /**
     * Seek to the matching '}' character at the same nesting level,
     * skipping over any apostrophes. This adds some redundant scanning
     * of the string but simplifies some of the parsing logic in other
     * areas. It ensures we're always dealing with a well-formed tag
     * where all '{' have a corresponding '}'.
     */
    MessagePatternParser.prototype.seek = function (i, j) {
        var r = this.raw;
        var d = 0; // Track nesting depth
        loop: while (i < j) {
            var c = r[i];
            switch (c) {
                case "{" /* Chars.LEFT */:
                    // Increase depth
                    d++;
                    break;
                case "}" /* Chars.RIGHT */:
                    // Reduce depth
                    d--;
                    if (!d) {
                        // Depth is zero, we're done
                        break loop;
                    }
                    break;
                case "'" /* Chars.APOS */:
                    if (c === r[i + 1]) {
                        // Skip single escaped apostrophe
                        i++;
                    }
                    else {
                        // Find matching apostrophe
                        var k = r.indexOf(c, i + 1);
                        if (k === -1) {
                            // No apostrophe, assume rest of string is escaped
                            return -1;
                        }
                        // Skip over matching apostrophe
                        i = k;
                    }
                    break;
            }
            i++;
        }
        // If we still have un-matched characters, return -1
        return d ? -1 : i;
    };
    return MessagePatternParser;
}());
var flatten = function (n) {
    return !n.length ? NOOP : n.length === 1 ? n[0] : [4 /* MessageOpType.BLOCK */, n];
};
var text = function (s) { return [0 /* MessageOpType.TEXT */, s]; };
/**
 * Emit a text node, performing argument substitution for all occurrences of
 * the '#' character.
 */
var textarg = function (s, argsub) {
    var i = 0;
    var j = 0;
    // If no argument substitution is requested, return plain text
    if (argsub === undefined) {
        return text(s);
    }
    // If no '#' character is found, return plain text
    j = s.indexOf("#" /* Chars.POUND */);
    if (j === -1) {
        return text(s);
    }
    // Here 'j' points to position of '#'
    // We need to perform substitution on each occurrence of '#' in the
    // string and return a block.
    var len = s.length;
    var n = [];
    // Loop, substituing an arg node for each occurrence of '#'
    while (j !== -1) {
        // Push leading text
        if (i < j) {
            n.push(text(s.substring(i, j)));
        }
        // Add a substitution op
        n.push([7 /* MessageOpType.ARGSUB */]);
        // Skip over '#' and search for next occurrence
        i = j + 1;
        j = s.indexOf("#" /* Chars.POUND */, i);
    }
    // Push trailing text
    if (i < len) {
        n.push(text(s.substring(i)));
    }
    return flatten(n);
};
var NOOP = [5 /* MessageOpType.NOOP */];
//# sourceMappingURL=parser.js.map