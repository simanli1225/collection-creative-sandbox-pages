{"version":3,"file":"matcher.js","sourceRoot":"","sources":["../../src/parser/matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A string and range of characters [s, e) (from 's' up to but not including 'e'),\n * representing the current state of the parse of a given scope inside a\n * message string.\n *\n * @public\n */\nexport interface MessageState {\n  t: string;\n  s: number;\n  e: number;\n}\n\nconst patterns = {\n  /* eslint-disable max-len */\n  identifier:\n    /[^\\u0009-\\u000d \\u0085\\u200e\\u200f\\u2028\\u2029\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u005e\\u0060\\u007b-\\u007e\\u00a1-\\u00a7\\u00a9\\u00ab\\u00ac\\u00ae\\u00b0\\u00b1\\u00b6\\u00bb\\u00bf\\u00d7\\u00f7\\u2010-\\u2027\\u2030-\\u203e\\u2041-\\u2053\\u2055-\\u205e\\u2190-\\u245f\\u2500-\\u2775\\u2794-\\u2bff\\u2e00-\\u2e7f\\u3001-\\u3003\\u3008-\\u3020\\u3030\\ufd3e\\ufd3f\\ufe45\\ufe46]+/\n      .source,\n  /* eslint-enable max-len */\n\n  option: /[^\\s,\\{\\}]+/.source,\n\n  // explicit or plural category\n  pluralChoice: /(=\\d+(\\.\\d+)?)|zero|one|two|few|many|other/.source,\n};\n\n/**\n * Matches message syntax fragments.\n *\n * @public\n */\nexport interface MessageMatcher {\n  // debug(msg: string, r: MessageState): void;\n\n  /**\n   * Return the next character.\n   */\n  char(r: MessageState): string;\n\n  /**\n   * Indicate if we've reached the end of input.\n   */\n  complete(r: MessageState): boolean;\n\n  /**\n   * Match one or more spaces.\n   */\n  spaces(r: MessageState): boolean;\n\n  /**\n   * Match a list of arguments.\n   */\n  arguments(r: MessageState): (number | string)[] | undefined;\n\n  /**\n   * Match variable identifier.\n   */\n  identifier(r: MessageState): string | undefined;\n\n  /**\n   * Match a list of options.\n   */\n  options(r: MessageState): string[];\n\n  /**\n   * Match a formatter name.\n   */\n  formatter(r: MessageState): string | undefined;\n\n  /**\n   * Match a plural offset.\n   */\n  pluralOffset(r: MessageState): number;\n\n  /**\n   * Match a plural choice (exact or category).\n   */\n  pluralChoice(r: MessageState): string | undefined;\n}\n\n// This library supports these operations by default.\nconst BUILTINS = ['plural', 'select', 'selectordinal'];\n\nconst cmp = (a: number, b: number) => (a < b ? -1 : a > b ? 1 : 0);\n\n/**\n * Matches against a substring defined by the [start, end) range\n * argument. When a match occurs it updates the range's start pointer. This\n * allows a single matcher instance to be used to match positions recursively.\n *\n * For example, while the outer block is being parsed at [0, 74] the inner\n * block at [24, 73] can be recursively parsed using the same matcher, with\n * the corresponding parse positions maintained in a range object within each\n * stack frame.\n *\n * ```\n *   \"{gender, select, female {guests plural one {her guest} other {her guests}}\"\n * ```\n * @public\n */\nexport class StickyMatcher implements MessageMatcher {\n  private _space: RegExp;\n  private _arg: RegExp;\n  private _ident: RegExp;\n  private _option: RegExp;\n  private _fmt: RegExp;\n  private _offset: RegExp;\n  private _choice: RegExp;\n\n  constructor(formatters: string[], compile: regexpFunc) {\n    this._space = compile('[,\\\\s]+');\n    this._arg = compile(`(0[1..9]+|\\\\d+|${patterns.identifier})`);\n    this._ident = compile(patterns.identifier);\n    this._option = compile(patterns.option);\n    // Sort keys by length descending to ensure prefixes are matched last\n    formatters = BUILTINS.concat(formatters).sort((a, b) => cmp(b.length, a.length));\n    this._fmt = compile(`(${formatters.join('|')})`);\n    this._offset = compile(/offset:-?\\d+/.source);\n    this._choice = compile(patterns.pluralChoice);\n  }\n\n  // Debug helper during development.\n  // debug(msg: string, r: MessageState): void {\n  //   const pos = [r.s, r.e].map(n => n.toString().padStart(4));\n  //   const sub = JSON.stringify(r.t.substring(r.s, r.e));\n  //   console.log(`${msg} [${pos[0]}, ${pos[1]}] => ${sub}`);\n  // }\n\n  char(r: MessageState): string {\n    return r.t[r.s];\n  }\n\n  complete(r: MessageState): boolean {\n    return r.e === r.s;\n  }\n\n  spaces(r: MessageState): boolean {\n    return this.match(this._space, r) !== undefined;\n  }\n\n  arguments(r: MessageState): (number | string)[] | undefined {\n    let args: (number | string)[] | undefined;\n    do {\n      const arg = this.match(this._arg, r);\n      if (!arg) {\n        break;\n      }\n\n      const n = parseInt(arg, 10);\n      if (!args) {\n        args = [];\n      }\n      args.push(Number.isFinite(n) ? n : arg);\n\n      // Tuple arguments are separated by a single semicolon\n      if (r.t[r.s] !== ';') {\n        break;\n      }\n      r.s++;\n    } while (!this.complete(r));\n    return args;\n  }\n\n  identifier(r: MessageState): string | undefined {\n    return this.match(this._ident, r);\n  }\n\n  options(r: MessageState): string[] {\n    const options: string[] = [];\n    do {\n      this.spaces(r);\n      const opt = this.match(this._option, r);\n      if (!opt) {\n        break;\n      }\n      options.push(opt);\n    } while (!this.complete(r));\n    return options;\n  }\n\n  formatter(r: MessageState): string | undefined {\n    return this.match(this._fmt, r);\n  }\n\n  pluralChoice(r: MessageState): string | undefined {\n    return this.match(this._choice, r);\n  }\n\n  pluralOffset(r: MessageState): number {\n    let n = 0;\n    const m = this.match(this._offset, r);\n    if (m) {\n      // This must parse successfully since it is constrained by the regexp match\n      n = parseInt(m.split(':')[1], 10);\n    }\n    return n;\n  }\n\n  /**\n   * Attempt to match the pattern at the given starting location. If a\n   * match is found, move the start pointer and return the string.\n   * Otherwise return undefined.\n   */\n  match(pattern: RegExp, r: MessageState): string | undefined {\n    pattern.lastIndex = r.s;\n    const raw = pattern.exec(r.t);\n    if (raw) {\n      // set the start of range to the sticky index\n      r.s = pattern.lastIndex;\n      return raw[0];\n    }\n    return undefined;\n  }\n}\n\n/**\n * Implementation of matcher for browsers that do not support sticky regexps.\n * We anchor all patterns to the start of the string, then match against\n * a substring [start, end].\n *\n * @public\n */\nexport class SubstringMatcher extends StickyMatcher {\n  match(pattern: RegExp, r: MessageState): string | undefined {\n    pattern.lastIndex = 0;\n    const s = r.t.substring(r.s, r.e);\n    const raw = pattern.exec(s);\n    if (raw) {\n      // skip ahead by the number of characters matched\n      r.s += pattern.lastIndex;\n      return raw[0];\n    }\n    return undefined;\n  }\n}\n\n/**\n * Check if the current JS runtime supports sticky RegExp flag.\n */\nconst hasStickyRegexp = (() => {\n  try {\n    const r = new RegExp('.', 'y');\n    return r && true;\n  } catch (e) {\n    /* istanbul ignore next */\n    return false;\n  }\n})();\n\n/**\n * Function that compiles a regular expression.\n *\n * @public\n */\nexport type regexpFunc = (pattern: string) => RegExp;\n\n/**\n * Construct a regular expression for use in a StickyMatcher.\n *\n * @public\n */\nexport const stickyRegexp = (pattern: string): RegExp => new RegExp(pattern, 'y');\n\n/**\n * Construct a regular expression for use in a SubstringMatcher.\n *\n * @public\n */\nexport const substringRegexp = (pattern: string): RegExp => new RegExp('^' + pattern, 'g');\n\n/**\n * Constructs the right instance of matcher based on the runtime environment's\n * support of sticky regexp, while allowing substring matcher to be selected for\n * testing.\n *\n * @public\n */\nexport const buildMessageMatcher = (names: string[], sticky: boolean = hasStickyRegexp): MessageMatcher =>\n  new (sticky ? StickyMatcher : SubstringMatcher)(names, sticky ? stickyRegexp : substringRegexp);\n"]}