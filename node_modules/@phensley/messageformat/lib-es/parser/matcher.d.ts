/**
 * A string and range of characters [s, e) (from 's' up to but not including 'e'),
 * representing the current state of the parse of a given scope inside a
 * message string.
 *
 * @public
 */
export interface MessageState {
    t: string;
    s: number;
    e: number;
}
/**
 * Matches message syntax fragments.
 *
 * @public
 */
export interface MessageMatcher {
    /**
     * Return the next character.
     */
    char(r: MessageState): string;
    /**
     * Indicate if we've reached the end of input.
     */
    complete(r: MessageState): boolean;
    /**
     * Match one or more spaces.
     */
    spaces(r: MessageState): boolean;
    /**
     * Match a list of arguments.
     */
    arguments(r: MessageState): (number | string)[] | undefined;
    /**
     * Match variable identifier.
     */
    identifier(r: MessageState): string | undefined;
    /**
     * Match a list of options.
     */
    options(r: MessageState): string[];
    /**
     * Match a formatter name.
     */
    formatter(r: MessageState): string | undefined;
    /**
     * Match a plural offset.
     */
    pluralOffset(r: MessageState): number;
    /**
     * Match a plural choice (exact or category).
     */
    pluralChoice(r: MessageState): string | undefined;
}
/**
 * Matches against a substring defined by the [start, end) range
 * argument. When a match occurs it updates the range's start pointer. This
 * allows a single matcher instance to be used to match positions recursively.
 *
 * For example, while the outer block is being parsed at [0, 74] the inner
 * block at [24, 73] can be recursively parsed using the same matcher, with
 * the corresponding parse positions maintained in a range object within each
 * stack frame.
 *
 * ```
 *   "{gender, select, female {guests plural one {her guest} other {her guests}}"
 * ```
 * @public
 */
export declare class StickyMatcher implements MessageMatcher {
    private _space;
    private _arg;
    private _ident;
    private _option;
    private _fmt;
    private _offset;
    private _choice;
    constructor(formatters: string[], compile: regexpFunc);
    char(r: MessageState): string;
    complete(r: MessageState): boolean;
    spaces(r: MessageState): boolean;
    arguments(r: MessageState): (number | string)[] | undefined;
    identifier(r: MessageState): string | undefined;
    options(r: MessageState): string[];
    formatter(r: MessageState): string | undefined;
    pluralChoice(r: MessageState): string | undefined;
    pluralOffset(r: MessageState): number;
    /**
     * Attempt to match the pattern at the given starting location. If a
     * match is found, move the start pointer and return the string.
     * Otherwise return undefined.
     */
    match(pattern: RegExp, r: MessageState): string | undefined;
}
/**
 * Implementation of matcher for browsers that do not support sticky regexps.
 * We anchor all patterns to the start of the string, then match against
 * a substring [start, end].
 *
 * @public
 */
export declare class SubstringMatcher extends StickyMatcher {
    match(pattern: RegExp, r: MessageState): string | undefined;
}
/**
 * Function that compiles a regular expression.
 *
 * @public
 */
export type regexpFunc = (pattern: string) => RegExp;
/**
 * Construct a regular expression for use in a StickyMatcher.
 *
 * @public
 */
export declare const stickyRegexp: (pattern: string) => RegExp;
/**
 * Construct a regular expression for use in a SubstringMatcher.
 *
 * @public
 */
export declare const substringRegexp: (pattern: string) => RegExp;
/**
 * Constructs the right instance of matcher based on the runtime environment's
 * support of sticky regexp, while allowing substring matcher to be selected for
 * testing.
 *
 * @public
 */
export declare const buildMessageMatcher: (names: string[], sticky?: boolean) => MessageMatcher;
