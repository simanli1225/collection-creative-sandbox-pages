{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Argument,\n  MessageCode,\n  MessageOpType,\n  PluralChoice,\n  PluralChoiceType,\n  PluralNumberType,\n  SelectChoice,\n} from './types';\n\nimport { MessageMatcher, MessageState } from './matcher';\n\nconst enum Chars {\n  LEFT = '{',\n  RIGHT = '}',\n  MINUS = '-',\n  APOS = \"'\",\n  POUND = '#',\n}\n\n/**\n * Parses a string into message code. The result can be used to evaluate the\n * message or serialized to JSON for later evaluation.\n *\n * @public\n */\nexport const parseMessagePattern = (raw: string, matcher: MessageMatcher, disableEscapes?: boolean): MessageCode =>\n  new MessagePatternParser(raw, matcher, disableEscapes).parse();\n\n/**\n * Hand-implemented parser for ICU message format. Designed to be compact and\n * fast vs. other implementations.\n * The parser produces an instruction tree which can be cached for repeated\n * use, and is intended to be evaluated by a separate engine.\n *\n * Note: The 'choice' formatter is not implemented since it is deprecated.\n *\n * See ICU docs for details on syntax:\n * https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/MessageFormat.html\n *\n * Rationale\n *\n * The decision to hand-implement the parser was for 2 reasons:\n * 1. Avoiding extra runtime dependencies (parser generators, e.g. pegjs, etc)\n * 2. Provide control over the memory allocation, garbage generation, and other\n *    aspects that impact parser performance.\n *\n * A major consideration is size of the resulting parser code. The OpenJS project\n * 'messageformat-parser' which is generated by Peg.js is 30kB minified. It also\n * requires other dependencies for the plural calculations, where this is already\n * supported in our library via @phensley/plurals\n *\n * See:\n *   https://unpkg.com/messageformat-parser/parser.js\n */\nclass MessagePatternParser {\n  constructor(\n    private raw: string,\n    private matcher: MessageMatcher,\n    private disableEscapes?: boolean,\n  ) {}\n\n  parse(): MessageCode {\n    const t = this.raw;\n    return this.outer({ t, s: 0, e: t.length });\n  }\n\n  outer(r: MessageState, argsub?: Argument): MessageCode {\n    // this.matcher.debug('outer', r);\n\n    const str = this.raw;\n\n    // Accumulate parsed instruction nodes\n    const n: MessageCode[] = [];\n\n    // Accumulate plain text characters\n    let buf = '';\n\n    // Iterate until we reach the end of this range\n    while (r.s < r.e) {\n      const c = str[r.s];\n\n      // Look for characters which mark the start of a special section\n      switch (c) {\n        case Chars.LEFT: {\n          // Push non-empty buffer\n          if (buf) {\n            n.push(textarg(buf, argsub));\n            buf = '';\n          }\n          const hidden = str[r.s + 1] === Chars.MINUS;\n\n          const k = this.seek(r.s, r.e);\n          if (k === -1) {\n            n.push(textarg(str.substring(r.s, r.e), argsub));\n            r.s = r.e;\n          } else if (hidden) {\n            // Tag is hidden from processor, emit as text\n            n.push(text(Chars.LEFT + str.substring(r.s + 2, k + 1)));\n\n            // Skip over hidden tag\n            r.s = k;\n          } else {\n            // Process tag interior\n            const child = this.inner({ t: r.t, s: r.s + 1, e: k });\n            if (!child) {\n              // If we're not in the outermost scope, push text\n              if (argsub !== undefined && r.s + 1 !== k) {\n                n.push(textarg(str.substring(r.s + 1, k), argsub));\n              }\n            } else {\n              n.push(child);\n            }\n\n            // Skip over processed tag\n            r.s = k;\n          }\n          break;\n        }\n\n        case Chars.APOS: {\n          if (this.disableEscapes) {\n            buf += c;\n          } else {\n            if (c === str[r.s + 1]) {\n              // Convert double apostrophe to single\n              buf += c;\n              r.s++;\n            } else {\n              // Skip over apostrophe\n              r.s++;\n\n              // Capture string wrapped in apostrophes\n              let k = str.indexOf(c, r.s);\n              if (k === -1) {\n                k = r.e;\n              }\n\n              // Since this is escaped text, push text node without substituting '#'\n              buf += str.substring(r.s, k);\n\n              // Skip over escaped text\n              r.s = k;\n            }\n          }\n          break;\n        }\n\n        default:\n          // Append plain character to output buffer\n          buf += c;\n          break;\n      }\n      r.s++;\n    }\n\n    // Push any trailing characters\n    if (buf) {\n      n.push(textarg(buf, argsub));\n    }\n\n    // Flatten blocks\n    return flatten(n);\n  }\n\n  inner(r: MessageState): MessageCode | undefined {\n    // this.matcher.debug('inner', r);\n\n    const m = this.matcher;\n\n    // Skip any optional leading spaces\n    m.spaces(r);\n\n    // See if we have any arguments. we must have at least one or\n    // we fail this tag.\n    const args = m.arguments(r);\n    if (!args) {\n      return undefined;\n    }\n\n    // Check if we're done..\n    if (!m.spaces(r) || m.complete(r)) {\n      // We have a simple argument.\n      return [MessageOpType.ARG, args[0]];\n    }\n\n    // See if any of our known formatters are present\n    const name = m.formatter(r);\n    if (!name) {\n      return undefined;\n    }\n    m.spaces(r);\n\n    // Execute logic to parse instructions by type\n    switch (name) {\n      case 'plural':\n      case 'selectordinal':\n        const type = name === 'plural' ? PluralNumberType.CARDINAL : PluralNumberType.ORDINAL;\n        return this.plural(args, type, m, r);\n\n      case 'select':\n        return this.select(args, m, r);\n\n      default:\n        return this.simple(args, name, m, r);\n    }\n\n    // This code should never be reached if the 'name' corresponds\n    // to a valid formatter.\n    /* istanbul ignore next */\n    return NOOP;\n  }\n\n  /**\n   * Parse a nested tag sequence '{' ... '}'\n   */\n  tag(m: MessageMatcher, r: MessageState, argsub?: Argument): MessageCode | undefined {\n    // m.debug('  tag', r);\n    m.spaces(r);\n\n    // Ensure we see a tag start next\n    if (m.char(r) !== Chars.LEFT) {\n      return undefined;\n    }\n\n    const hidden = this.raw[r.s + 1] === Chars.MINUS;\n\n    // Find matching end delimter\n    const k = this.seek(r.s, r.e);\n\n    // Note this can never be -1 since to get into\n    // this code we must have parsed balanced '{' and '}' above.\n    // if (k === -1) {\n    //   return undefined;\n    // }\n\n    // Parse nested block and skip over it\n    const node = hidden\n      ? text(Chars.LEFT + this.raw.substring(r.s + 2, k + 1))\n      : this.outer({ t: r.t, s: r.s + 1, e: k }, argsub);\n    r.s = k + 1;\n    return node;\n  }\n\n  /**\n   * Parse a plural instruction.\n   */\n  plural(args: Argument[], type: PluralNumberType, m: MessageMatcher, r: MessageState): MessageCode {\n    // m.debug('plural', r);\n\n    // See if we have an offset argument\n    const offset = m.pluralOffset(r);\n    m.spaces(r);\n\n    const choices: PluralChoice[] = [];\n    do {\n      // Parse a plural choice\n      const choice = m.pluralChoice(r);\n      if (!choice) {\n        break;\n      }\n\n      // Parse a tag into a block of instructions\n      const block = this.tag(m, r, args[0]);\n      if (!block) {\n        return NOOP;\n      }\n\n      // Determine which choice node to construct\n      let node: PluralChoice;\n      if (choice[0] === '=') {\n        const num = choice.substring(1);\n        node = [PluralChoiceType.EXACT, num, block];\n      } else {\n        // Plural category match\n        node = [PluralChoiceType.CATEGORY, choice, block];\n      }\n\n      // Append and skip spaces\n      choices.push(node);\n      m.spaces(r);\n    } while (!m.complete(r));\n\n    // If we parsed no choices, emit a no-op\n    return choices.length ? [MessageOpType.PLURAL, args, offset, type, choices] : NOOP;\n  }\n\n  /**\n   * Parse a select instruction.\n   */\n  select(args: Argument[], m: MessageMatcher, r: MessageState): MessageCode {\n    const choices: SelectChoice[] = [];\n    do {\n      // Parse an identifier to be used as the select choice\n      const ident = m.identifier(r);\n      if (!ident) {\n        break;\n      }\n\n      // Parse a tag into a block of instructions\n      const block = this.tag(m, r, args[0]);\n      if (!block) {\n        return NOOP;\n      }\n\n      // Append and skip to the next choice\n      choices.push([ident, block]);\n      m.spaces(r);\n    } while (!m.complete(r));\n\n    // If we parsed no choices, just emit a no-op\n    return choices.length ? [MessageOpType.SELECT, args, choices] : NOOP;\n  }\n\n  /**\n   * Simple single-argument formatter with zero or more options.\n   */\n  simple(args: Argument[], name: string, m: MessageMatcher, r: MessageState): MessageCode {\n    const options = m.options(r);\n    return [MessageOpType.SIMPLE, name, args, options];\n  }\n\n  /**\n   * Seek to the matching '}' character at the same nesting level,\n   * skipping over any apostrophes. This adds some redundant scanning\n   * of the string but simplifies some of the parsing logic in other\n   * areas. It ensures we're always dealing with a well-formed tag\n   * where all '{' have a corresponding '}'.\n   */\n  seek(i: number, j: number): number {\n    const r = this.raw;\n    let d = 0; // Track nesting depth\n\n    loop: while (i < j) {\n      const c = r[i];\n      switch (c) {\n        case Chars.LEFT:\n          // Increase depth\n          d++;\n          break;\n\n        case Chars.RIGHT:\n          // Reduce depth\n          d--;\n          if (!d) {\n            // Depth is zero, we're done\n            break loop;\n          }\n          break;\n\n        case Chars.APOS:\n          if (c === r[i + 1]) {\n            // Skip single escaped apostrophe\n            i++;\n          } else {\n            // Find matching apostrophe\n            const k = r.indexOf(c, i + 1);\n            if (k === -1) {\n              // No apostrophe, assume rest of string is escaped\n              return -1;\n            }\n            // Skip over matching apostrophe\n            i = k;\n          }\n          break;\n      }\n\n      i++;\n    }\n\n    // If we still have un-matched characters, return -1\n    return d ? -1 : i;\n  }\n}\n\nconst flatten = (n: MessageCode[]): MessageCode =>\n  !n.length ? NOOP : n.length === 1 ? n[0] : [MessageOpType.BLOCK, n];\n\nconst text = (s: string): MessageCode => [MessageOpType.TEXT, s];\n\n/**\n * Emit a text node, performing argument substitution for all occurrences of\n * the '#' character.\n */\nconst textarg = (s: string, argsub?: Argument): MessageCode => {\n  let i = 0;\n  let j = 0;\n\n  // If no argument substitution is requested, return plain text\n  if (argsub === undefined) {\n    return text(s);\n  }\n\n  // If no '#' character is found, return plain text\n  j = s.indexOf(Chars.POUND);\n  if (j === -1) {\n    return text(s);\n  }\n\n  // Here 'j' points to position of '#'\n\n  // We need to perform substitution on each occurrence of '#' in the\n  // string and return a block.\n  const len = s.length;\n  const n: MessageCode[] = [];\n\n  // Loop, substituing an arg node for each occurrence of '#'\n  while (j !== -1) {\n    // Push leading text\n    if (i < j) {\n      n.push(text(s.substring(i, j)));\n    }\n\n    // Add a substitution op\n    n.push([MessageOpType.ARGSUB]);\n\n    // Skip over '#' and search for next occurrence\n    i = j + 1;\n    j = s.indexOf(Chars.POUND, i);\n  }\n\n  // Push trailing text\n  if (i < len) {\n    n.push(text(s.substring(i)));\n  }\n\n  return flatten(n);\n};\n\nconst NOOP: MessageCode = [MessageOpType.NOOP];\n"]}