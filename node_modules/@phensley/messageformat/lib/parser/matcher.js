"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildMessageMatcher = exports.substringRegexp = exports.stickyRegexp = exports.SubstringMatcher = exports.StickyMatcher = void 0;
var tslib_1 = require("tslib");
var patterns = {
    /* eslint-disable max-len */
    identifier: /[^\u0009-\u000d \u0085\u200e\u200f\u2028\u2029\u0021-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u007e\u00a1-\u00a7\u00a9\u00ab\u00ac\u00ae\u00b0\u00b1\u00b6\u00bb\u00bf\u00d7\u00f7\u2010-\u2027\u2030-\u203e\u2041-\u2053\u2055-\u205e\u2190-\u245f\u2500-\u2775\u2794-\u2bff\u2e00-\u2e7f\u3001-\u3003\u3008-\u3020\u3030\ufd3e\ufd3f\ufe45\ufe46]+/
        .source,
    /* eslint-enable max-len */
    option: /[^\s,\{\}]+/.source,
    // explicit or plural category
    pluralChoice: /(=\d+(\.\d+)?)|zero|one|two|few|many|other/.source,
};
// This library supports these operations by default.
var BUILTINS = ['plural', 'select', 'selectordinal'];
var cmp = function (a, b) { return (a < b ? -1 : a > b ? 1 : 0); };
/**
 * Matches against a substring defined by the [start, end) range
 * argument. When a match occurs it updates the range's start pointer. This
 * allows a single matcher instance to be used to match positions recursively.
 *
 * For example, while the outer block is being parsed at [0, 74] the inner
 * block at [24, 73] can be recursively parsed using the same matcher, with
 * the corresponding parse positions maintained in a range object within each
 * stack frame.
 *
 * ```
 *   "{gender, select, female {guests plural one {her guest} other {her guests}}"
 * ```
 * @public
 */
var StickyMatcher = /** @class */ (function () {
    function StickyMatcher(formatters, compile) {
        this._space = compile('[,\\s]+');
        this._arg = compile("(0[1..9]+|\\d+|".concat(patterns.identifier, ")"));
        this._ident = compile(patterns.identifier);
        this._option = compile(patterns.option);
        // Sort keys by length descending to ensure prefixes are matched last
        formatters = BUILTINS.concat(formatters).sort(function (a, b) { return cmp(b.length, a.length); });
        this._fmt = compile("(".concat(formatters.join('|'), ")"));
        this._offset = compile(/offset:-?\d+/.source);
        this._choice = compile(patterns.pluralChoice);
    }
    // Debug helper during development.
    // debug(msg: string, r: MessageState): void {
    //   const pos = [r.s, r.e].map(n => n.toString().padStart(4));
    //   const sub = JSON.stringify(r.t.substring(r.s, r.e));
    //   console.log(`${msg} [${pos[0]}, ${pos[1]}] => ${sub}`);
    // }
    StickyMatcher.prototype.char = function (r) {
        return r.t[r.s];
    };
    StickyMatcher.prototype.complete = function (r) {
        return r.e === r.s;
    };
    StickyMatcher.prototype.spaces = function (r) {
        return this.match(this._space, r) !== undefined;
    };
    StickyMatcher.prototype.arguments = function (r) {
        var args;
        do {
            var arg = this.match(this._arg, r);
            if (!arg) {
                break;
            }
            var n = parseInt(arg, 10);
            if (!args) {
                args = [];
            }
            args.push(Number.isFinite(n) ? n : arg);
            // Tuple arguments are separated by a single semicolon
            if (r.t[r.s] !== ';') {
                break;
            }
            r.s++;
        } while (!this.complete(r));
        return args;
    };
    StickyMatcher.prototype.identifier = function (r) {
        return this.match(this._ident, r);
    };
    StickyMatcher.prototype.options = function (r) {
        var options = [];
        do {
            this.spaces(r);
            var opt = this.match(this._option, r);
            if (!opt) {
                break;
            }
            options.push(opt);
        } while (!this.complete(r));
        return options;
    };
    StickyMatcher.prototype.formatter = function (r) {
        return this.match(this._fmt, r);
    };
    StickyMatcher.prototype.pluralChoice = function (r) {
        return this.match(this._choice, r);
    };
    StickyMatcher.prototype.pluralOffset = function (r) {
        var n = 0;
        var m = this.match(this._offset, r);
        if (m) {
            // This must parse successfully since it is constrained by the regexp match
            n = parseInt(m.split(':')[1], 10);
        }
        return n;
    };
    /**
     * Attempt to match the pattern at the given starting location. If a
     * match is found, move the start pointer and return the string.
     * Otherwise return undefined.
     */
    StickyMatcher.prototype.match = function (pattern, r) {
        pattern.lastIndex = r.s;
        var raw = pattern.exec(r.t);
        if (raw) {
            // set the start of range to the sticky index
            r.s = pattern.lastIndex;
            return raw[0];
        }
        return undefined;
    };
    return StickyMatcher;
}());
exports.StickyMatcher = StickyMatcher;
/**
 * Implementation of matcher for browsers that do not support sticky regexps.
 * We anchor all patterns to the start of the string, then match against
 * a substring [start, end].
 *
 * @public
 */
var SubstringMatcher = /** @class */ (function (_super) {
    tslib_1.__extends(SubstringMatcher, _super);
    function SubstringMatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SubstringMatcher.prototype.match = function (pattern, r) {
        pattern.lastIndex = 0;
        var s = r.t.substring(r.s, r.e);
        var raw = pattern.exec(s);
        if (raw) {
            // skip ahead by the number of characters matched
            r.s += pattern.lastIndex;
            return raw[0];
        }
        return undefined;
    };
    return SubstringMatcher;
}(StickyMatcher));
exports.SubstringMatcher = SubstringMatcher;
/**
 * Check if the current JS runtime supports sticky RegExp flag.
 */
var hasStickyRegexp = (function () {
    try {
        var r = new RegExp('.', 'y');
        return r && true;
    }
    catch (e) {
        /* istanbul ignore next */
        return false;
    }
})();
/**
 * Construct a regular expression for use in a StickyMatcher.
 *
 * @public
 */
var stickyRegexp = function (pattern) { return new RegExp(pattern, 'y'); };
exports.stickyRegexp = stickyRegexp;
/**
 * Construct a regular expression for use in a SubstringMatcher.
 *
 * @public
 */
var substringRegexp = function (pattern) { return new RegExp('^' + pattern, 'g'); };
exports.substringRegexp = substringRegexp;
/**
 * Constructs the right instance of matcher based on the runtime environment's
 * support of sticky regexp, while allowing substring matcher to be selected for
 * testing.
 *
 * @public
 */
var buildMessageMatcher = function (names, sticky) {
    if (sticky === void 0) { sticky = hasStickyRegexp; }
    return new (sticky ? StickyMatcher : SubstringMatcher)(names, sticky ? exports.stickyRegexp : exports.substringRegexp);
};
exports.buildMessageMatcher = buildMessageMatcher;
//# sourceMappingURL=matcher.js.map