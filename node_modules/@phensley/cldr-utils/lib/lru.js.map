{"version":3,"file":"lru.js","sourceRoot":"","sources":["../src/lru.ts"],"names":[],"mappings":"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","sourcesContent":["const DEFAULT_CAPACITY = 100;\n\n/**\n * Type of the key used in the LRU.\n *\n * @public\n */\nexport type Key = string | number;\n\n// Note next / prev will always be set internally, but are undefined\n// temporarily when inserting a new node into the list.\ntype Node<V> = { key: Key; val: V; next?: Node<V>; prev?: Node<V> };\n\n/**\n * Cache evicts the least-recently-used key when capacity is exceeded.\n *\n * @public\n */\nexport class LRU<V> {\n  private readonly storage: Map<Key, Node<V>> = new Map();\n  private readonly root: Node<V>;\n  private readonly capacity: number;\n\n  constructor(capacity: number = DEFAULT_CAPACITY) {\n    this.capacity = capacity;\n    const root = {} as Node<V>;\n    root.next = root;\n    root.prev = root;\n    this.root = root;\n  }\n\n  /**\n   * Number of items in the LRU.\n   */\n  size(): number {\n    return this.storage.size;\n  }\n\n  /**\n   * Get the value associated with the key and move the\n   * key to the front of the LRU.\n   */\n  get(key: Key): V | undefined {\n    const n = this.storage.get(key);\n    if (!n) {\n      return undefined;\n    }\n    this.moveFront(n);\n    return n.val;\n  }\n\n  /**\n   * Set a value associated with the key. IF it already\n   * exists, the value is updated. Otherwise it is inserted\n   * into the LRU and moved to the front.\n   */\n  set(key: Key, val: V): void {\n    if (this.capacity === 0) {\n      return;\n    }\n\n    let n = this.storage.get(key);\n\n    // Key already exists, so replace its value and bump it\n    // to the front. Size does not change.\n    if (n) {\n      n.val = val;\n      this.moveFront(n);\n      return;\n    }\n\n    // The lru is full, so reuse the oldest node to keep the\n    // total node allocation stable.\n    if (this.storage.size === this.capacity) {\n      const old = this.root.prev!;\n      this.storage.delete(old.key);\n      this.storage.set(key, old);\n      old.key = key;\n      old.val = val;\n      this.moveFront(old);\n      return;\n    }\n\n    // The lru is not full, so allocate a new node.\n    n = { key, val };\n    this.storage.set(key, n);\n    this.insert(n, this.root);\n  }\n\n  /**\n   * Show the contents of the LRU as a string.\n   */\n  toString(): string {\n    let res = '';\n    let n = this.root.next;\n    while (n && n !== this.root) {\n      if (res.length > 0) {\n        res += ' ';\n      }\n      res += `${n.key}=${n.val}`;\n      n = n.next;\n    }\n    return res;\n  }\n\n  private moveFront(n: Node<V>): void {\n    this.insert(this.remove(n), this.root);\n  }\n\n  private insert(e: Node<V>, at: Node<V>): Node<V> {\n    const n = at.next;\n    at.next = e;\n    e.prev = at;\n    e.next = n;\n    n!.prev = e;\n    return e;\n  }\n\n  private remove(n: Node<V>): Node<V> {\n    n.prev!.next = n.next;\n    n.next!.prev = n.prev;\n    n.prev = n.next = undefined;\n    return n;\n  }\n}\n"]}