{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;AAAA,uDAA6C;AAE7C,mDAAoD;AAmHpD,IAAM,QAAQ,GAAG,UAAC,CAAS,IAAK,OAAA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,EAAf,CAAe,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAnD,CAAmD,CAAC;AAEpF;;;;GAIG;AACH;IAsBE,gBAAY,GAAY;QAAxB,iBAsCC;QA3DD,kDAAkD;QAC1C,cAAS,GAAwB,IAAI,GAAG,EAAE,CAAC;QAEnD,2FAA2F;QACnF,cAAS,GAAwB,IAAI,GAAG,EAAE,CAAC;QAcnD,6CAA6C;QACrC,YAAO,GAAa,EAAE,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC;QAGhF,IAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,EAAE,CAAC,CAAqB,EAA1B,CAA0B,CAAC,CAAC;QAEjF,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC;YACjC,IAAA,KAAS,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAApB,CAAC,QAAA,EAAE,CAAC,QAAgB,CAAC;YAC5B,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAqB,CAAC;QAC5C,CAAC,CAAC,CAAC;QAEH,IAAM,OAAO,GAAG,UAAC,GAAW,EAAE,GAAW;YACvC,2DAA2D;YAC3D,IAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;YACnC,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YAC7B,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACpC,CAAC,CAAC;QAEF,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,OAAO,CAAC,OAAO,CAAC,UAAC,CAAC;YAChB,IAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAChB,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACvB,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAE7B,uEAAuE;YACvE,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;QAEH,KAAK,CAAC,OAAO,CAAC,UAAC,CAAC;YACd,IAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACnB,IAAM,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5B,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,CAAC,WAAW,GAAG,GAAG,CAAC,QAAQ,CAAC;QAChC,IAAI,CAAC,WAAW,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAElD,GAAG,CAAC,OAAO,GAAG,EAAE,CAAC;QACjB,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,wBAAO,GAAP,UAAQ,MAAc,EAAE,GAAW;QACjC,IAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACzC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtB,CAAC;IAED;;;OAGG;IACH,yBAAQ,GAAR,UAAS,MAAc,EAAE,IAAY;QACnC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAC1C,CAAC;IAED;;OAEG;IACH,wBAAO,GAAP;QACE,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED;;OAEG;IACH,0BAAS,GAAT,UAAU,EAAU;QAClB,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,yBAAQ,GAAR,UAAS,EAAU;QACjB,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAC5B,IAAI,GAAG,EAAE,CAAC;YACR,OAAO;gBACL,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;gBACd,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM;gBACxB,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ;gBACzB,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS;gBAC3B,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS;aAC5B,CAAC;QACJ,CAAC;QACD,OAAO;IACT,CAAC;IAED;;OAEG;IACH,wBAAO,GAAP;QACE,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;OAEG;IACK,uBAAM,GAAd,UAAe,EAAU,EAAE,CAAS,EAAE,KAAc;QAClD,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAC5B,IAAI,GAAG,EAAE,CAAC;YACD,IAAA,MAAM,GAAO,GAAG,GAAV,EAAE,CAAC,GAAI,GAAG,GAAP,CAAQ;YAClB,IAAA,KAAa,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAhD,GAAG,QAAA,EAAE,GAAG,QAAwC,CAAC;YACxD,OAAO;gBACL,GAAG;sDAEE,GAAG,KACN,MAAM,QAAA;aAET,CAAC;QACJ,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;OAEG;IACK,uBAAM,GAAd,UAAe,MAAc;QAC3B,IAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACtC,qEAAqE;QACrE,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YACrB,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,+CAA+C;QAC/C,IAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAE,CAAC;QAElC,yCAAyC;QACzC,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAC9B,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;YACtB,iEAAiE;YACjE,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAChC,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YAC3C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;YAC1B,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;QAC3B,CAAC;QAED,gDAAgD;QAChD,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;IACnB,CAAC;IACH,aAAC;AAAD,CAAC,AAnKD,IAmKC;AAnKY,wBAAM;AAqKnB;;;;GAIG;AACH;IAYE,oBAAY,GAAW,EAAE,KAAe;QAChC,IAAA,KAAyD,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAtE,IAAI,QAAA,EAAE,IAAI,QAAA,EAAE,IAAI,QAAA,EAAE,UAAU,QAAA,EAAE,KAAK,QAAA,EAAE,MAAM,QAAA,EAAE,OAAO,QAAkB,CAAC;QAC9E,IAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;QACjC,IAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,KAAK,CAAC,CAAC,CAAC,EAAR,CAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAElE,sCAAsC;QACtC,IAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;QAC1B,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC;YACZ,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7B,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACtD,CAAC;QACH,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC;QACxC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC;QACzC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC;QAC1C,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACzD,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACvD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,4BAAO,GAAP,UAAQ,GAAW;QACjB,IAAM,CAAC,GAAG,IAAA,yBAAY,EAAC,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;QAC/C,IAAM,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1C,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IACrC,CAAC;IAED;;;;;;;OAOG;IACH,6BAAQ,GAAR,UAAS,IAAY;QACnB,8CAA8C;QAC9C,IAAI,CAAC,GAAG,IAAA,yBAAY,EAAC,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,CAAC;QACzD,IAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACxD,CAAC,EAAE,CAAC;QAEJ,yDAAyD;QACzD,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;YAC5B,OAAO,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAChC,CAAC;QAED,sBAAsB;QACtB,IAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,IAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAE1B,4FAA4F;QAC5F,EAAE;QACF,wEAAwE;QACxE,iDAAiD;QACjD,EAAE;QACF,+CAA+C;QAC/C,gFAAgF;QAChF,EAAE;QACF,wEAAwE;QACxE,iDAAiD;QACjD,EAAE;QACF,+CAA+C;QAC/C,gFAAgF;QAEhF,6CAA6C;QAC7C,IAAM,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC;QAE1B,0CAA0C;QAC1C,IAAM,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC;QAE1B,0DAA0D;QAC1D,IAAI,IAAI,GAAG,EAAE,IAAI,IAAI,GAAG,EAAE,EAAE,CAAC;YAC3B,OAAO,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAChC,CAAC;QAED,8EAA8E;QAC9E,wEAAwE;QACxE,8EAA8E;QAC9E,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC;YACZ,uEAAuE;YACvE,OAAO,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QACrE,CAAC;QAED,2DAA2D;QAC3D,wEAAwE;QACxE,uEAAuE;QACvE,yBAAyB;QACzB,OAAO,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;IACrE,CAAC;IAED;;OAEG;IACK,+BAAU,GAAlB,UAAmB,GAAW;QACtB,IAAA,KAAwB,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAArC,IAAI,QAAA,EAAE,IAAI,QAAA,EAAE,OAAO,QAAkB,CAAC;QAC7C,OAAO;YACL,IAAI,MAAA;YACJ,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC;YACjB,MAAM,EAAE,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,GAAG,IAAI;SACrC,CAAC;IACJ,CAAC;IACH,iBAAC;AAAD,CAAC,AAvHD,IAuHC;AAED,IAAM,KAAK,GAAG,sCAAsC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,MAAM,CACnE,UAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IACN,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACT,OAAO,CAAC,CAAC;AACX,CAAC,EACD,EAA6B,CAC9B,CAAC;AAQF;;;;GAIG;AACU,QAAA,EAAE,GAAO,IAAI,MAAM,CAAC,0BAAO,CAAC,CAAC","sourcesContent":["import { rawdata } from './autogen.zonedata';\nimport { RawData } from './types';\nimport { binarySearch } from '@phensley/cldr-utils';\n\nexport { RawData } from './types';\n\n/**\n * Represents abbreviation, daylight savings and timezone offset for\n * a single time zone.\n *\n * @public\n */\nexport interface ZoneInfo {\n  /**\n   * Time zone identifier.\n   */\n  zoneid: string;\n\n  /**\n   * Time zone 3-character abbreviation.\n   */\n  abbr: string;\n\n  /**\n   * Flag indicating the zone is currently in daylight savings time.\n   */\n  dst: number;\n\n  /**\n   * Time zone offset from UTC.\n   */\n  offset: number;\n}\n\n/**\n * Represents metadata associated with a timezone.\n *\n * @public\n */\nexport interface ZoneMeta {\n  /**\n   * Time zone identifier. Corrected if the metadata was looked up using an alias.\n   */\n  zoneid: string;\n\n  /**\n   * Current standard offset from UTC, in milliseconds.\n   */\n  stdoffset: number;\n\n  /**\n   * Latitude of the zone's \"principal location\".\n   */\n  latitude: number;\n\n  /**\n   * Longitude of the zone's \"principal location\".\n   */\n  longitude: number;\n\n  /**\n   * ISO 3166 2-character country code for all countries which\n   * overlap the timezone.\n   */\n  countries: string[];\n}\n\n/**\n * Interface to accessing time zone data.\n *\n * @public\n */\nexport interface Tz {\n  /**\n   * Get the info for a time zone using a UTC timestamp.\n   */\n  fromUTC(zoneid: string, utc: number): ZoneInfo | undefined;\n\n  /**\n   * Get the info for a time zone using a Wall Clock timestamp. This returns\n   * the corresponding UTC timestamp and the timezone info record, or undefined\n   * if the zone lookup fails.\n   *\n   * Since daylight savings time can result in a clock being moved backwards,\n   * there is some ambiguity in resolving a wall clock time to the corresponding\n   * UTC time. For example, on November 8 2020 in New York, the time 1:30 AM\n   * occurs twice: once before the timezone boundary of 2:00 AM is reached, and\n   * again after the clock is set back 1 hour to 1:00 AM. This method attempts\n   * to resolve the ambiguity in the most intuitive way.\n   */\n  fromWall(zoneid: string, wall: number): [number, ZoneInfo] | undefined;\n\n  /**\n   * Resolve a lowercase time zone id or alias into the canonical proper-cased id.\n   */\n  resolveId(id: string): string | undefined;\n\n  /**\n   * UTC zone info.\n   */\n  utcZone(): ZoneInfo;\n\n  /**\n   * Metadata related to a zone, such as the list of country codes that overlap with\n   * the zone, the latitude and longitude, and the current standard offset, in milliseconds.\n   * These can be used to display user interfaces for selecting a zone.\n   *\n   * If the zone identifier does not match a known zone or alias this returns undefined.\n   */\n  zoneMeta(id: string): ZoneMeta | undefined;\n\n  /**\n   * Returns an array of time zone ids.\n   */\n  zoneIds(): string[];\n}\n\nconst numarray = (s: string) => (s ? s.split(' ').map((n) => parseInt(n, 36)) : []);\n\n/**\n * Implements the time zone lookup.\n *\n * @public\n */\nexport class TzImpl {\n  /** Mapping of canonical time zone ids to index */\n  private zoneindex: Map<string, number> = new Map();\n\n  /** Mapping of proper- and lower-cased time zone and alias ids to canonical time zone id */\n  private linkindex: Map<string, string> = new Map();\n\n  /** Array of time zone ids */\n  private _zoneids: string[];\n\n  /** Array of untils and deltas */\n  private untilindex: number[];\n\n  /** Raw un-decoded zone info */\n  private rawzoneinfo: string[];\n\n  /** Decoded zone records */\n  private zonerecords: ZoneRecord[];\n\n  /** Default UTC zone here for quick access */\n  private utcinfo: ZoneInfo = { zoneid: 'Etc/UTC', abbr: 'UTC', dst: 0, offset: 0 };\n\n  constructor(raw: RawData) {\n    const zoneids = raw.zoneids.split('|').map((e, i) => [e, i] as [string, number]);\n\n    const links = raw.links.split('|').map((e) => {\n      const [k, j] = e.split(':');\n      return [k, Number(j)] as [string, number];\n    });\n\n    const addlink = (src: string, dst: string) => {\n      // index a few supported forms of the time zone id or alias\n      const lowersrc = src.toLowerCase();\n      this.linkindex.set(src, dst);\n      this.linkindex.set(lowersrc, dst);\n    };\n\n    this._zoneids = [];\n    zoneids.forEach((i) => {\n      const id = i[0];\n      this._zoneids.push(id);\n      this.zoneindex.set(id, i[1]);\n\n      // index the zone id as a link to itself, including the lowercase form.\n      addlink(id, id);\n    });\n\n    links.forEach((i) => {\n      const alias = i[0];\n      const id = zoneids[i[1]][0];\n      addlink(alias, id);\n    });\n\n    this.untilindex = numarray(raw.index);\n    this.rawzoneinfo = raw.zoneinfo;\n    this.zonerecords = new Array(raw.zoneinfo.length);\n\n    raw.zoneids = '';\n    raw.links = '';\n    raw.index = '';\n  }\n\n  /**\n   * Get the info for a time zone using a UTC timestamp.\n   */\n  fromUTC(zoneid: string, utc: number): ZoneInfo | undefined {\n    const r = this.lookup(zoneid, utc, true);\n    return r ? r[1] : r;\n  }\n\n  /**\n   * Get the info for a time zone using a local \"wall clock\" timestamp\n   * for that zone.\n   */\n  fromWall(zoneid: string, wall: number): [number, ZoneInfo] | undefined {\n    return this.lookup(zoneid, wall, false);\n  }\n\n  /**\n   * UTC zone info.\n   */\n  utcZone(): ZoneInfo {\n    return this.utcinfo;\n  }\n\n  /**\n   * Resolve a lowercase time zone id or alias into the canonical proper-cased id.\n   */\n  resolveId(id: string): string | undefined {\n    return this.linkindex.get(id);\n  }\n\n  /**\n   * Metadata related to a zone, such as the list of country codes that overlap with\n   * the zone, the latitude and longitude, and the current standard offset, in milliseconds.\n   * These can be used to display user interfaces for selecting a zone.\n   */\n  zoneMeta(id: string): ZoneMeta | undefined {\n    const rec = this.record(id);\n    if (rec) {\n      return {\n        zoneid: rec[0],\n        stdoffset: rec[1].stdoff,\n        latitude: rec[1].latitude,\n        longitude: rec[1].longitude,\n        countries: rec[1].countries,\n      };\n    }\n    return;\n  }\n\n  /**\n   * Returns an array of time zone ids.\n   */\n  zoneIds(): string[] {\n    return this._zoneids;\n  }\n\n  /**\n   * Lookup the time zone record and return the zone info.\n   */\n  private lookup(id: string, t: number, isutc: boolean): [number, ZoneInfo] | undefined {\n    const rec = this.record(id);\n    if (rec) {\n      const [zoneid, r] = rec;\n      const [utc, res] = isutc ? r.fromUTC(t) : r.fromWall(t);\n      return [\n        utc,\n        {\n          ...res,\n          zoneid,\n        },\n      ];\n    }\n    return undefined;\n  }\n\n  /**\n   * Find a record for a time zone id or alias.\n   */\n  private record(zoneid: string): [string, ZoneRecord] | undefined {\n    const id = this.linkindex.get(zoneid);\n    // Failed to match a time zone or alias in any of the supported forms\n    if (id === undefined) {\n      return undefined;\n    }\n\n    // Find the offset to the record for this zone.\n    const i = this.zoneindex.get(id)!;\n\n    // See if we've already decoded this zone\n    let rec = this.zonerecords[i];\n    if (rec === undefined) {\n      // Decode raw data then clear the reference to release the memory\n      const raw = this.rawzoneinfo[i];\n      rec = new ZoneRecord(raw, this.untilindex);\n      this.zonerecords[i] = rec;\n      this.rawzoneinfo[i] = '';\n    }\n\n    // Return canonical time zone id with its record\n    return [id, rec];\n  }\n}\n\n/**\n * Information related to a single timezone.\n *\n * @internal\n */\nclass ZoneRecord {\n  // metadata\n  readonly stdoff: number;\n  readonly latitude: number;\n  readonly longitude: number;\n  readonly countries: string[]; // indices\n\n  readonly localtime: ZoneInfoRec[];\n  readonly types: number[];\n  readonly untils: number[];\n  readonly len: number;\n\n  constructor(raw: string, index: number[]) {\n    const [_std, _lat, _lon, _countries, _info, _types, _untils] = raw.split('_');\n    const untils = numarray(_untils);\n    const types = _types ? _types.split('').map((t) => TYPES[t]) : [];\n\n    // Decode initial until and the deltas\n    const len = untils.length;\n    if (len > 0) {\n      untils[0] = index[untils[0]] * 1000;\n      for (let i = 1; i < len; i++) {\n        untils[i] = untils[i - 1] + index[untils[i]] * 1000;\n      }\n    }\n\n    this.stdoff = parseInt(_std, 36) * 1000;\n    this.latitude = parseInt(_lat, 36) / 1e6;\n    this.longitude = parseInt(_lon, 36) / 1e6;\n    this.countries = _countries ? _countries.split(',') : [];\n    this.localtime = _info.split('|').map(this.decodeInfo);\n    this.types = types;\n    this.untils = untils;\n    this.len = untils.length;\n  }\n\n  /**\n   * Resolve the zone info using a UTC timestamp.\n   */\n  fromUTC(utc: number): [number, ZoneInfoRec] {\n    const i = binarySearch(this.untils, true, utc);\n    const type = i === -1 ? 0 : this.types[i];\n    return [utc, this.localtime[type]];\n  }\n\n  /**\n   * Resolve the zone info using a wall clock timestamp in the given zone.\n   *\n   * We have to determine the nearest DST transition boundary in wall clock\n   * time, and choose one side of the boundary based on whether the clock moved\n   * backwards or forwards, and where our wall time falls relative to\n   * the boundary, or within the transitional gap.\n   */\n  fromWall(wall: number): [number, ZoneInfoRec] {\n    // Find the until one day before our wall time\n    let i = binarySearch(this.untils, true, wall - 86400000);\n    const r0 = this.localtime[i === -1 ? 0 : this.types[i]];\n    i++;\n\n    // Check if we hit the end of the untils array and return\n    if (i === this.types.length) {\n      return [wall - r0.offset, r0];\n    }\n\n    // Get the next until.\n    const r1 = this.localtime[this.types[i]];\n    const u1 = this.untils[i];\n\n    // Adjust the next until using the prior offset to find the wall clock time of the boundary.\n    //\n    // Example for New York on Mar 8, 2020 with DST boundary at 7:00 AM UTC:\n    //   1:59 AM NY time is UTC 6:59 AM minus 5 hours\n    //\n    // 1 minute later the offset changes to -04:00:\n    //   2:00 AM NY time is UTC 7:00 AM minus 5 hours, so local time becomes 3:00 AM\n    //\n    // Example for New York on Nov 1, 2020 with DST boundary at 7:00 AM UTC:\n    //   1:59 AM NY time is UTC 5:59 AM minus 4 hours\n    //\n    // 1 minute later the offset changes to -05:00:\n    //   2:00 AM NY time is UTC 6:00 AM minus 4 hours, so local time becomes 1:00 AM\n\n    // Wall time instantaneously at zone boundary\n    const w0 = u1 + r0.offset;\n\n    // New wall time after boundary is crossed\n    const w1 = u1 + r1.offset;\n\n    // Wall time is before the gap, return pre-boundary offset\n    if (wall < w0 && wall < w1) {\n      return [wall - r0.offset, r0];\n    }\n\n    // When local time jumps forward, the resulting gap contains many \"impossible\"\n    // times. In our example for New York, Mar 8 2020 at 2:30 AM is invalid.\n    // We return a UTC timestamp and offset that will make the local time 3:30 AM.\n    if (w0 < w1) {\n      // Wall time is either in the gap of impossible times or after the gap.\n      return wall < w1 ? [wall - r0.offset, r1] : [wall - r1.offset, r1];\n    }\n\n    // When local time jumps backwards, many times occur twice.\n    // In our example for New York, Nov 1 2020, 1:30 AM occurs once as local\n    // time moves towards 2:00 AM, and occurs again after the time has been\n    // moved back to 1:00 AM.\n    return wall < w0 ? [wall - r0.offset, r0] : [wall - r1.offset, r1];\n  }\n\n  /**\n   * Decode a single zone info record.\n   */\n  private decodeInfo(raw: string): ZoneInfoRec {\n    const [abbr, _dst, _offset] = raw.split(':');\n    return {\n      abbr,\n      dst: Number(_dst),\n      offset: parseInt(_offset, 36) * 1000,\n    };\n  }\n}\n\nconst TYPES = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').reduce(\n  (p, c, i) => {\n    p[c] = i;\n    return p;\n  },\n  {} as { [x: string]: number },\n);\n\ninterface ZoneInfoRec {\n  abbr: string;\n  dst: number;\n  offset: number;\n}\n\n/**\n * Global instance for accessing time zones.\n *\n * @public\n */\nexport const TZ: Tz = new TzImpl(rawdata);\n"]}