import { __assign } from "tslib";
import { rawdata } from './autogen.zonedata';
import { binarySearch } from '@phensley/cldr-utils';
var numarray = function (s) { return (s ? s.split(' ').map(function (n) { return parseInt(n, 36); }) : []); };
/**
 * Implements the time zone lookup.
 *
 * @public
 */
var TzImpl = /** @class */ (function () {
    function TzImpl(raw) {
        var _this = this;
        /** Mapping of canonical time zone ids to index */
        this.zoneindex = new Map();
        /** Mapping of proper- and lower-cased time zone and alias ids to canonical time zone id */
        this.linkindex = new Map();
        /** Default UTC zone here for quick access */
        this.utcinfo = { zoneid: 'Etc/UTC', abbr: 'UTC', dst: 0, offset: 0 };
        var zoneids = raw.zoneids.split('|').map(function (e, i) { return [e, i]; });
        var links = raw.links.split('|').map(function (e) {
            var _a = e.split(':'), k = _a[0], j = _a[1];
            return [k, Number(j)];
        });
        var addlink = function (src, dst) {
            // index a few supported forms of the time zone id or alias
            var lowersrc = src.toLowerCase();
            _this.linkindex.set(src, dst);
            _this.linkindex.set(lowersrc, dst);
        };
        this._zoneids = [];
        zoneids.forEach(function (i) {
            var id = i[0];
            _this._zoneids.push(id);
            _this.zoneindex.set(id, i[1]);
            // index the zone id as a link to itself, including the lowercase form.
            addlink(id, id);
        });
        links.forEach(function (i) {
            var alias = i[0];
            var id = zoneids[i[1]][0];
            addlink(alias, id);
        });
        this.untilindex = numarray(raw.index);
        this.rawzoneinfo = raw.zoneinfo;
        this.zonerecords = new Array(raw.zoneinfo.length);
        raw.zoneids = '';
        raw.links = '';
        raw.index = '';
    }
    /**
     * Get the info for a time zone using a UTC timestamp.
     */
    TzImpl.prototype.fromUTC = function (zoneid, utc) {
        var r = this.lookup(zoneid, utc, true);
        return r ? r[1] : r;
    };
    /**
     * Get the info for a time zone using a local "wall clock" timestamp
     * for that zone.
     */
    TzImpl.prototype.fromWall = function (zoneid, wall) {
        return this.lookup(zoneid, wall, false);
    };
    /**
     * UTC zone info.
     */
    TzImpl.prototype.utcZone = function () {
        return this.utcinfo;
    };
    /**
     * Resolve a lowercase time zone id or alias into the canonical proper-cased id.
     */
    TzImpl.prototype.resolveId = function (id) {
        return this.linkindex.get(id);
    };
    /**
     * Metadata related to a zone, such as the list of country codes that overlap with
     * the zone, the latitude and longitude, and the current standard offset, in milliseconds.
     * These can be used to display user interfaces for selecting a zone.
     */
    TzImpl.prototype.zoneMeta = function (id) {
        var rec = this.record(id);
        if (rec) {
            return {
                zoneid: rec[0],
                stdoffset: rec[1].stdoff,
                latitude: rec[1].latitude,
                longitude: rec[1].longitude,
                countries: rec[1].countries,
            };
        }
        return;
    };
    /**
     * Returns an array of time zone ids.
     */
    TzImpl.prototype.zoneIds = function () {
        return this._zoneids;
    };
    /**
     * Lookup the time zone record and return the zone info.
     */
    TzImpl.prototype.lookup = function (id, t, isutc) {
        var rec = this.record(id);
        if (rec) {
            var zoneid = rec[0], r = rec[1];
            var _a = isutc ? r.fromUTC(t) : r.fromWall(t), utc = _a[0], res = _a[1];
            return [
                utc,
                __assign(__assign({}, res), { zoneid: zoneid }),
            ];
        }
        return undefined;
    };
    /**
     * Find a record for a time zone id or alias.
     */
    TzImpl.prototype.record = function (zoneid) {
        var id = this.linkindex.get(zoneid);
        // Failed to match a time zone or alias in any of the supported forms
        if (id === undefined) {
            return undefined;
        }
        // Find the offset to the record for this zone.
        var i = this.zoneindex.get(id);
        // See if we've already decoded this zone
        var rec = this.zonerecords[i];
        if (rec === undefined) {
            // Decode raw data then clear the reference to release the memory
            var raw = this.rawzoneinfo[i];
            rec = new ZoneRecord(raw, this.untilindex);
            this.zonerecords[i] = rec;
            this.rawzoneinfo[i] = '';
        }
        // Return canonical time zone id with its record
        return [id, rec];
    };
    return TzImpl;
}());
export { TzImpl };
/**
 * Information related to a single timezone.
 *
 * @internal
 */
var ZoneRecord = /** @class */ (function () {
    function ZoneRecord(raw, index) {
        var _a = raw.split('_'), _std = _a[0], _lat = _a[1], _lon = _a[2], _countries = _a[3], _info = _a[4], _types = _a[5], _untils = _a[6];
        var untils = numarray(_untils);
        var types = _types ? _types.split('').map(function (t) { return TYPES[t]; }) : [];
        // Decode initial until and the deltas
        var len = untils.length;
        if (len > 0) {
            untils[0] = index[untils[0]] * 1000;
            for (var i = 1; i < len; i++) {
                untils[i] = untils[i - 1] + index[untils[i]] * 1000;
            }
        }
        this.stdoff = parseInt(_std, 36) * 1000;
        this.latitude = parseInt(_lat, 36) / 1e6;
        this.longitude = parseInt(_lon, 36) / 1e6;
        this.countries = _countries ? _countries.split(',') : [];
        this.localtime = _info.split('|').map(this.decodeInfo);
        this.types = types;
        this.untils = untils;
        this.len = untils.length;
    }
    /**
     * Resolve the zone info using a UTC timestamp.
     */
    ZoneRecord.prototype.fromUTC = function (utc) {
        var i = binarySearch(this.untils, true, utc);
        var type = i === -1 ? 0 : this.types[i];
        return [utc, this.localtime[type]];
    };
    /**
     * Resolve the zone info using a wall clock timestamp in the given zone.
     *
     * We have to determine the nearest DST transition boundary in wall clock
     * time, and choose one side of the boundary based on whether the clock moved
     * backwards or forwards, and where our wall time falls relative to
     * the boundary, or within the transitional gap.
     */
    ZoneRecord.prototype.fromWall = function (wall) {
        // Find the until one day before our wall time
        var i = binarySearch(this.untils, true, wall - 86400000);
        var r0 = this.localtime[i === -1 ? 0 : this.types[i]];
        i++;
        // Check if we hit the end of the untils array and return
        if (i === this.types.length) {
            return [wall - r0.offset, r0];
        }
        // Get the next until.
        var r1 = this.localtime[this.types[i]];
        var u1 = this.untils[i];
        // Adjust the next until using the prior offset to find the wall clock time of the boundary.
        //
        // Example for New York on Mar 8, 2020 with DST boundary at 7:00 AM UTC:
        //   1:59 AM NY time is UTC 6:59 AM minus 5 hours
        //
        // 1 minute later the offset changes to -04:00:
        //   2:00 AM NY time is UTC 7:00 AM minus 5 hours, so local time becomes 3:00 AM
        //
        // Example for New York on Nov 1, 2020 with DST boundary at 7:00 AM UTC:
        //   1:59 AM NY time is UTC 5:59 AM minus 4 hours
        //
        // 1 minute later the offset changes to -05:00:
        //   2:00 AM NY time is UTC 6:00 AM minus 4 hours, so local time becomes 1:00 AM
        // Wall time instantaneously at zone boundary
        var w0 = u1 + r0.offset;
        // New wall time after boundary is crossed
        var w1 = u1 + r1.offset;
        // Wall time is before the gap, return pre-boundary offset
        if (wall < w0 && wall < w1) {
            return [wall - r0.offset, r0];
        }
        // When local time jumps forward, the resulting gap contains many "impossible"
        // times. In our example for New York, Mar 8 2020 at 2:30 AM is invalid.
        // We return a UTC timestamp and offset that will make the local time 3:30 AM.
        if (w0 < w1) {
            // Wall time is either in the gap of impossible times or after the gap.
            return wall < w1 ? [wall - r0.offset, r1] : [wall - r1.offset, r1];
        }
        // When local time jumps backwards, many times occur twice.
        // In our example for New York, Nov 1 2020, 1:30 AM occurs once as local
        // time moves towards 2:00 AM, and occurs again after the time has been
        // moved back to 1:00 AM.
        return wall < w0 ? [wall - r0.offset, r0] : [wall - r1.offset, r1];
    };
    /**
     * Decode a single zone info record.
     */
    ZoneRecord.prototype.decodeInfo = function (raw) {
        var _a = raw.split(':'), abbr = _a[0], _dst = _a[1], _offset = _a[2];
        return {
            abbr: abbr,
            dst: Number(_dst),
            offset: parseInt(_offset, 36) * 1000,
        };
    };
    return ZoneRecord;
}());
var TYPES = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').reduce(function (p, c, i) {
    p[c] = i;
    return p;
}, {});
/**
 * Global instance for accessing time zones.
 *
 * @public
 */
export var TZ = new TzImpl(rawdata);
//# sourceMappingURL=index.js.map