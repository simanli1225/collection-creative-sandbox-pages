"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToObject = exports.substituteRegionAliases = exports.replaceRegion = void 0;
var autogen_aliases_1 = require("./autogen.aliases");
var buildTerritoryAliasMap = function () {
    return autogen_aliases_1.territoryAliasRaw.split('|').reduce(function (o, e) {
        var _a = e.split(':'), k = _a[0], v = _a[1];
        var regions = v.split(/\s+/g);
        o[k] = regions;
        return o;
    }, {});
};
var TERRITORY_ALIAS_MAP;
var init = function () { return (TERRITORY_ALIAS_MAP = buildTerritoryAliasMap()); };
/**
 * Helper for the language tag parser to fix overlong region fields that may
 * or may not be variants.
 *
 * @internal
 */
var replaceRegion = function (region) {
    if (!TERRITORY_ALIAS_MAP) {
        init();
    }
    var aliases = TERRITORY_ALIAS_MAP[region];
    return aliases === undefined ? undefined : aliases[0];
};
exports.replaceRegion = replaceRegion;
/**
 * Substitute territory subtag aliases, if any.
 *
 * @public
 */
var substituteRegionAliases = function (dst) {
    if (!TERRITORY_ALIAS_MAP) {
        init();
    }
    var region = dst[2 /* Tag.REGION */];
    var replacement = region === 2 /* Tag.REGION */ ? undefined : TERRITORY_ALIAS_MAP[region];
    if (replacement === undefined) {
        return;
    }
    // Hack: for now we just use the first region in the list.
    dst[2 /* Tag.REGION */] = replacement[0];
    // TODO: get the best regions for this language / script combination, and if
    // one is found in the replacement set, use it. Otherwise use the first in the list.
};
exports.substituteRegionAliases = substituteRegionAliases;
var stringToObject = function (raw, d1, d2) {
    var o = {};
    for (var _i = 0, _a = raw.split(d1); _i < _a.length; _i++) {
        var part = _a[_i];
        var _b = part.split(d2), k = _b[0], v = _b[1];
        o[k] = v;
    }
    return o;
};
exports.stringToObject = stringToObject;
//# sourceMappingURL=util.js.map