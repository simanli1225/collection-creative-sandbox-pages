import { __assign } from "tslib";
import { LanguageTag } from './languagetag';
import { replaceRegion, stringToObject } from './util';
import * as subtags from './autogen.subtags';
// Subtag separator
var SEP = '-';
var UNDERSCORE = /_/g;
// ISO 639 language code
var LANGUAGE = /^[a-z]{2,8}$/i;
// Selected ISO 639 codes
var EXTLANG = /^[a-z]{3}$/i;
// ISO 15924 script code
var SCRIPT = /^[a-z]{4}$/i;
// ISO 3166-1 or UN M.49 code
var REGION = /^([a-z]{2,3}|\d{3})$/i;
// Registered variants
var VARIANT = /^([a-z\d]{5,8}|\d[a-z\d]{3})$/i;
var EXTENSION_PREFIX = /^[\da-wyz]$/i;
var EXTENSION_SUBTAG = /^[\da-z]{2,8}$/i;
var PRIVATEUSE_PREFIX = /^x$/i;
var PRIVATEUSE_SUBTAG = /^[\da-z]{1,8}$/i;
// https://www.unicode.org/reports/tr35/tr35-33/tr35.html#Key_And_Type_Definitions_
var UNICODE_EXTENSION_KEYS = new Set([
    'ca', // calendar
    'co', // collation
    'cu', // currency
    'nu', // numbering system
    'tz', // timezone
    'va', // common variant type
]);
// Grandfathered irregular and regular tags from IANA registry.
var GRANDFATHERED_TAGS;
var init = function () {
    GRANDFATHERED_TAGS = __assign(__assign({}, stringToObject(subtags.grandfatheredRaw, '|', ':')), { 
        // Additional fallbacks from ICU
        'cel-gaulish': 'xtg-x-cel-gaulish', 'en-GB-oed': 'en-GB-x-oed', 'i-default': 'en-x-i-default', 'i-enochian': 'und-x-i-enochian', 'i-mingo': 'see-x-i-mingo', 'zh-min': 'nan-x-zh-min' });
};
/**
 * Match the first element of the parts array against the given pattern.
 * Shifts the first element and returns the match, or returns null.
 */
var match = function (parts, pattern) {
    if (parts.length > 0) {
        var m = parts[0].match(pattern);
        if (m !== null) {
            parts.shift();
            return m[0];
        }
    }
    return undefined;
};
/**
 * Parses a string into a series of language tag fields.
 */
var LanguageTagParser = /** @class */ (function () {
    // private errors: string[] = [];
    function LanguageTagParser(str) {
        this.extlangs = [];
        this.variants = [];
        this.extensions = {};
        this.privateUse = '';
        this.str = str;
    }
    /**
     * Parse the string and return a language tag object.
     */
    LanguageTagParser.prototype.parse = function () {
        if (!GRANDFATHERED_TAGS) {
            init();
        }
        var str = this.str.indexOf('_') === -1 ? this.str : this.str.replace(UNDERSCORE, SEP);
        var preferred = GRANDFATHERED_TAGS[str.toLowerCase()];
        var parts = typeof preferred === 'string' ? preferred.split(SEP) : str.split(SEP);
        if (this.parseLanguage(parts)) {
            if (this.language && this.language.length <= 3) {
                this.parseExtLangs(parts);
            }
            this.parseScript(parts);
            this.parseRegion(parts);
            this.parseVariants(parts);
            this.parseExtensions(parts);
        }
        this.parsePrivateUse(parts);
        // If no region was parsed, check if one of the extlangs is actually a valid ISO 3166
        if (!this.region) {
            for (var i = 0; i < this.extlangs.length; i++) {
                var replacement = replaceRegion(this.extlangs[i].toUpperCase());
                if (replacement) {
                    this.region = replacement;
                    // Ignore the extlangs since we currently don't add them to the LanguageTag.
                    break;
                }
            }
        }
        return new LanguageTag(this.language, this.script, this.region, this.variants.length === 0 ? undefined : this.variants[0], this.extensions, this.privateUse, this.extlangs);
    };
    LanguageTagParser.prototype.parseLanguage = function (parts) {
        this.language = match(parts, LANGUAGE);
        return !!this.language;
    };
    LanguageTagParser.prototype.parseExtLangs = function (parts) {
        while (parts.length !== 0) {
            var result = match(parts, EXTLANG);
            if (!result) {
                break;
            }
            this.extlangs.push(result);
        }
        return this.extlangs.length !== 0;
    };
    LanguageTagParser.prototype.parseScript = function (parts) {
        this.script = match(parts, SCRIPT);
        return !!this.script;
    };
    LanguageTagParser.prototype.parseRegion = function (parts) {
        this.region = match(parts, REGION);
        return !!this.region;
    };
    LanguageTagParser.prototype.parseVariants = function (parts) {
        while (parts.length > 0) {
            var result = match(parts, VARIANT);
            if (!result) {
                break;
            }
            this.variants.push(result);
        }
        return this.variants.length !== 0;
    };
    LanguageTagParser.prototype.parseExtensions = function (parts) {
        var parsed = false;
        while (parts.length > 0) {
            var prefix = match(parts, EXTENSION_PREFIX);
            if (!prefix) {
                break;
            }
            var subs = [];
            var temp = '';
            while (parts.length > 0) {
                var subtag = match(parts, EXTENSION_SUBTAG);
                if (!subtag) {
                    break;
                }
                if (!UNICODE_EXTENSION_KEYS.has(subtag)) {
                    temp += temp ? SEP + subtag : subtag;
                    continue;
                }
                if (temp) {
                    subs.push(temp);
                }
                temp = subtag;
            }
            if (temp) {
                subs.push(temp);
            }
            if (subs.length > 0) {
                parsed = true;
                subs.sort();
                var curr = this.extensions[prefix];
                curr = curr === undefined ? subs : curr.concat(subs);
                this.extensions[prefix] = curr.sort();
            }
        }
        return parsed;
    };
    LanguageTagParser.prototype.parsePrivateUse = function (parts) {
        var parsed = false;
        while (parts.length > 0) {
            var prefix = match(parts, PRIVATEUSE_PREFIX);
            if (!prefix) {
                break;
            }
            var subs = [];
            while (parts.length > 0) {
                var subtag = match(parts, PRIVATEUSE_SUBTAG);
                if (!subtag) {
                    break;
                }
                subs.push(subtag);
            }
            if (subs.length > 0) {
                this.privateUse += "".concat(prefix).concat(SEP).concat(subs.join(SEP));
                parsed = true;
            }
        }
        return parsed;
    };
    return LanguageTagParser;
}());
/**
 * Low-level parsing of a language tag. No resolution is performed.
 *
 * @public
 */
export var parseLanguageTag = function (str) { return new LanguageTagParser(str).parse(); };
//# sourceMappingURL=parser.js.map