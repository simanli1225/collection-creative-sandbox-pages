{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,MAAM,mBAAmB,CAAC;AAWtD,IAAM,sBAAsB,GAAG;IAC7B,OAAO,iBAAiB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,UAAC,CAAoB,EAAE,CAAC;QAC3D,IAAA,KAAS,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAApB,CAAC,QAAA,EAAE,CAAC,QAAgB,CAAC;QAC5B,IAAM,OAAO,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;QACf,OAAO,CAAC,CAAC;IACX,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CAAC;AAEF,IAAI,mBAAsC,CAAC;AAE3C,IAAM,IAAI,GAAG,cAAM,OAAA,CAAC,mBAAmB,GAAG,sBAAsB,EAAE,CAAC,EAAhD,CAAgD,CAAC;AAEpE;;;;;GAKG;AACH,MAAM,CAAC,IAAM,aAAa,GAAG,UAAC,MAAc;IAC1C,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,IAAI,EAAE,CAAC;IACT,CAAC;IACD,IAAM,OAAO,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;IAC5C,OAAO,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,IAAM,uBAAuB,GAAG,UAAC,GAAY;IAClD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,IAAI,EAAE,CAAC;IACT,CAAC;IACD,IAAM,MAAM,GAAG,GAAG,oBAAY,CAAC;IAC/B,IAAM,WAAW,GAAG,MAAM,uBAAe,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;IACpF,IAAI,WAAW,KAAK,SAAS,EAAE,CAAC;QAC9B,OAAO;IACT,CAAC;IAED,0DAA0D;IAC1D,GAAG,oBAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;IAEjC,4EAA4E;IAC5E,oFAAoF;AACtF,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,cAAc,GAAG,UAAC,GAAW,EAAE,EAAU,EAAE,EAAU;IAChE,IAAM,CAAC,GAA4B,EAAE,CAAC;IACtC,KAAmB,UAAa,EAAb,KAAA,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAb,cAAa,EAAb,IAAa,EAAE,CAAC;QAA9B,IAAM,IAAI,SAAA;QACP,IAAA,KAAS,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAtB,CAAC,QAAA,EAAE,CAAC,QAAkB,CAAC;QAC9B,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACX,CAAC;IACD,OAAO,CAAC,CAAC;AACX,CAAC,CAAC","sourcesContent":["import { LanguageTagField as Tag } from './languagetag';\nimport { territoryAliasRaw } from './autogen.aliases';\n\n/**\n * @public\n */\nexport type FastTag = (string | number)[];\n\nexport type FastTagPair = { type: FastTag; repl: FastTag };\nexport type LanguageAliasMap = { [x: string]: FastTagPair[] };\nexport type TerritoryAliasMap = { [x: string]: string[] };\n\nconst buildTerritoryAliasMap = (): TerritoryAliasMap => {\n  return territoryAliasRaw.split('|').reduce((o: TerritoryAliasMap, e) => {\n    const [k, v] = e.split(':');\n    const regions = v.split(/\\s+/g);\n    o[k] = regions;\n    return o;\n  }, {});\n};\n\nlet TERRITORY_ALIAS_MAP: TerritoryAliasMap;\n\nconst init = () => (TERRITORY_ALIAS_MAP = buildTerritoryAliasMap());\n\n/**\n * Helper for the language tag parser to fix overlong region fields that may\n * or may not be variants.\n *\n * @internal\n */\nexport const replaceRegion = (region: string): string | undefined => {\n  if (!TERRITORY_ALIAS_MAP) {\n    init();\n  }\n  const aliases = TERRITORY_ALIAS_MAP[region];\n  return aliases === undefined ? undefined : aliases[0];\n};\n\n/**\n * Substitute territory subtag aliases, if any.\n *\n * @public\n */\nexport const substituteRegionAliases = (dst: FastTag): void => {\n  if (!TERRITORY_ALIAS_MAP) {\n    init();\n  }\n  const region = dst[Tag.REGION];\n  const replacement = region === Tag.REGION ? undefined : TERRITORY_ALIAS_MAP[region];\n  if (replacement === undefined) {\n    return;\n  }\n\n  // Hack: for now we just use the first region in the list.\n  dst[Tag.REGION] = replacement[0];\n\n  // TODO: get the best regions for this language / script combination, and if\n  // one is found in the replacement set, use it. Otherwise use the first in the list.\n};\n\nexport const stringToObject = (raw: string, d1: string, d2: string): { [x: string]: string } => {\n  const o: { [x: string]: string } = {};\n  for (const part of raw.split(d1)) {\n    const [k, v] = part.split(d2);\n    o[k] = v;\n  }\n  return o;\n};\n"]}