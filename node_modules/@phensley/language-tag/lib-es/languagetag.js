var SEP = '-';
var UNDEFINED_VALUES = ['und', 'Zzzz', 'ZZ', ''];
var KEYS = [0 /* LanguageTagField.LANGUAGE */, 1 /* LanguageTagField.SCRIPT */, 2 /* LanguageTagField.REGION */, 3 /* LanguageTagField.VARIANT */];
var TRANSFORMS = [
    function (s) { return s.toLowerCase(); },
    function (s) { return s[0].toUpperCase() + s.substring(1).toLowerCase(); },
    function (s) { return s.toUpperCase(); },
    function (s) { return s.toLowerCase(); },
];
/**
 * Ensure the given field is in canonical form.
 */
var canonicalize = function (field, value) {
    if (field === 0 /* LanguageTagField.LANGUAGE */ && value === 'root') {
        value = undefined;
    }
    else if (value === UNDEFINED_VALUES[field]) {
        value = undefined;
    }
    if (typeof value === 'string' && value.length > 0) {
        return TRANSFORMS[field](value);
    }
    return undefined;
};
/**
 * IETF BCP 47 language tag with static methods for parsing, adding likely
 * subtags, etc.
 *
 * @public
 */
var LanguageTag = /** @class */ (function () {
    function LanguageTag(language, script, region, variant, extensions, privateUse, extlangs) {
        this.core = [
            canonicalize(0 /* LanguageTagField.LANGUAGE */, language),
            canonicalize(1 /* LanguageTagField.SCRIPT */, script),
            canonicalize(2 /* LanguageTagField.REGION */, region),
            canonicalize(3 /* LanguageTagField.VARIANT */, variant),
        ];
        this._extensions = extensions || {};
        this._privateUse = privateUse || '';
        this._extlangs = extlangs || [];
    }
    /**
     * Language subtag.
     */
    LanguageTag.prototype.language = function () {
        return this.core[0 /* LanguageTagField.LANGUAGE */] || UNDEFINED_VALUES[0 /* LanguageTagField.LANGUAGE */];
    };
    /**
     * Returns true if the language subtag is defined.
     */
    LanguageTag.prototype.hasLanguage = function () {
        return this.core[0 /* LanguageTagField.LANGUAGE */] !== undefined;
    };
    /**
     * Script subtag.
     */
    LanguageTag.prototype.script = function () {
        return this.core[1 /* LanguageTagField.SCRIPT */] || UNDEFINED_VALUES[1 /* LanguageTagField.SCRIPT */];
    };
    /**
     * Returns true if the script subtag is defined.
     */
    LanguageTag.prototype.hasScript = function () {
        return this.core[1 /* LanguageTagField.SCRIPT */] !== undefined;
    };
    /**
     * Region subtag.
     */
    LanguageTag.prototype.region = function () {
        return this.core[2 /* LanguageTagField.REGION */] || UNDEFINED_VALUES[2 /* LanguageTagField.REGION */];
    };
    /**
     * Returns true if the region subtag is defined.
     */
    LanguageTag.prototype.hasRegion = function () {
        return this.core[2 /* LanguageTagField.REGION */] !== undefined;
    };
    /**
     * Variant subtag.
     */
    LanguageTag.prototype.variant = function () {
        return this.core[3 /* LanguageTagField.VARIANT */] || UNDEFINED_VALUES[3 /* LanguageTagField.VARIANT */];
    };
    /**
     * Return a copy of this language tag's extensions map.
     */
    LanguageTag.prototype.extensions = function () {
        var exts = this._extensions;
        var res = {};
        Object.keys(exts).forEach(function (k) {
            res[k] = exts[k];
        });
        return res;
    };
    /**
     * Return a copy of the extensions of the given type. Use 'u' for Unicode
     * and 't' for Transforms.
     */
    LanguageTag.prototype.extensionSubtags = function (key) {
        var exts = this._extensions[key];
        return exts || [];
    };
    /**
     * Private use subtag.
     */
    LanguageTag.prototype.privateUse = function () {
        return this._privateUse;
    };
    /**
     * Extended language tags, used for BCP 47 canonicalization.
     */
    LanguageTag.prototype.extlangs = function () {
        return this._extlangs;
    };
    /**
     * Return a compact string representation of the language tag. Any undefined
     * fields will be omitted.
     */
    LanguageTag.prototype.compact = function () {
        if (!this._compact) {
            this._compact = this.render(false);
        }
        return this._compact;
    };
    /**
     * Return an expanded string representation of the language tag. Any undefined
     * fields will emit their undefined value.
     */
    LanguageTag.prototype.expanded = function () {
        if (!this._expanded) {
            this._expanded = this.render(true);
        }
        return this._expanded;
    };
    /**
     * Return a compact string representation of the language tag. Any undefined
     * fields will be omitted.
     */
    LanguageTag.prototype.toString = function () {
        return this.compact();
    };
    /**
     * Render a tag in compact or expanded form.
     */
    LanguageTag.prototype.render = function (expanded) {
        var _this = this;
        var buf = '';
        KEYS.forEach(function (key) {
            var force = key !== 3 /* LanguageTagField.VARIANT */ && (key === 0 /* LanguageTagField.LANGUAGE */ || expanded);
            var val = _this.core[key];
            if (val !== undefined || force) {
                if (buf.length > 0) {
                    buf += SEP;
                }
                buf += val ? val : UNDEFINED_VALUES[key];
            }
        });
        var exts = this._extensions;
        var keys = Object.keys(exts);
        if (keys.length) {
            keys.sort().forEach(function (k) {
                var vals = exts[k];
                if (vals !== undefined && vals.length > 0) {
                    buf += SEP + k + SEP + exts[k].join(SEP);
                }
            });
        }
        if (this._privateUse.length > 0) {
            buf += SEP + this._privateUse;
        }
        return buf;
    };
    return LanguageTag;
}());
export { LanguageTag };
//# sourceMappingURL=languagetag.js.map