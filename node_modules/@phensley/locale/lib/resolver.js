"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageResolver = exports.returnTag = exports.fastTag = void 0;
var language_tag_1 = require("@phensley/language-tag");
var util_1 = require("./util");
var autogen_aliases_1 = require("./autogen.aliases");
var autogen_subtags_1 = require("./autogen.subtags");
/**
 * Since a lot of comparisons will be done, we need fast access to
 * core fields of LanguageTag without exposing the raw fields.
 *
 * Visible for testing
 */
var fastTag = function (real) {
    // Hack to get fast access to internal core fields without exposing them.
    var fake = real;
    // The fast tag is used for indexing purposes. Since a field may be
    // undefined, and we don't want to use its string representation of
    // the undefined value (e.g. 'und', 'Zzzz', etc), we use the field's
    // index number to represent undefined.
    var fast = fake.core.slice(0, 3);
    for (var i = 0; i < 3; i++) {
        if (!fast[i]) {
            fast[i] = i;
        }
    }
    // If an extlang subtag exists, replace the language subtag with the first
    // extlang value.
    if (fake._extlangs && fake._extlangs.length) {
        fast[0] = fake._extlangs[0];
    }
    return fast;
};
exports.fastTag = fastTag;
var likelyGet = function (query) {
    var lang = query[0 /* Tag.LANGUAGE */];
    var n1 = autogen_subtags_1.likelySubtags[lang] || {};
    var script = query[1 /* Tag.SCRIPT */];
    var n2 = n1[script] || {};
    var region = query[2 /* Tag.REGION */];
    var n3 = n2[region];
    if (typeof n3 === 'string') {
        // On first access, convert to an array representation
        var p = n3.split('-').map(function (v, i) {
            if (!v) {
                return i === 0 ? lang : region;
            }
            if (i === 1) {
                return autogen_subtags_1.likelySubtags._[Number(v)];
            }
            return v;
        });
        n2[region] = p;
        return p;
    }
    return n3;
};
var MATCH_ORDER = [
    1 /* F.LANGUAGE */ | 2 /* F.SCRIPT */ | 4 /* F.REGION */,
    1 /* F.LANGUAGE */ | 4 /* F.REGION */,
    1 /* F.LANGUAGE */ | 2 /* F.SCRIPT */,
    1 /* F.LANGUAGE */,
    2 /* F.SCRIPT */,
];
/**
 * Clear or copy fields from src to dst depending on flags.
 */
var setFields = function (src, dst, flags) {
    dst[0 /* Tag.LANGUAGE */] = (flags & 1 /* F.LANGUAGE */) === 0 ? 0 /* Tag.LANGUAGE */ : src[0 /* Tag.LANGUAGE */];
    dst[1 /* Tag.SCRIPT */] = (flags & 2 /* F.SCRIPT */) === 0 ? 1 /* Tag.SCRIPT */ : src[1 /* Tag.SCRIPT */];
    dst[2 /* Tag.REGION */] = (flags & 4 /* F.REGION */) === 0 ? 2 /* Tag.REGION */ : src[2 /* Tag.REGION */];
};
/**
 * Lookup any aliases that match this tag, and replace any undefined subtags.
 */
var substituteLanguageAliases = function (dst) {
    if (!LANGUAGE_ALIAS_MAP) {
        initAlias();
    }
    var aliases = LANGUAGE_ALIAS_MAP[dst[0 /* Tag.LANGUAGE */]];
    if (aliases === undefined) {
        return;
    }
    for (var i = 0; i < aliases.length; i++) {
        var _a = aliases[i], type = _a[0], repl = _a[1];
        var exact = type[0 /* Tag.LANGUAGE */] === dst[0 /* Tag.LANGUAGE */] &&
            type[1 /* Tag.SCRIPT */] === dst[1 /* Tag.SCRIPT */] &&
            type[2 /* Tag.REGION */] === dst[2 /* Tag.REGION */];
        if ((type[1 /* Tag.SCRIPT */] === 1 /* Tag.SCRIPT */ && type[2 /* Tag.REGION */] === 2 /* Tag.REGION */) || exact) {
            dst[0 /* Tag.LANGUAGE */] = repl[0 /* Tag.LANGUAGE */];
            if (dst[1 /* Tag.SCRIPT */] === 1 /* Tag.SCRIPT */) {
                dst[1 /* Tag.SCRIPT */] = repl[1 /* Tag.SCRIPT */];
            }
            if (dst[2 /* Tag.REGION */] === 2 /* Tag.REGION */) {
                dst[2 /* Tag.REGION */] = repl[2 /* Tag.REGION */];
            }
            break;
        }
    }
};
/**
 * Add any missing subtags using the likely subtags mapping. For example,
 * this would convert "en" to "en-Latn-US".
 */
var addLikelySubtags = function (dst) {
    var tmp = dst.slice(0);
    for (var i = 0; i < MATCH_ORDER.length; i++) {
        var flags = MATCH_ORDER[i];
        setFields(dst, tmp, flags);
        var match = likelyGet(tmp);
        if (match !== undefined) {
            if (dst[0 /* Tag.LANGUAGE */] === 0 /* Tag.LANGUAGE */) {
                dst[0 /* Tag.LANGUAGE */] = match[0 /* Tag.LANGUAGE */];
            }
            if (dst[1 /* Tag.SCRIPT */] === 1 /* Tag.SCRIPT */) {
                dst[1 /* Tag.SCRIPT */] = match[1 /* Tag.SCRIPT */];
            }
            if (dst[2 /* Tag.REGION */] === 2 /* Tag.REGION */) {
                dst[2 /* Tag.REGION */] = match[2 /* Tag.REGION */];
            }
            break;
        }
    }
};
/**
 * Return a language tag, combining the fast tag's core subtags with the
 * original's additional subtags.
 *
 * Visible for testing
 */
var returnTag = function (real, fast) {
    var language = fast[0 /* Tag.LANGUAGE */];
    var script = fast[1 /* Tag.SCRIPT */];
    var region = fast[2 /* Tag.REGION */];
    return new language_tag_1.LanguageTag(typeof language === 'number' ? undefined : language, typeof script === 'number' ? undefined : script, typeof region === 'number' ? undefined : region, real.variant(), real.extensions(), real.privateUse());
};
exports.returnTag = returnTag;
// Undefined tag to be copied for use in resolution below.
var UNDEFINED = [0 /* Tag.LANGUAGE */, 1 /* Tag.SCRIPT */, 2 /* Tag.REGION */];
/**
 * Compare two fast tags for equality. These always have identical length.
 */
var fastTagEquals = function (a, b) {
    var len = a.length;
    for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};
var parseFastTag = function (s) {
    var p = s.split('-');
    var r = [0, 1, 2];
    for (var i = 0; i < 3; i++) {
        if (p[i]) {
            r[i] = p[i];
        }
    }
    return r;
};
var buildLanguageAliasMap = function () {
    var languageAlias = (0, util_1.stringToObject)(autogen_aliases_1.languageAliasRaw, '|', ':');
    return Object.keys(languageAlias).reduce(function (o, k) {
        var type = parseFastTag(k);
        var repl = parseFastTag(languageAlias[k]);
        var language = type[0 /* Tag.LANGUAGE */];
        var aliases = o[language];
        if (aliases === undefined) {
            aliases = [];
            o[language] = aliases;
        }
        aliases.push([type, repl]);
        return o;
    }, {});
};
// Singleton maps.
var LANGUAGE_ALIAS_MAP;
var initAlias = function () {
    LANGUAGE_ALIAS_MAP = buildLanguageAliasMap();
};
/**
 * Methods for substituting language and region aliases, adding likely subtags, etc.
 *
 * @public
 */
var LanguageResolver = /** @class */ (function () {
    function LanguageResolver() {
    }
    /**
     * Substitute aliases only.
     */
    LanguageResolver.substituteAliases = function (real) {
        var tag = typeof real === 'string' ? (0, language_tag_1.parseLanguageTag)(real) : real;
        var fast = (0, exports.fastTag)(tag);
        substituteLanguageAliases(fast);
        (0, language_tag_1.substituteRegionAliases)(fast);
        return (0, exports.returnTag)(tag, fast);
    };
    /**
     * Substitute all relevant aliases, and then add likely subtags.
     */
    LanguageResolver.resolve = function (real) {
        var tag = typeof real === 'string' ? (0, language_tag_1.parseLanguageTag)(real) : real;
        var fast = (0, exports.fastTag)(tag);
        // TODO: add flags to determine which operations to perform.
        substituteLanguageAliases(fast);
        (0, language_tag_1.substituteRegionAliases)(fast);
        addLikelySubtags(fast);
        return (0, exports.returnTag)(tag, fast);
    };
    /**
     * Add any missing subtags using the likely subtags mapping. For example,
     * this would convert "en" to "en-Latn-US".
     */
    LanguageResolver.addLikelySubtags = function (real) {
        var tag = typeof real === 'string' ? (0, language_tag_1.parseLanguageTag)(real) : real;
        var fast = (0, exports.fastTag)(tag);
        addLikelySubtags(fast);
        return (0, exports.returnTag)(tag, fast);
    };
    /**
     * Remove any subtags that would be added by addLikelySubtags() above. For example,
     * this would convert "en-Latn-US" to "en".
     */
    LanguageResolver.removeLikelySubtags = function (real) {
        var tag = typeof real === 'string' ? (0, language_tag_1.parseLanguageTag)(real) : real;
        var max = (0, exports.fastTag)(tag);
        if (max[0 /* Tag.LANGUAGE */] === 0 /* Tag.LANGUAGE */ || max[1 /* Tag.SCRIPT */] === 1 /* Tag.SCRIPT */ || max[2 /* Tag.REGION */] === 2 /* Tag.REGION */) {
            addLikelySubtags(max);
        }
        var tmp = UNDEFINED.slice(0);
        // Using "en-Latn-US" as an example...
        // 1. Match "en-Zzzz-ZZ"
        tmp[0 /* Tag.LANGUAGE */] = max[0 /* Tag.LANGUAGE */];
        var match = tmp.slice(0);
        addLikelySubtags(match);
        if (fastTagEquals(match, max)) {
            return (0, exports.returnTag)(tag, tmp);
        }
        // 2. Match "en-Zzzz-US"
        tmp[2 /* Tag.REGION */] = max[2 /* Tag.REGION */];
        match = tmp.slice(0);
        addLikelySubtags(match);
        if (fastTagEquals(match, max)) {
            tmp[0 /* Tag.LANGUAGE */] = max[0 /* Tag.LANGUAGE */];
            return (0, exports.returnTag)(tag, tmp);
        }
        // 3. Match "en-Latn-ZZ"
        tmp[2 /* Tag.REGION */] = 2 /* Tag.REGION */;
        tmp[1 /* Tag.SCRIPT */] = max[1 /* Tag.SCRIPT */];
        match = tmp.slice(0);
        addLikelySubtags(match);
        if (fastTagEquals(match, max)) {
            return (0, exports.returnTag)(tag, tmp);
        }
        // 4. Nothing matched, so return a copy of the original tag.
        return (0, exports.returnTag)(tag, max);
    };
    return LanguageResolver;
}());
exports.LanguageResolver = LanguageResolver;
//# sourceMappingURL=resolver.js.map