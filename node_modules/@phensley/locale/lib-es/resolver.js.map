{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../src/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  parseLanguageTag,\n  substituteRegionAliases,\n  LanguageTag,\n  LanguageTagField as Tag,\n} from '@phensley/language-tag';\n\nimport { FastTag, LanguageAliasMap } from './util';\nimport { stringToObject } from './util';\nimport { languageAliasRaw } from './autogen.aliases';\nimport { likelySubtags } from './autogen.subtags';\n\n// Helper to cast LanguageTag to access protected fields\ninterface FakeLanguageTag {\n  core: (string | number)[];\n  _extensions?: string[];\n  _privateUse?: string;\n  _extlangs?: string[];\n}\n\n/**\n * Since a lot of comparisons will be done, we need fast access to\n * core fields of LanguageTag without exposing the raw fields.\n *\n * Visible for testing\n */\nexport const fastTag = (real: LanguageTag): FastTag => {\n  // Hack to get fast access to internal core fields without exposing them.\n  const fake = real as any as FakeLanguageTag;\n\n  // The fast tag is used for indexing purposes. Since a field may be\n  // undefined, and we don't want to use its string representation of\n  // the undefined value (e.g. 'und', 'Zzzz', etc), we use the field's\n  // index number to represent undefined.\n  const fast = fake.core.slice(0, 3) as FastTag;\n  for (let i = 0; i < 3; i++) {\n    if (!fast[i]) {\n      fast[i] = i;\n    }\n  }\n  // If an extlang subtag exists, replace the language subtag with the first\n  // extlang value.\n  if (fake._extlangs && fake._extlangs.length) {\n    fast[0] = fake._extlangs[0];\n  }\n  return fast;\n};\n\nconst likelyGet = (query: FastTag): FastTag | undefined => {\n  const lang = query[Tag.LANGUAGE];\n  const n1 = likelySubtags[lang] || {};\n  const script = query[Tag.SCRIPT];\n  const n2 = n1[script] || {};\n  const region = query[Tag.REGION];\n  const n3: any = n2[region];\n  if (typeof n3 === 'string') {\n    // On first access, convert to an array representation\n    const p = n3.split('-').map((v, i) => {\n      if (!v) {\n        return i === 0 ? lang : region;\n      }\n      if (i === 1) {\n        return likelySubtags._[Number(v)];\n      }\n      return v;\n    });\n    n2[region] = p;\n    return p;\n  }\n  return n3;\n};\n\n// Flags for subtag permutations\nconst enum F {\n  LANGUAGE = 1,\n  SCRIPT = 2,\n  REGION = 4,\n}\n\nconst MATCH_ORDER = [\n  F.LANGUAGE | F.SCRIPT | F.REGION,\n  F.LANGUAGE | F.REGION,\n  F.LANGUAGE | F.SCRIPT,\n  F.LANGUAGE,\n  F.SCRIPT,\n];\n\n/**\n * Clear or copy fields from src to dst depending on flags.\n */\nconst setFields = (src: FastTag, dst: FastTag, flags: number): void => {\n  dst[Tag.LANGUAGE] = (flags & F.LANGUAGE) === 0 ? Tag.LANGUAGE : src[Tag.LANGUAGE];\n  dst[Tag.SCRIPT] = (flags & F.SCRIPT) === 0 ? Tag.SCRIPT : src[Tag.SCRIPT];\n  dst[Tag.REGION] = (flags & F.REGION) === 0 ? Tag.REGION : src[Tag.REGION];\n};\n\n/**\n * Lookup any aliases that match this tag, and replace any undefined subtags.\n */\nconst substituteLanguageAliases = (dst: FastTag): void => {\n  if (!LANGUAGE_ALIAS_MAP) {\n    initAlias();\n  }\n  const aliases = LANGUAGE_ALIAS_MAP![dst[Tag.LANGUAGE]];\n  if (aliases === undefined) {\n    return;\n  }\n  for (let i = 0; i < aliases.length; i++) {\n    const [type, repl] = aliases[i];\n    const exact =\n      type[Tag.LANGUAGE] === dst[Tag.LANGUAGE] &&\n      type[Tag.SCRIPT] === dst[Tag.SCRIPT] &&\n      type[Tag.REGION] === dst[Tag.REGION];\n\n    if ((type[Tag.SCRIPT] === Tag.SCRIPT && type[Tag.REGION] === Tag.REGION) || exact) {\n      dst[Tag.LANGUAGE] = repl[Tag.LANGUAGE];\n      if (dst[Tag.SCRIPT] === Tag.SCRIPT) {\n        dst[Tag.SCRIPT] = repl[Tag.SCRIPT];\n      }\n      if (dst[Tag.REGION] === Tag.REGION) {\n        dst[Tag.REGION] = repl[Tag.REGION];\n      }\n      break;\n    }\n  }\n};\n\n/**\n * Add any missing subtags using the likely subtags mapping. For example,\n * this would convert \"en\" to \"en-Latn-US\".\n */\nconst addLikelySubtags = (dst: FastTag): void => {\n  const tmp = dst.slice(0);\n  for (let i = 0; i < MATCH_ORDER.length; i++) {\n    const flags = MATCH_ORDER[i];\n    setFields(dst, tmp, flags);\n    const match = likelyGet(tmp);\n    if (match !== undefined) {\n      if (dst[Tag.LANGUAGE] === Tag.LANGUAGE) {\n        dst[Tag.LANGUAGE] = match[Tag.LANGUAGE];\n      }\n      if (dst[Tag.SCRIPT] === Tag.SCRIPT) {\n        dst[Tag.SCRIPT] = match[Tag.SCRIPT];\n      }\n      if (dst[Tag.REGION] === Tag.REGION) {\n        dst[Tag.REGION] = match[Tag.REGION];\n      }\n      break;\n    }\n  }\n};\n\n/**\n * Return a language tag, combining the fast tag's core subtags with the\n * original's additional subtags.\n *\n * Visible for testing\n */\nexport const returnTag = (real: LanguageTag, fast: FastTag): LanguageTag => {\n  const language = fast[Tag.LANGUAGE];\n  const script = fast[Tag.SCRIPT];\n  const region = fast[Tag.REGION];\n\n  return new LanguageTag(\n    typeof language === 'number' ? undefined : language,\n    typeof script === 'number' ? undefined : script,\n    typeof region === 'number' ? undefined : region,\n    real.variant(),\n    real.extensions(),\n    real.privateUse(),\n  );\n};\n\n// Undefined tag to be copied for use in resolution below.\nconst UNDEFINED: FastTag = [Tag.LANGUAGE, Tag.SCRIPT, Tag.REGION];\n\n/**\n * Compare two fast tags for equality. These always have identical length.\n */\nconst fastTagEquals = (a: FastTag, b: FastTag): boolean => {\n  const len = a.length;\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst parseFastTag = (s: string) => {\n  const p = s.split('-');\n  const r: FastTag = [0, 1, 2];\n  for (let i = 0; i < 3; i++) {\n    if (p[i]) {\n      r[i] = p[i];\n    }\n  }\n  return r as FastTag;\n};\n\nconst buildLanguageAliasMap = (): LanguageAliasMap => {\n  const languageAlias = stringToObject(languageAliasRaw, '|', ':');\n  return Object.keys(languageAlias).reduce((o: LanguageAliasMap, k) => {\n    const type = parseFastTag(k);\n    const repl = parseFastTag(languageAlias[k]);\n    const language = type[Tag.LANGUAGE];\n    let aliases = o[language];\n    if (aliases === undefined) {\n      aliases = [];\n      o[language] = aliases;\n    }\n    aliases.push([type, repl]);\n    return o;\n  }, {});\n};\n\n// Singleton maps.\nlet LANGUAGE_ALIAS_MAP: LanguageAliasMap | undefined;\n\nconst initAlias = () => {\n  LANGUAGE_ALIAS_MAP = buildLanguageAliasMap();\n};\n\n/**\n * Methods for substituting language and region aliases, adding likely subtags, etc.\n *\n * @public\n */\nexport class LanguageResolver {\n  /**\n   * Substitute aliases only.\n   */\n  static substituteAliases(real: string | LanguageTag): LanguageTag {\n    const tag = typeof real === 'string' ? parseLanguageTag(real) : real;\n    const fast = fastTag(tag);\n    substituteLanguageAliases(fast);\n    substituteRegionAliases(fast);\n    return returnTag(tag, fast);\n  }\n\n  /**\n   * Substitute all relevant aliases, and then add likely subtags.\n   */\n  static resolve(real: string | LanguageTag): LanguageTag {\n    const tag = typeof real === 'string' ? parseLanguageTag(real) : real;\n    const fast = fastTag(tag);\n    // TODO: add flags to determine which operations to perform.\n    substituteLanguageAliases(fast);\n    substituteRegionAliases(fast);\n    addLikelySubtags(fast);\n    return returnTag(tag, fast);\n  }\n\n  /**\n   * Add any missing subtags using the likely subtags mapping. For example,\n   * this would convert \"en\" to \"en-Latn-US\".\n   */\n  static addLikelySubtags(real: string | LanguageTag): LanguageTag {\n    const tag = typeof real === 'string' ? parseLanguageTag(real) : real;\n    const fast = fastTag(tag);\n    addLikelySubtags(fast);\n    return returnTag(tag, fast);\n  }\n\n  /**\n   * Remove any subtags that would be added by addLikelySubtags() above. For example,\n   * this would convert \"en-Latn-US\" to \"en\".\n   */\n  static removeLikelySubtags(real: string | LanguageTag): LanguageTag {\n    const tag = typeof real === 'string' ? parseLanguageTag(real) : real;\n    const max = fastTag(tag);\n    if (max[Tag.LANGUAGE] === Tag.LANGUAGE || max[Tag.SCRIPT] === Tag.SCRIPT || max[Tag.REGION] === Tag.REGION) {\n      addLikelySubtags(max);\n    }\n    const tmp = UNDEFINED.slice(0);\n\n    // Using \"en-Latn-US\" as an example...\n    // 1. Match \"en-Zzzz-ZZ\"\n    tmp[Tag.LANGUAGE] = max[Tag.LANGUAGE];\n    let match = tmp.slice(0);\n    addLikelySubtags(match);\n    if (fastTagEquals(match, max)) {\n      return returnTag(tag, tmp);\n    }\n\n    // 2. Match \"en-Zzzz-US\"\n    tmp[Tag.REGION] = max[Tag.REGION];\n    match = tmp.slice(0);\n    addLikelySubtags(match);\n    if (fastTagEquals(match, max)) {\n      tmp[Tag.LANGUAGE] = max[Tag.LANGUAGE];\n      return returnTag(tag, tmp);\n    }\n\n    // 3. Match \"en-Latn-ZZ\"\n    tmp[Tag.REGION] = Tag.REGION;\n    tmp[Tag.SCRIPT] = max[Tag.SCRIPT];\n    match = tmp.slice(0);\n    addLikelySubtags(match);\n    if (fastTagEquals(match, max)) {\n      return returnTag(tag, tmp);\n    }\n\n    // 4. Nothing matched, so return a copy of the original tag.\n    return returnTag(tag, max);\n  }\n}\n"]}