{"version":3,"file":"matcher.js","sourceRoot":"","sources":["../src/matcher.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACvE,OAAO,EAAE,gBAAgB,EAAU,MAAM,kBAAkB,CAAC;AAE5D,OAAO,EAAE,WAAW,EAAE,iBAAiB,EAAE,YAAY,EAAE,MAAM,YAAY,CAAC;AAC1E,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAC;AAErD,wCAAwC;AACxC,IAAM,OAAO,GAAG,SAAS,CAAC;AAE1B,IAAM,CAAC,GAAG,SAAS,CAAC;AAEpB,IAAM,SAAS,GAAG,UAAC,CAAS,EAAE,CAAS,IAAK,OAAA,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAA9B,CAA8B,CAAC;AAE3E;IAEE,eACW,EAAU,EACV,GAAgB;QADhB,OAAE,GAAF,EAAE,CAAQ;QACV,QAAG,GAAH,GAAG,CAAa;QAEzB,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;IAC/B,CAAC;IACH,YAAC;AAAD,CAAC,AARD,IAQC;AAID;;;;GAIG;AACH,MAAM,CAAC,IAAM,KAAK,GAAG,UAAC,OAA2C,EAAE,OAAkC;IAA/E,wBAAA,EAAA,YAA2C;IAAE,wBAAA,EAAA,YAAkC;IACnG,IAAI,GAAc,CAAC;IACnB,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAChC,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IAC/B,CAAC;SAAM,CAAC;QACN,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,UAAC,CAAY,EAAE,CAAgC;YAClE,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE,CAAC;gBAC1B,IAAM,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBAC7B,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACvB,CAAC;YACD,IAAK,CAAY,CAAC,GAAG,YAAY,WAAW,EAAE,CAAC;gBAC7C,CAAC,CAAC,IAAI,CAAC,CAAW,CAAC,CAAC;YACtB,CAAC;iBAAM,IAAI,CAAC,YAAY,WAAW,EAAE,CAAC;gBACpC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;YACD,OAAO,CAAC,CAAC;QACX,CAAC,EAAE,EAAe,CAAC,CAAC;IACtB,CAAC;IAED,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC;IAC1C,IAAM,MAAM,GAAY,EAAE,CAAC;IAC3B,IAAM,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;QAC7B,IAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QACjB,IAAI,EAAE,SAAQ,CAAC;QACf,IAAI,GAAG,SAAa,CAAC;QACrB,IAAI,CAAC,YAAY,WAAW,EAAE,CAAC;YAC7B,GAAG,GAAG,CAAC,CAAC;YACR,EAAE,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QACrB,CAAC;aAAM,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE,CAAC;YACjC,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YACd,GAAG,GAAG,gBAAgB,CAAC,EAAE,CAAC,CAAC;QAC7B,CAAC;aAAM,CAAC;YACN,yEAAyE;YACzE,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;YACZ,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC;YACV,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC1F,SAAS;QACX,CAAC;QAED,2EAA2E;QAC3E,iDAAiD;QAEjD,IAAM,CAAC,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;QAC5B,IAAM,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;QAC1B,IAAM,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;QAE1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YAChB,iDAAiD;YACjD,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACtF,CAAC;aAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACvB,6CAA6C;YAC7C,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5E,CAAC;aAAM,CAAC;YACN,iEAAiE;YACjE,MAAM,CAAC,IAAI,CACT,IAAI,KAAK,CAAC,EAAE,EAAE,IAAI,WAAW,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,CAAC,UAAU,EAAE,EAAE,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,CAC/G,CAAC;QACJ,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AA+BF;;;;;;;;GAQG;AACH,MAAM,CAAC,IAAM,WAAW,GACtB,UAAC,CAAQ;IACT,OAAA,UAAC,CAAQ,EAAE,CAAQ;QACjB,2EAA2E;QAC3E,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;YACpB,OAAO,CAAC,CAAC,CAAC;QACZ,CAAC;QACD,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;YACpB,OAAO,CAAC,CAAC;QACX,CAAC;QAED,kDAAkD;QAClD,IAAM,EAAE,GAAG,eAAe,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACtC,IAAM,EAAE,GAAG,eAAe,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACtC,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YACrB,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC3C,CAAC;aAAM,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YAC5B,OAAO,CAAC,CAAC;QACX,CAAC;QAED,sDAAsD;QACtD,OAAO,CAAC,CAAC;IACX,CAAC;AApBD,CAoBC,CAAC;AAEJ;;;;;;;;;;;GAWG;AACH;IAME,uBAAY,gBAA4D,EAAE,OAAkC;QAAlC,wBAAA,EAAA,YAAkC;QAA5G,iBAuBC;QAzBO,aAAQ,GAA6B,EAAE,CAAC;QAG9C,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,gBAAgB,EAAE,OAAO,CAAC,CAAC;QAClD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;QACnC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;QACzE,CAAC;QAED,uDAAuD;QACvD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAE/C,iEAAiE;QACjE,0DAA0D;QAC1D,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAC,MAAM;YAC5B,IAAM,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC;YAC3B,IAAI,OAAO,GAAG,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACjC,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;gBAClB,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC;gBACnB,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;YAC/B,CAAC;iBAAM,CAAC;gBACN,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACvB,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,6BAAK,GAAL,UAAM,cAAiC,EAAE,SAAqC;QAArC,0BAAA,EAAA,6BAAqC;QAC5E,IAAM,QAAQ,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;QACvC,IAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;QAC5B,IAAI,YAAY,GAAG,YAAY,CAAC;QAChC,IAAI,SAAS,GAAG,SAAS,CAAC;QAC1B,IAAI,WAAW,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QACzD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YAC7B,IAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE5B,0CAA0C;YAC1C,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAC7C,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACxB,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACrB,YAAY,GAAG,CAAC,CAAC;gBACjB,WAAW,GAAG,OAAO,CAAC;gBACtB,MAAM;YACR,CAAC;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpC,IAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACpC,IAAM,QAAQ,GAAG,WAAW,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;gBACpE,IAAI,QAAQ,GAAG,YAAY,EAAE,CAAC;oBAC5B,YAAY,GAAG,QAAQ,CAAC;oBACxB,SAAS,GAAG,SAAS,CAAC;oBACtB,WAAW,GAAG,OAAO,CAAC;gBACxB,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC;QAChD,IAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC;QAC1C,IAAA,KAAc,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,EAAtD,EAAE,QAAA,EAAE,GAAG,SAA+C,CAAC;QAC/D,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,OAAO,EAAE,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAClH,OAAO;YACL,MAAM,EAAE,EAAE,EAAE,IAAA,EAAE,GAAG,EAAE,MAAM,EAAE;YAC3B,QAAQ,EAAE,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY;SACxD,CAAC;IACJ,CAAC;IACH,oBAAC;AAAD,CAAC,AA1ED,IA0EC","sourcesContent":["import { parseLanguageTag, LanguageTag } from '@phensley/language-tag';\nimport { LanguageResolver, Locale } from '@phensley/locale';\n\nimport { getDistance, DEFAULT_THRESHOLD, MAX_DISTANCE } from './distance';\nimport { paradigmLocales } from './autogen.distance';\n\n// Space and comma-separated bundle ids.\nconst TAG_SEP = /[,\\s]+/g;\n\nconst U = undefined;\n\nconst numberCmp = (a: number, b: number) => (a === b ? 0 : a < b ? -1 : 1);\n\nclass Entry implements Locale {\n  readonly compact: string;\n  constructor(\n    readonly id: string,\n    readonly tag: LanguageTag,\n  ) {\n    this.compact = tag.compact();\n  }\n}\n\ntype LangTag = Locale | LanguageTag | string;\n\n/**\n * Flatten and split the string or array into a list of matcher entries.\n *\n * Visible for testing.\n */\nexport const parse = (locales: string | (Locale | LangTag)[] = [], options: LocaleMatcherOptions = {}): Entry[] => {\n  let raw: LangTag[];\n  if (typeof locales === 'string') {\n    raw = locales.split(TAG_SEP);\n  } else {\n    raw = locales.reduce((a: LangTag[], e: Locale | LanguageTag | string): LangTag[] => {\n      if (typeof e === 'string') {\n        const tmp = e.split(TAG_SEP);\n        return a.concat(tmp);\n      }\n      if ((e as Locale).tag instanceof LanguageTag) {\n        a.push(e as Locale);\n      } else if (e instanceof LanguageTag) {\n        a.push(e);\n      }\n      return a;\n    }, [] as LangTag[]);\n  }\n\n  const resolve = options.resolve !== false;\n  const result: Entry[] = [];\n  const len = raw.length;\n  for (let i = 0; i < len; i++) {\n    const e = raw[i];\n    let id: string;\n    let tag: LanguageTag;\n    if (e instanceof LanguageTag) {\n      tag = e;\n      id = tag.compact();\n    } else if (typeof e === 'string') {\n      id = e.trim();\n      tag = parseLanguageTag(id);\n    } else {\n      // Have a full Locale object, so optionally substitute aliases and add it\n      tag = e.tag;\n      id = e.id;\n      result.push(new Entry(e.id, resolve ? LanguageResolver.substituteAliases(e.tag) : e.tag));\n      continue;\n    }\n\n    // This code preserves the 'und' undefined locale. If we resolve it, adding\n    // likely subtags will expand it to 'en-Latn-US'.\n\n    const l = tag.hasLanguage();\n    const s = tag.hasScript();\n    const r = tag.hasRegion();\n\n    if (l && s && r) {\n      // If all subtags are present, substitute aliases\n      result.push(new Entry(id, resolve ? LanguageResolver.substituteAliases(tag) : tag));\n    } else if (l || s || r) {\n      // If at least one subtag is present, resolve\n      result.push(new Entry(id, resolve ? LanguageResolver.resolve(tag) : tag));\n    } else {\n      // Preserve undefined core fields, but include input's extensions\n      result.push(\n        new Entry(id, new LanguageTag(undefined, undefined, undefined, undefined, tag.extensions(), tag.privateUse())),\n      );\n    }\n  }\n  return result;\n};\n\n/**\n * A result returned by the LocaleMatcher.\n *\n * @public\n */\nexport interface LocaleMatch {\n  /**\n   * The locale that was matched.\n   */\n  locale: Locale;\n\n  /**\n   * Distance of the match from the desired locale.\n   */\n  distance: number;\n}\n\n/**\n * Options for the LocaleMatcher.\n *\n * @public\n */\nexport interface LocaleMatcherOptions {\n  /**\n   * Resolve language tags. (default true)\n   */\n  resolve?: boolean;\n}\n\n/**\n * Sort the supported locale entries. The result will have the following order:\n *\n *  First: default locale\n *   Next: all paradigm locales\n *   Last: all other locales\n *\n * Visible for testing.\n */\nexport const sortEntries =\n  (d: Entry) =>\n  (a: Entry, b: Entry): number => {\n    // Check if entry is our default tag, to keep it at the front of the array.\n    if (a.tag === d.tag) {\n      return -1;\n    }\n    if (b.tag === d.tag) {\n      return 1;\n    }\n\n    // Sort all paradigm locales before non-paradigms.\n    const pa = paradigmLocales[a.compact];\n    const pb = paradigmLocales[b.compact];\n    if (pa !== undefined) {\n      return pb === U ? -1 : numberCmp(pa, pb);\n    } else if (pb !== undefined) {\n      return 1;\n    }\n\n    // All other locales stay in their relative positions.\n    return 0;\n  };\n\n/**\n * Given a list of supported locales, and a list of a user's desired locales\n * (sorted in the order of preference, descending), returns the supported\n * locale closest to the user preference. The first locale in the list will\n * be used as the default. The default will be selected if no match is within\n * the distance threshold.\n *\n * Implementation of CLDR enhanced language matching:\n * http://www.unicode.org/reports/tr35/tr35.html#EnhancedLanguageMatching\n *\n * @public\n */\nexport class LocaleMatcher {\n  private supported: Entry[];\n  private count: number;\n  private default: Entry;\n  private exactMap: { [x: string]: Entry[] } = {};\n\n  constructor(supportedLocales: string | (Locale | LanguageTag | string)[], options: LocaleMatcherOptions = {}) {\n    this.supported = parse(supportedLocales, options);\n    this.count = this.supported.length;\n    if (!this.count) {\n      throw new Error('LocaleMatcher expects at least one supported locale');\n    }\n\n    // The first locale in the list is used as the default.\n    this.default = this.supported[0];\n    this.supported.sort(sortEntries(this.default));\n\n    // Wire up a map for quick lookups of exact matches. These have a\n    // distance of 0 and will short-circuit the matching loop.\n    this.supported.forEach((locale) => {\n      const key = locale.compact;\n      let bundles = this.exactMap[key];\n      if (bundles === U) {\n        bundles = [locale];\n        this.exactMap[key] = bundles;\n      } else {\n        bundles.push(locale);\n      }\n    });\n  }\n\n  /**\n   * Find the desired locale that is the closed match to a supported locale, within\n   * the given threshold. Any matches whose distance is greater than or equal to the\n   * threshold will be treated as having maximum distance.\n   */\n  match(desiredLocales: string | string[], threshold: number = DEFAULT_THRESHOLD): LocaleMatch {\n    const desireds = parse(desiredLocales);\n    const len = desireds.length;\n    let bestDistance = MAX_DISTANCE;\n    let bestMatch = undefined;\n    let bestDesired = len === 0 ? this.default : desireds[0];\n    for (let i = 0; i < len; i++) {\n      const desired = desireds[i];\n\n      // Short-circuit if we find an exact match\n      const exact = this.exactMap[desired.compact];\n      if (exact !== undefined) {\n        bestMatch = exact[0];\n        bestDistance = 0;\n        bestDesired = desired;\n        break;\n      }\n\n      for (let j = 0; j < this.count; j++) {\n        const supported = this.supported[j];\n        const distance = getDistance(desired.tag, supported.tag, threshold);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = supported;\n          bestDesired = desired;\n        }\n      }\n    }\n\n    const extensions = bestDesired.tag.extensions();\n    const privateUse = bestDesired.tag.privateUse();\n    const { id, tag } = bestMatch === U ? this.default : bestMatch;\n    const result = new LanguageTag(tag.language(), tag.script(), tag.region(), tag.variant(), extensions, privateUse);\n    return {\n      locale: { id, tag: result },\n      distance: bestMatch === U ? MAX_DISTANCE : bestDistance,\n    };\n  }\n}\n"]}