import { parseLanguageTag, LanguageTag } from '@phensley/language-tag';
import { LanguageResolver } from '@phensley/locale';
import { getDistance, DEFAULT_THRESHOLD, MAX_DISTANCE } from './distance';
import { paradigmLocales } from './autogen.distance';
// Space and comma-separated bundle ids.
var TAG_SEP = /[,\s]+/g;
var U = undefined;
var numberCmp = function (a, b) { return (a === b ? 0 : a < b ? -1 : 1); };
var Entry = /** @class */ (function () {
    function Entry(id, tag) {
        this.id = id;
        this.tag = tag;
        this.compact = tag.compact();
    }
    return Entry;
}());
/**
 * Flatten and split the string or array into a list of matcher entries.
 *
 * Visible for testing.
 */
export var parse = function (locales, options) {
    if (locales === void 0) { locales = []; }
    if (options === void 0) { options = {}; }
    var raw;
    if (typeof locales === 'string') {
        raw = locales.split(TAG_SEP);
    }
    else {
        raw = locales.reduce(function (a, e) {
            if (typeof e === 'string') {
                var tmp = e.split(TAG_SEP);
                return a.concat(tmp);
            }
            if (e.tag instanceof LanguageTag) {
                a.push(e);
            }
            else if (e instanceof LanguageTag) {
                a.push(e);
            }
            return a;
        }, []);
    }
    var resolve = options.resolve !== false;
    var result = [];
    var len = raw.length;
    for (var i = 0; i < len; i++) {
        var e = raw[i];
        var id = void 0;
        var tag = void 0;
        if (e instanceof LanguageTag) {
            tag = e;
            id = tag.compact();
        }
        else if (typeof e === 'string') {
            id = e.trim();
            tag = parseLanguageTag(id);
        }
        else {
            // Have a full Locale object, so optionally substitute aliases and add it
            tag = e.tag;
            id = e.id;
            result.push(new Entry(e.id, resolve ? LanguageResolver.substituteAliases(e.tag) : e.tag));
            continue;
        }
        // This code preserves the 'und' undefined locale. If we resolve it, adding
        // likely subtags will expand it to 'en-Latn-US'.
        var l = tag.hasLanguage();
        var s = tag.hasScript();
        var r = tag.hasRegion();
        if (l && s && r) {
            // If all subtags are present, substitute aliases
            result.push(new Entry(id, resolve ? LanguageResolver.substituteAliases(tag) : tag));
        }
        else if (l || s || r) {
            // If at least one subtag is present, resolve
            result.push(new Entry(id, resolve ? LanguageResolver.resolve(tag) : tag));
        }
        else {
            // Preserve undefined core fields, but include input's extensions
            result.push(new Entry(id, new LanguageTag(undefined, undefined, undefined, undefined, tag.extensions(), tag.privateUse())));
        }
    }
    return result;
};
/**
 * Sort the supported locale entries. The result will have the following order:
 *
 *  First: default locale
 *   Next: all paradigm locales
 *   Last: all other locales
 *
 * Visible for testing.
 */
export var sortEntries = function (d) {
    return function (a, b) {
        // Check if entry is our default tag, to keep it at the front of the array.
        if (a.tag === d.tag) {
            return -1;
        }
        if (b.tag === d.tag) {
            return 1;
        }
        // Sort all paradigm locales before non-paradigms.
        var pa = paradigmLocales[a.compact];
        var pb = paradigmLocales[b.compact];
        if (pa !== undefined) {
            return pb === U ? -1 : numberCmp(pa, pb);
        }
        else if (pb !== undefined) {
            return 1;
        }
        // All other locales stay in their relative positions.
        return 0;
    };
};
/**
 * Given a list of supported locales, and a list of a user's desired locales
 * (sorted in the order of preference, descending), returns the supported
 * locale closest to the user preference. The first locale in the list will
 * be used as the default. The default will be selected if no match is within
 * the distance threshold.
 *
 * Implementation of CLDR enhanced language matching:
 * http://www.unicode.org/reports/tr35/tr35.html#EnhancedLanguageMatching
 *
 * @public
 */
var LocaleMatcher = /** @class */ (function () {
    function LocaleMatcher(supportedLocales, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.exactMap = {};
        this.supported = parse(supportedLocales, options);
        this.count = this.supported.length;
        if (!this.count) {
            throw new Error('LocaleMatcher expects at least one supported locale');
        }
        // The first locale in the list is used as the default.
        this.default = this.supported[0];
        this.supported.sort(sortEntries(this.default));
        // Wire up a map for quick lookups of exact matches. These have a
        // distance of 0 and will short-circuit the matching loop.
        this.supported.forEach(function (locale) {
            var key = locale.compact;
            var bundles = _this.exactMap[key];
            if (bundles === U) {
                bundles = [locale];
                _this.exactMap[key] = bundles;
            }
            else {
                bundles.push(locale);
            }
        });
    }
    /**
     * Find the desired locale that is the closed match to a supported locale, within
     * the given threshold. Any matches whose distance is greater than or equal to the
     * threshold will be treated as having maximum distance.
     */
    LocaleMatcher.prototype.match = function (desiredLocales, threshold) {
        if (threshold === void 0) { threshold = DEFAULT_THRESHOLD; }
        var desireds = parse(desiredLocales);
        var len = desireds.length;
        var bestDistance = MAX_DISTANCE;
        var bestMatch = undefined;
        var bestDesired = len === 0 ? this.default : desireds[0];
        for (var i = 0; i < len; i++) {
            var desired = desireds[i];
            // Short-circuit if we find an exact match
            var exact = this.exactMap[desired.compact];
            if (exact !== undefined) {
                bestMatch = exact[0];
                bestDistance = 0;
                bestDesired = desired;
                break;
            }
            for (var j = 0; j < this.count; j++) {
                var supported = this.supported[j];
                var distance = getDistance(desired.tag, supported.tag, threshold);
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestMatch = supported;
                    bestDesired = desired;
                }
            }
        }
        var extensions = bestDesired.tag.extensions();
        var privateUse = bestDesired.tag.privateUse();
        var _a = bestMatch === U ? this.default : bestMatch, id = _a.id, tag = _a.tag;
        var result = new LanguageTag(tag.language(), tag.script(), tag.region(), tag.variant(), extensions, privateUse);
        return {
            locale: { id: id, tag: result },
            distance: bestMatch === U ? MAX_DISTANCE : bestDistance,
        };
    };
    return LocaleMatcher;
}());
export { LocaleMatcher };
//# sourceMappingURL=matcher.js.map