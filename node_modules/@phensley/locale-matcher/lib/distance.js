"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDistance = exports.MAX_DISTANCE = exports.DEFAULT_THRESHOLD = void 0;
var partition_1 = require("./partition");
var autogen_distance_1 = require("./autogen.distance");
/**
 * Default distance threshold.
 */
exports.DEFAULT_THRESHOLD = 50;
/**
 * Maximum possible distance between two language tags.
 */
exports.MAX_DISTANCE = 100;
var get = function (map, want, have) {
    var sub = map[want];
    return sub === undefined ? undefined : sub[have];
};
var getany = function (map) {
    var sub = map.$;
    /* istanbul ignore else */
    if (sub !== undefined) {
        var node = sub.$;
        /* istanbul ignore else */
        if (node !== undefined) {
            return node;
        }
    }
    /* istanbul ignore next */
    throw new Error('Severe error: wildcard levels missing in distance map.');
};
var _distance = function (node) { return (typeof node === 'number' ? node : node[0]); };
/**
 * Return the distance between the desired and supported locale, stopping once
 * the given threshold is exceeded.
 */
var getDistance = function (desired, supported, threshold) {
    if (typeof threshold !== 'number') {
        threshold = exports.DEFAULT_THRESHOLD;
    }
    // Compare the LANGUAGE subtag.
    var wildcard = false;
    var map = autogen_distance_1.distanceMap;
    var want = desired.language();
    var have = supported.language();
    var node = get(map, want, have);
    if (node === undefined) {
        node = getany(map);
        wildcard = true;
    }
    // Calculate LANGUAGE distance.
    var distance = wildcard ? (want === have ? 0 : _distance(node)) : _distance(node);
    if (distance >= threshold) {
        return exports.MAX_DISTANCE;
    }
    // Move to compare the SCRIPT subtag.
    map = node[1];
    want = desired.script();
    have = supported.script();
    node = get(map, want, have);
    if (node === undefined) {
        node = getany(map);
        wildcard = true;
    }
    else {
        wildcard = false;
    }
    // Update with SCRIPT distance.
    distance += wildcard ? (want === have ? 0 : _distance(node)) : _distance(node);
    if (distance >= threshold) {
        return exports.MAX_DISTANCE;
    }
    // Move to compare the REGION subtag.
    want = desired.region();
    have = supported.region();
    // If regions are equal, we're done.
    if (want === have) {
        return distance;
    }
    var wantPartitions = (0, partition_1.getRegionPartition)(want);
    var havePartitions = (0, partition_1.getRegionPartition)(have);
    map = node[1];
    node = get(map, want, have);
    // There are currently no region -> region distances, so the node
    // be undefined here.
    /* istanbul ignore else */
    if (node === undefined) {
        // Compare the desired region against supported partitions, and vice-versa.
        node = scanRegion(map, want, wantPartitions, have, havePartitions);
    }
    // If we found something, we're done.
    if (node !== undefined) {
        distance += _distance(node);
        return distance < threshold ? distance : exports.MAX_DISTANCE;
    }
    // Find the maximum distance between partitions.
    var maxDistance = 0;
    var match = false;
    // Try permutations of desired and supported partitions to find the maximum distance.
    for (var _i = 0, wantPartitions_1 = wantPartitions; _i < wantPartitions_1.length; _i++) {
        var dpartition = wantPartitions_1[_i];
        for (var _a = 0, havePartitions_1 = havePartitions; _a < havePartitions_1.length; _a++) {
            var spartition = havePartitions_1[_a];
            node = get(map, dpartition, spartition);
            if (node !== undefined) {
                maxDistance = Math.max(maxDistance, _distance(node));
                match = true;
            }
        }
    }
    if (!match) {
        node = getany(map);
        // The 'any' lookup will always succeed here
        /* istanbul ignore else */
        if (node !== undefined) {
            maxDistance = Math.max(maxDistance, _distance(node));
        }
    }
    distance += maxDistance;
    return distance < threshold ? distance : exports.MAX_DISTANCE;
};
exports.getDistance = getDistance;
/**
 * Find the distance between sets of partitions.
 */
var scanRegion = function (map, want, wantPartitions, have, havePartitions) {
    var node = undefined;
    for (var _i = 0, wantPartitions_2 = wantPartitions; _i < wantPartitions_2.length; _i++) {
        var v = wantPartitions_2[_i];
        node = get(map, v, have);
        if (typeof node === 'number') {
            return node;
        }
    }
    for (var _a = 0, havePartitions_2 = havePartitions; _a < havePartitions_2.length; _a++) {
        var v = havePartitions_2[_a];
        node = get(map, want, v);
        if (typeof node === 'number') {
            return node;
        }
    }
    return undefined;
};
//# sourceMappingURL=distance.js.map