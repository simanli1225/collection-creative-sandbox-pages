import { __assign } from "tslib";
import { TimeZoneStableIdIndex } from '../../schema';
import { TZ } from '@phensley/timezone';
import { zoneAliasRaw } from './autogen.aliases';
import { metazoneData } from './autogen.zonedata';
import { numarray, stringToObject } from '../../utils/string';
export var zoneInfoFromUTC = function (zoneid, utc) {
    init();
    var tzinfo = TZ.fromUTC(zoneid, utc);
    if (tzinfo === undefined) {
        tzinfo = TZ.utcZone();
    }
    // For the purposes of CLDR stable timezone ids, check if the passed-in
    // id is an alias to a current/valid tzdb id.
    var isstable = TimeZoneStableIdIndex.get(zoneid) !== -1;
    // Use the passed-in id as the stable id if it is an alias,
    // otherwise lookup the id in the stable map.
    var stableid = isstable ? zoneid : metazones.getStableId(tzinfo.zoneid);
    // Use the corrected zone id to lookup the metazone
    var metazoneid = metazones.getMetazone(tzinfo.zoneid, utc);
    return __assign(__assign({}, tzinfo), { metazoneid: metazoneid || '', stableid: stableid });
};
export var currentMetazone = function (id) { return metazones.getMetazone(id, Number.MAX_SAFE_INTEGER); };
/**
 * Map a given timezone identifier to a CLDR stable timezone id.
 * This is lighter-weight than going through `zoneInfoFromUTC`
 * since it doesn't need to decode the zone data.
 */
export var getStableTimeZoneId = function (zoneid) {
    init();
    // Check if this is already a CLDR stable timezone id.
    var isstable = TimeZoneStableIdIndex.get(zoneid) !== -1;
    if (isstable) {
        return zoneid;
    }
    // Resolve the passed-in string to a real tzdb zone id
    var realid = TZ.resolveId(zoneid);
    if (realid) {
        // Map to a CLDR stable id
        return metazones.getStableId(realid);
    }
    return '';
};
/**
 * Maps a possible timezone alias to the correct id.
 */
export var substituteZoneAlias = function (id) { return timeZoneAliases[id] || id; };
/**
 * Index all metazone information for quick access.
 */
var Metazones = /** @class */ (function () {
    function Metazones(raw) {
        var _this = this;
        this.metazones = [];
        this.zoneToMetazone = new Map();
        this.stableids = new Map();
        this.metazoneids = raw.metazoneids;
        var index = numarray(raw.index, 36);
        var offsets = numarray(raw.offsets, 36);
        var untils = numarray(raw.untils, 36).map(function (n) { return (n === -1 ? n : n * 1000); });
        for (var i = 0; i < index.length; i += 2) {
            var s = index[i];
            var e = index[i + 1];
            var rec = {
                offsets: offsets.slice(s, e),
                untils: untils.slice(s, e),
            };
            this.metazones.push(rec);
        }
        // mapping of zoneid to metazone records
        var zoneids = TZ.zoneIds();
        var zoneindex = numarray(raw.zoneindex, 36);
        // Mapping of tzdb id back to cldr stable id used for schema lookups
        raw.stableids.split('|').forEach(function (d) {
            var p = d.split(':');
            var i = Number(p[0]);
            _this.stableids.set(zoneids[i], p[1]);
        });
        // Sanity-check, since the zoneindex is based off the canonical
        // zoneids array, but could be generated at different times. our test
        // cases should ensure they're in sync, but warn of a discrepancy
        /* istanbul ignore if */
        if (zoneids.length !== zoneindex.length) {
            console.log("Error: time zone ids and zone index are not in sync!");
        }
        for (var i = 0; i < zoneindex.length; i++) {
            var mi = zoneindex[i];
            if (mi !== -1) {
                this.zoneToMetazone.set(zoneids[i], mi);
                this.zoneToMetazone.set(zoneids[i].toLowerCase(), mi);
            }
        }
    }
    Metazones.prototype.getMetazone = function (zoneid, utc) {
        var i = this.zoneToMetazone.get(zoneid);
        if (i !== undefined) {
            var rec = this.metazones[i];
            // Note: we don't bother with binary search here since the metazone
            // until arrays are quite short.
            var offsets = rec.offsets, untils = rec.untils;
            var len = untils.length;
            for (var j = len - 1; j > 0; j--) {
                if (untils[j] <= utc) {
                    return this.metazoneids[offsets[j]];
                }
            }
            // Hit the end, return the initial metazone id
            return this.metazoneids[offsets[0]];
        }
        // This zone has no metazoneid, e.g. "Etc/GMT+1"
        return undefined;
    };
    Metazones.prototype.getStableId = function (zoneid) {
        return this.stableids.get(zoneid) || zoneid;
    };
    return Metazones;
}());
var metazones;
var init = function () {
    if (!metazones) {
        metazones = new Metazones(metazoneData);
    }
};
var zoneAlias = stringToObject(zoneAliasRaw, '|', ':');
/**
 * Hand-built list of extra timezone aliases, for remapping timezone identifiers
 * that currently do not map 1:1 with a CLDR identifier or aliass.
 * reated using backward mapping in tz database v2017b.
 *
 * TODO: revisit to translate tz database aliases automatically and merge with
 * cldr aliases.
 */
export var timeZoneAliases = __assign(__assign({}, zoneAlias), { 'Canada/East-Saskatchewan': 'America/Regina', 'Etc/Unknown': 'Factory' });
//# sourceMappingURL=timezone.js.map