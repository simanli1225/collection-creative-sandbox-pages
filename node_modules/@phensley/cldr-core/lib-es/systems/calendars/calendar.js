import { __assign } from "tslib";
import { dateFields } from './fields';
import { substituteZoneAlias, zoneInfoFromUTC } from './timezone';
import { INTERNAL_NUMBERING } from '../numbering';
import { timePeriodFieldFlags, TIME_PERIOD_FIELDS } from './interval';
var zeropad = function (n, w) { return INTERNAL_NUMBERING.formatString(n, false, w); };
/**
 * Implementation order, based on calendar preference data and ease of implementation.
 * https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/calendarPreferenceData.json
 *
 * Complete:
 *  gregorian           - widely used worldwide
 *  persian             - primary in AF, IR
 *  japanese            - secondary in JP, based on gregorian
 *  iso8601             - based on gregorian
 *  buddhist            - primary in TH
 *
 * Next:
 *  islamic-umalqura    - primary in SA
 *  chinese             - secondary in CN, CX, HK, MO, SG, TW
 *  islamic             - secondary in many locales
 *  dangi               - secondary in KO, based on chinese
 *
 * Rest TBD
 *
 * Calendar calculations are compatible with those in the Unicode ICU project.
 */
// Indicates a null field to support computing on demand
var NULL = Number.MAX_SAFE_INTEGER;
var abs = Math.abs, floor = Math.floor;
var splitfrac = function (n) {
    n = n || 0;
    var t = abs(n);
    var sign = n < 0 ? -1 : 1;
    var r = t | 0;
    return [sign * r, sign * (t - r)];
};
var relativeField = function (p) {
    for (var _i = 0, TIME_PERIOD_FIELDS_1 = TIME_PERIOD_FIELDS; _i < TIME_PERIOD_FIELDS_1.length; _i++) {
        var f = TIME_PERIOD_FIELDS_1[_i];
        if (p[f]) {
            return f;
        }
    }
    return 'millis';
};
var differenceFields = [
    [4 /* DateField.YEAR */, "y" /* DateTimePatternField.YEAR */],
    [7 /* DateField.MONTH */, "M" /* DateTimePatternField.MONTH */],
    [10 /* DateField.DAY_OF_MONTH */, "d" /* DateTimePatternField.DAY */],
    [14 /* DateField.AM_PM */, "a" /* DateTimePatternField.DAYPERIOD */],
    [16 /* DateField.HOUR */, "H" /* DateTimePatternField.HOUR */],
    [17 /* DateField.MINUTE */, "m" /* DateTimePatternField.MINUTE */],
];
/**
 * Base class for dates in supported calendars.
 *
 * @public
 */
var CalendarDate = /** @class */ (function () {
    /**
     * Minimal fields required to construct any calendar date.
     */
    function CalendarDate(_type, _firstDay, _minDays) {
        this._type = _type;
        this._firstDay = _firstDay;
        this._minDays = _minDays;
        this._fields = dateFields();
        // Compute week fields on demand.
        this._fields[6 /* DateField.WEEK_OF_YEAR */] = NULL;
        this._fields[5 /* DateField.YEAR_WOY */] = NULL;
        this._zoneInfo = zoneInfoFromUTC('UTC', 0);
    }
    /**
     * Calendar type for this date, e.g. 'gregory' for Gregorian.
     */
    CalendarDate.prototype.type = function () {
        return this._type;
    };
    /**
     * Returns a formatted ISO-8601 string of the date in UTC. Note that this
     * always returns a date in the Gregorian calendar.
     */
    CalendarDate.prototype.toISOString = function () {
        return this._toISOString(this, true);
    };
    /**
     * Returns a formatted ISO 8601 string of the date with local timezone offset.
     * Note that this always returns a date in the Gregorian calendar.
     */
    CalendarDate.prototype.toLocalISOString = function () {
        return this._toISOString(this, false);
    };
    /**
     * Unix epoch with no timezone offset.
     */
    CalendarDate.prototype.unixEpoch = function () {
        return this._fields[0 /* DateField.LOCAL_MILLIS */] - this._zoneInfo.offset;
    };
    CalendarDate.prototype.firstDayOfWeek = function () {
        return this._firstDay;
    };
    CalendarDate.prototype.minDaysInFirstWeek = function () {
        return this._minDays;
    };
    /**
     * Returns a floating point number representing the real Julian Day, UTC.
     */
    CalendarDate.prototype.julianDay = function () {
        var ms = (this._fields[13 /* DateField.MILLIS_IN_DAY */] - this._zoneInfo.offset) / 86400000 /* CalendarConstants.ONE_DAY_MS */;
        return this._fields[1 /* DateField.JULIAN_DAY */] - 0.5 + ms;
    };
    /**
     * CLDR's modified Julian day used as the basis for all date calculations.
     */
    CalendarDate.prototype.modifiedJulianDay = function () {
        return this._fields[1 /* DateField.JULIAN_DAY */];
    };
    CalendarDate.prototype.era = function () {
        return this._fields[2 /* DateField.ERA */];
    };
    CalendarDate.prototype.extendedYear = function () {
        return this._fields[3 /* DateField.EXTENDED_YEAR */];
    };
    CalendarDate.prototype.year = function () {
        return this._fields[4 /* DateField.YEAR */];
    };
    CalendarDate.prototype.relatedYear = function () {
        return this._fields[3 /* DateField.EXTENDED_YEAR */];
    };
    CalendarDate.prototype.yearOfWeekOfYear = function () {
        this.computeWeekFields();
        return this._fields[5 /* DateField.YEAR_WOY */];
    };
    CalendarDate.prototype.weekOfYear = function () {
        this.computeWeekFields();
        return this._fields[6 /* DateField.WEEK_OF_YEAR */];
    };
    CalendarDate.prototype.yearOfWeekOfYearISO = function () {
        this.computeWeekFields();
        return this._fields[23 /* DateField.ISO_YEAR_WOY */];
    };
    CalendarDate.prototype.weekOfYearISO = function () {
        this.computeWeekFields();
        return this._fields[24 /* DateField.ISO_WEEK_OF_YEAR */];
    };
    /**
     * Ordinal month, one-based, e.g. Gregorian JANUARY = 1.
     */
    CalendarDate.prototype.month = function () {
        return this._fields[7 /* DateField.MONTH */];
    };
    /**
     * Returns the week of the month computed using the locale's 'first day
     * of week' and 'minimal days in first week' where applicable.
     *
     * For example, for the United States, weeks start on Sunday.
     * Saturday 9/1/2018 would be in week 1, and Sunday 9/2/2018 would
     * begin week 2.
     *
     *         September
     *   Su Mo Tu We Th Fr Sa
     *                      1
     *    2  3  4  5  6  7  8
     *    9 10 11 12 13 14 15
     *   16 17 18 19 20 21 22
     *   23 24 25 26 27 28 29
     *   30
     */
    CalendarDate.prototype.weekOfMonth = function () {
        this.computeWeekFields();
        return this._fields[8 /* DateField.WEEK_OF_MONTH */];
    };
    CalendarDate.prototype.dayOfYear = function () {
        return this._fields[9 /* DateField.DAY_OF_YEAR */];
    };
    /**
     * Day of the week. 1 = SUNDAY, 2 = MONDAY, ..., 7 = SATURDAY
     */
    CalendarDate.prototype.dayOfWeek = function () {
        return this._fields[11 /* DateField.DAY_OF_WEEK */];
    };
    /**
     * Ordinal day of the week. 1 if this is the 1st day of the week,
     * 2 if the 2nd, etc. Depends on the local starting day of the week.
     */
    CalendarDate.prototype.ordinalDayOfWeek = function () {
        var weekday = this.dayOfWeek();
        var firstDay = this.firstDayOfWeek();
        return ((7 - firstDay + weekday) % 7) + 1;
    };
    /**
     * Ordinal number indicating the day of the week in the current month.
     * The result of this method can be used to format messages like
     * "2nd Sunday in August".
     */
    CalendarDate.prototype.dayOfWeekInMonth = function () {
        this.computeWeekFields();
        return this._fields[12 /* DateField.DAY_OF_WEEK_IN_MONTH */];
    };
    CalendarDate.prototype.dayOfMonth = function () {
        return this._fields[10 /* DateField.DAY_OF_MONTH */];
    };
    CalendarDate.prototype.isAM = function () {
        return this._fields[14 /* DateField.AM_PM */] === 0;
    };
    /**
     * Indicates the hour of the morning or afternoon, used for the 12-hour
     * clock (0 - 11). Noon and midnight are 0, not 12.
     */
    CalendarDate.prototype.hour = function () {
        return this._fields[16 /* DateField.HOUR */];
    };
    /**
     * Indicates the hour of the day, used for the 24-hour clock (0 - 23).
     * Noon is 12 and midnight is 0.
     */
    CalendarDate.prototype.hourOfDay = function () {
        return this._fields[15 /* DateField.HOUR_OF_DAY */];
    };
    /**
     * Indicates the minute of the hour (0 - 59).
     */
    CalendarDate.prototype.minute = function () {
        return this._fields[17 /* DateField.MINUTE */];
    };
    /**
     * Indicates the second of the minute (0 - 59).
     */
    CalendarDate.prototype.second = function () {
        return this._fields[18 /* DateField.SECOND */];
    };
    CalendarDate.prototype.milliseconds = function () {
        return this._fields[19 /* DateField.MILLIS */];
    };
    CalendarDate.prototype.millisecondsInDay = function () {
        return this._fields[13 /* DateField.MILLIS_IN_DAY */];
    };
    CalendarDate.prototype.metaZoneId = function () {
        return this._zoneInfo.metazoneid;
    };
    CalendarDate.prototype.timeZoneId = function () {
        return this._zoneInfo.zoneid;
    };
    CalendarDate.prototype.timeZoneStableId = function () {
        return this._zoneInfo.stableid;
    };
    CalendarDate.prototype.timeZoneOffset = function () {
        return this._zoneInfo.offset;
    };
    CalendarDate.prototype.isLeapYear = function () {
        return this._fields[21 /* DateField.IS_LEAP */] === 1;
    };
    CalendarDate.prototype.isDaylightSavings = function () {
        return this._zoneInfo.dst === 1;
    };
    /**
     * Computes the field of visual difference between the two dates.
     * Note: This assumes the dates are of the same type and have the same
     * timezone offset.
     */
    CalendarDate.prototype.fieldOfVisualDifference = function (other) {
        var a = this._fields;
        var b = other._fields;
        for (var _i = 0, differenceFields_1 = differenceFields; _i < differenceFields_1.length; _i++) {
            var pair = differenceFields_1[_i];
            var key = pair[0], field = pair[1];
            if (a[key] !== b[key]) {
                return field;
            }
        }
        return "s" /* DateTimePatternField.SECOND */;
    };
    /**
     * Compare two dates a and b, returning:
     *
     * ```
     *   a < b  ->  -1
     *   a = b  ->  0
     *   a > b  ->  1
     * ```
     */
    CalendarDate.prototype.compare = function (other) {
        var a = this.unixEpoch();
        var b = other.unixEpoch();
        return a < b ? -1 : a > b ? 1 : 0;
    };
    /**
     * Calculate the relative time between two dates. If a field is specified
     * the time will be calculated in terms of that single field. Otherwise
     * the field of greatest difference will be used.
     */
    CalendarDate.prototype.relativeTime = function (other, field) {
        var _a = this.swap(other), s = _a[0], sf = _a[1], ef = _a[3];
        var d = this._diff(s, sf, ef);
        var _field = field || relativeField(d);
        var r = this._rollup(d, sf, ef, [_field]);
        return [_field, r[_field] || 0];
    };
    /**
     * Calculate the time period between two dates. Note this returns the
     * absolute value of the difference.
     */
    CalendarDate.prototype.difference = function (other, fields) {
        var _a = this.swap(other), s = _a[0], sf = _a[1], ef = _a[3];
        var d = this._diff(s, sf, ef);
        return fields ? this._rollup(d, sf, ef, fields) : d;
    };
    /**
     * Calculate the time period between two dates. If 'other' is before this date,
     * the time period fields will be negative.
     */
    CalendarDate.prototype.differenceSigned = function (other, fields) {
        var r = this.difference(other, fields);
        return other.compare(this) < 0 ? this._invertPeriod(r) : r;
    };
    /**
     * Return all of the date and time field values.
     */
    CalendarDate.prototype.fields = function () {
        return {
            year: this.extendedYear(),
            month: this.month(),
            day: this.dayOfMonth(),
            hour: this.hourOfDay(),
            minute: this.minute(),
            second: this.second(),
            millis: this.milliseconds(),
            zoneId: this.timeZoneId(),
        };
    };
    /**
     * Return a JavaScript Date object with the same date and time.
     */
    CalendarDate.prototype.asJSDate = function () {
        return new Date(this.toLocalISOString());
    };
    CalendarDate.prototype._toISOString = function (d, utc) {
        d = CalendarDate._gregorian(this, utc, this._firstDay, this._minDays);
        var z = 'Z';
        if (!utc) {
            var o = (this.timeZoneOffset() / 60000 /* CalendarConstants.ONE_MINUTE_MS */) | 0;
            z = "".concat(o < 0 ? '-' : '+').concat(zeropad((o / 60) | 0, 2), ":").concat(zeropad(o % 60 | 0, 2));
        }
        var y = d.extendedYear();
        var neg = y < 0;
        return ("".concat(neg ? '-' : '').concat(zeropad(Math.abs(y), 4), "-").concat(zeropad(d.month(), 2), "-").concat(zeropad(d.dayOfMonth(), 2)) +
            "T".concat(zeropad(d.hourOfDay(), 2), ":").concat(zeropad(d.minute(), 2), ":").concat(zeropad(d.second(), 2)) +
            ".".concat(zeropad(d.milliseconds(), 3)).concat(z));
    };
    /**
     * Rollup just the time fields into number of milliseconds. This is internal
     * and assumes all time fields are defined.
     */
    CalendarDate.prototype._timeToMs = function (f) {
        return (clamp(f.hour || 0, 0, 23) * 3600000 /* CalendarConstants.ONE_HOUR_MS */ +
            clamp(f.minute || 0, 0, 59) * 60000 /* CalendarConstants.ONE_MINUTE_MS */ +
            clamp(f.second || 0, 0, 59) * 1000 /* CalendarConstants.ONE_SECOND_MS */ +
            clamp(f.millis || 0, 0, 999));
    };
    CalendarDate.prototype._invertPeriod = function (fields) {
        var r = {};
        for (var _i = 0, TIME_PERIOD_FIELDS_2 = TIME_PERIOD_FIELDS; _i < TIME_PERIOD_FIELDS_2.length; _i++) {
            var f = TIME_PERIOD_FIELDS_2[_i];
            var v = fields[f];
            r[f] = v ? -v : 0;
        }
        return r;
    };
    /**
     * Roll up time period fields into a subset of fields.
     */
    CalendarDate.prototype._rollup = function (span, sf, ef, fields) {
        var f = timePeriodFieldFlags(fields);
        if (!f) {
            return __assign({ year: 0, month: 0, week: 0, day: 0, hour: 0, minute: 0, second: 0, millis: 0 }, span);
        }
        var mc = this.monthCount();
        var year = span.year || 0;
        var month = span.month || 0;
        var day = (span.week || 0) * 7 + (span.day || 0);
        var ms = (span.hour || 0) * 3600000 /* CalendarConstants.ONE_HOUR_MS */ +
            (span.minute || 0) * 60000 /* CalendarConstants.ONE_MINUTE_MS */ +
            (span.second || 0) * 1000 /* CalendarConstants.ONE_SECOND_MS */ +
            (span.millis || 0);
        if (f & 1 /* TimePeriodFieldFlag.YEAR */ && f & 2 /* TimePeriodFieldFlag.MONTH */) {
            // Both year and month were requested, so use their integer values.
        }
        else if (f & 2 /* TimePeriodFieldFlag.MONTH */) {
            // Month was requested so convert years into months
            month += year * mc;
            year = 0;
        }
        else if (f & 1 /* TimePeriodFieldFlag.YEAR */ && month) {
            // Year was requested so convert months into days
            // This is a little verbose but necessary to accurately convert
            // months into days.  Example:
            //
            //  2001-03-11  and 2001-09-09   5 months and 29 days apart
            //  == (last month days) + (full month days) + (first month days)
            //  == 9 + 31 + 31 + 30 + 31 + 30 + (31 - 11)
            //  == 182 days
            var endy = ef[3 /* DateField.EXTENDED_YEAR */];
            var endm = ef[7 /* DateField.MONTH */] - 1;
            // TODO: create a cursor for year/month calculations to reduce
            // the verbosity of this block
            // Subtract the number of days to find the "day of month"
            // relative to each of the months to be converted.
            var dom = ef[10 /* DateField.DAY_OF_MONTH */] - day;
            if (dom < 0) {
                endm--;
                if (endm < 0) {
                    endm += mc;
                    endy--;
                }
                // const dim = this.daysInMonth(endy, endm);
                dom += this.daysInMonth(endy, endm);
            }
            // Convert each month except the last into days
            var tmpd = dom;
            while (month > 1) {
                endm--;
                if (endm < 0) {
                    endm += mc;
                    endy--;
                }
                tmpd += this.daysInMonth(endy, endm);
                month--;
            }
            // Convert the last month into days
            endm--;
            if (endm < 0) {
                endm += mc;
                endy--;
            }
            tmpd += this.daysInMonth(endy, endm) - dom;
            day += tmpd;
            month = 0;
        }
        else {
            // Neither year nor month were requested, so we ignore those parts
            // of the time period, and re-calculate the days directly from the
            // original date fields.
            day = ef[1 /* DateField.JULIAN_DAY */] - sf[1 /* DateField.JULIAN_DAY */];
            ms = ef[13 /* DateField.MILLIS_IN_DAY */] - sf[13 /* DateField.MILLIS_IN_DAY */];
            if (ms < 0) {
                day--;
                ms += 86400000 /* CalendarConstants.ONE_DAY_MS */;
            }
            year = month = 0;
        }
        // We have integer year, month, and millis computed at this point.
        ms += 86400000 /* CalendarConstants.ONE_DAY_MS */ * day;
        day = 0;
        var onedy = 86400000 /* CalendarConstants.ONE_DAY_MS */;
        var onewk = onedy * 7;
        var onehr = 3600000 /* CalendarConstants.ONE_HOUR_MS */;
        var onemn = 60000 /* CalendarConstants.ONE_MINUTE_MS */;
        var week = 0;
        var hour = 0;
        var minute = 0;
        var second = 0;
        var millis = 0;
        // Roll down
        if (f & 4 /* TimePeriodFieldFlag.WEEK */) {
            week = (ms / onewk) | 0;
            ms -= week * onewk;
        }
        if (f & 8 /* TimePeriodFieldFlag.DAY */) {
            day = (ms / onedy) | 0;
            ms -= day * onedy;
        }
        if (f & 16 /* TimePeriodFieldFlag.HOUR */) {
            hour = (ms / onehr) | 0;
            ms -= hour * onehr;
        }
        if (f & 32 /* TimePeriodFieldFlag.MINUTE */) {
            minute = (ms / onemn) | 0;
            ms -= minute * onemn;
        }
        if (f & 64 /* TimePeriodFieldFlag.SECOND */) {
            second = (ms / 1000) | 0;
            ms -= second * 1000;
        }
        if (f & 128 /* TimePeriodFieldFlag.MILLIS */) {
            millis = ms;
        }
        var dayms = ms / 86400000 /* CalendarConstants.ONE_DAY_MS */;
        // Roll up fractional
        if (f < 2 /* TimePeriodFieldFlag.MONTH */) {
            // Days in the last year before adding the remaining fields
            var diy = this.daysInYear(sf[3 /* DateField.EXTENDED_YEAR */] + year);
            year += (day + dayms) / diy;
            day = 0;
        }
        else if (f < 4 /* TimePeriodFieldFlag.WEEK */) {
            var ey = ef[4 /* DateField.YEAR */];
            var em = ef[7 /* DateField.MONTH */] - 2;
            if (em < 0) {
                em += mc;
                ey--;
            }
            var dim = this.daysInMonth(ey, em);
            month += (day + dayms) / dim;
        }
        else if (f < 8 /* TimePeriodFieldFlag.DAY */) {
            week += (day + dayms) / 7;
        }
        else if (f < 16 /* TimePeriodFieldFlag.HOUR */) {
            day += dayms;
        }
        else if (f < 32 /* TimePeriodFieldFlag.MINUTE */) {
            hour += ms / onehr;
        }
        else if (f < 64 /* TimePeriodFieldFlag.SECOND */) {
            minute += ms / onemn;
        }
        else if (f < 128 /* TimePeriodFieldFlag.MILLIS */) {
            second += ms / 1000;
        }
        return {
            year: year,
            month: month,
            week: week,
            day: day,
            hour: hour,
            minute: minute,
            second: second,
            millis: millis,
        };
    };
    /**
     * Compute the number of years, months, days, etc, between two dates. The result will
     * have all fields as integers.
     */
    CalendarDate.prototype._diff = function (s, sf, ef) {
        // Use a borrow-based method to compute fields. If a field X is negative, we borrow
        // from the next-higher field until X is positive. Repeat until all fields are
        // positive.
        var millis = ef[13 /* DateField.MILLIS_IN_DAY */] - sf[13 /* DateField.MILLIS_IN_DAY */];
        var day = ef[10 /* DateField.DAY_OF_MONTH */] - sf[10 /* DateField.DAY_OF_MONTH */];
        var month = ef[7 /* DateField.MONTH */] - sf[7 /* DateField.MONTH */];
        var year = ef[3 /* DateField.EXTENDED_YEAR */] - sf[3 /* DateField.EXTENDED_YEAR */];
        // Convert days into milliseconds
        if (millis < 0) {
            millis += 86400000 /* CalendarConstants.ONE_DAY_MS */;
            day--;
        }
        // Convert months into days
        // This is a little more complex since months can have 28, 29 30 or 31 days.
        // We work backwards from the current month and successively convert months
        // into days until days are positive.
        var mc = s.monthCount();
        var m = ef[7 /* DateField.MONTH */] - 1; // convert to 0-based month
        var y = ef[3 /* DateField.EXTENDED_YEAR */];
        while (day < 0) {
            // move to previous month
            m--;
            // add back the number of days in the current month, wrapping around to December
            if (m < 0) {
                m += mc;
                y--;
            }
            var dim = this.daysInMonth(y, m);
            day += dim;
            month--;
        }
        // Convert years into months
        if (month < 0) {
            month += mc;
            year--;
        }
        // Convert days to weeks
        var week = day > 0 ? (day / 7) | 0 : 0;
        if (week > 0) {
            day -= week * 7;
        }
        // Break down milliseconds into components
        var hour = (millis / 3600000 /* CalendarConstants.ONE_HOUR_MS */) | 0;
        millis -= hour * 3600000 /* CalendarConstants.ONE_HOUR_MS */;
        var minute = (millis / 60000 /* CalendarConstants.ONE_MINUTE_MS */) | 0;
        millis -= minute * 60000 /* CalendarConstants.ONE_MINUTE_MS */;
        var second = (millis / 1000 /* CalendarConstants.ONE_SECOND_MS */) | 0;
        millis -= second * 1000 /* CalendarConstants.ONE_SECOND_MS */;
        return {
            year: year,
            month: month,
            week: week,
            day: day,
            hour: hour,
            minute: minute,
            second: second,
            millis: millis,
        };
    };
    CalendarDate.prototype.swap = function (other) {
        var _a;
        var s = this;
        var e = other;
        // Swap start/end dates
        if (this.compare(other) === 1) {
            _a = [e, s], s = _a[0], e = _a[1];
        }
        // Convert start and end to UTC and ensure both are of the same calendar type.
        // We do this using lower-level logic since the CalendarDate base class currently
        // cannot construct instances of subclasses.
        return [s, s.utcfields(), e, e.utcfields()];
    };
    /**
     * Compute a new Julian day and milliseconds UTC by updating one or more fields.
     */
    CalendarDate.prototype._add = function (fields) {
        var _a, _b, _c, _d, _e;
        var f = this.utcfields();
        var jd;
        var ms;
        var year;
        var yearf;
        var ydays;
        var ydaysf;
        var month;
        var monthf;
        var day;
        var dayf;
        var _days;
        var _ms;
        // Capture days and time fields (in milliseconds) for future use.
        // We do this here since we'll be re-initializing the date fields
        // below.
        _a = this._addTime(fields), _days = _a[0], _ms = _a[1];
        _days += (fields.day || 0) + (fields.week || 0) * 7;
        // YEARS
        // Split off the fractional part of the years. Add the integer
        // years to the extended year. Then get the number of days in that
        // year and multiply that by the fractional part.
        // Example: In a Gregorian leap year we'll have 366 days. If the fractional
        // year is 0.25 we'll get 91.5 days.
        _b = splitfrac(fields.year), year = _b[0], yearf = _b[1];
        year += f[3 /* DateField.EXTENDED_YEAR */];
        _c = splitfrac(this.daysInYear(year) * yearf), ydays = _c[0], ydaysf = _c[1];
        // Add day fractions from year calculation to milliseconds
        ms = ydaysf * 86400000 /* CalendarConstants.ONE_DAY_MS */;
        // Calculate the julian day for the year, month and day-of-month combination,
        // adding in the days due to fractional year
        jd = this.monthStart(year, f[7 /* DateField.MONTH */] - 1, false) + f[10 /* DateField.DAY_OF_MONTH */] + ydays;
        // Initialize fields from the julian day
        f[1 /* DateField.JULIAN_DAY */] = jd;
        f[13 /* DateField.MILLIS_IN_DAY */] = 0;
        this.initFields(f);
        year = f[3 /* DateField.EXTENDED_YEAR */];
        // MONTHS
        // Get integer and fractional months
        month = fields.month || 0;
        _d = splitfrac(f[7 /* DateField.MONTH */] - 1 + month), month = _d[0], monthf = _d[1];
        // Add back years by dividing by month count
        var mc = this.monthCount();
        var myears = splitfrac(month / 12)[0]; // ignore fraction here
        month -= myears * mc;
        year += myears;
        // Take away a year if the month pointer went negative
        if (month < 0) {
            month += mc;
            year--;
        }
        // Compute updated julian day from year and fractional month
        var dim = this.daysInMonth(year, month) * monthf;
        _e = splitfrac(_days + dim), day = _e[0], dayf = _e[1];
        jd = this.monthStart(year, month, false) + f[10 /* DateField.DAY_OF_MONTH */];
        // DAY AND TIME FIELDS
        // Adjust julian day by fractional day and time fields
        ms += Math.round(_ms + dayf * 86400000 /* CalendarConstants.ONE_DAY_MS */);
        if (ms >= 86400000 /* CalendarConstants.ONE_DAY_MS */) {
            var d = floor(ms / 86400000 /* CalendarConstants.ONE_DAY_MS */);
            ms -= d * 86400000 /* CalendarConstants.ONE_DAY_MS */;
            day += d;
        }
        return [jd + day, ms];
    };
    /**
     * Converts all time fields into [days, milliseconds].
     */
    CalendarDate.prototype._addTime = function (fields) {
        // Calculate the time difference in days and milliseconds
        var msDay = this._fields[13 /* DateField.MILLIS_IN_DAY */] - this.timeZoneOffset();
        msDay +=
            (fields.hour || 0) * 3600000 /* CalendarConstants.ONE_HOUR_MS */ +
                (fields.minute || 0) * 60000 /* CalendarConstants.ONE_MINUTE_MS */ +
                (fields.second || 0) * 1000 /* CalendarConstants.ONE_SECOND_MS */ +
                (fields.millis || 0);
        var oneDay = 86400000 /* CalendarConstants.ONE_DAY_MS */;
        var days = floor(msDay / oneDay);
        var ms = msDay - days * oneDay;
        return [days, ms];
    };
    CalendarDate.prototype.initFromUnixEpoch = function (ms, zoneId) {
        zoneId = substituteZoneAlias(zoneId);
        this._zoneInfo = zoneInfoFromUTC(zoneId, ms);
        jdFromUnixEpoch(ms + this._zoneInfo.offset, this._fields);
        computeBaseFields(this._fields);
    };
    CalendarDate.prototype.initFromJD = function (jd, msDay, zoneId) {
        var unixEpoch = unixEpochFromJD(jd, msDay);
        this.initFromUnixEpoch(unixEpoch, zoneId);
    };
    CalendarDate.prototype._toString = function (type) {
        var y = this.extendedYear();
        var neg = y < 0;
        return ("".concat(type, " ").concat(neg ? '-' : '').concat(zeropad(Math.abs(y), 4)) +
            "-".concat(zeropad(this.month(), 2), "-").concat(zeropad(this.dayOfMonth(), 2), " ") +
            "".concat(zeropad(this.hourOfDay(), 2), ":").concat(zeropad(this.minute(), 2), ":").concat(zeropad(this.second(), 2)) +
            ".".concat(zeropad(this.milliseconds(), 3), " ").concat(this._zoneInfo.zoneid));
    };
    /**
     * Compute WEEK_OF_YEAR and YEAR_WOY on demand.
     */
    CalendarDate.prototype.computeWeekFields = function () {
        var f = this._fields;
        if (f[5 /* DateField.YEAR_WOY */] !== NULL) {
            return;
        }
        var dow = f[11 /* DateField.DAY_OF_WEEK */];
        var dom = f[10 /* DateField.DAY_OF_MONTH */];
        var doy = f[9 /* DateField.DAY_OF_YEAR */];
        f[8 /* DateField.WEEK_OF_MONTH */] = this.weekNumber(this._firstDay, this._minDays, dom, dom, dow);
        f[12 /* DateField.DAY_OF_WEEK_IN_MONTH */] = (((dom - 1) / 7) | 0) + 1;
        // compute locale
        this._computeWeekFields(6 /* DateField.WEEK_OF_YEAR */, 5 /* DateField.YEAR_WOY */, this._firstDay, this._minDays, dow, dom, doy);
        // compute ISO
        this._computeWeekFields(24 /* DateField.ISO_WEEK_OF_YEAR */, 23 /* DateField.ISO_YEAR_WOY */, 2, 4, dow, dom, doy);
    };
    CalendarDate.prototype._computeWeekFields = function (woyfield, ywoyfield, firstDay, minDays, dow, _dom, doy) {
        var f = this._fields;
        var eyear = f[3 /* DateField.EXTENDED_YEAR */];
        var ywoy = eyear;
        var rdow = (dow + 7 - firstDay) % 7;
        var rdowJan1 = (dow - doy + 7001 - firstDay) % 7;
        var woy = floor((doy - 1 + rdowJan1) / 7);
        if (7 - rdowJan1 >= minDays) {
            woy++;
        }
        if (woy === 0) {
            var prevDay = doy + this.yearLength(eyear - 1);
            woy = this.weekNumber(firstDay, minDays, prevDay, prevDay, dow);
            ywoy--;
        }
        else {
            var lastDoy = this.yearLength(eyear);
            if (doy >= lastDoy - 5) {
                var lastRdow = (rdow + lastDoy - doy) % 7;
                if (lastRdow < 0) {
                    lastRdow += 7;
                }
                if (6 - lastRdow >= minDays && doy + 7 - rdow > lastDoy) {
                    woy = 1;
                    ywoy++;
                }
            }
        }
        f[woyfield] = woy;
        f[ywoyfield] = ywoy;
    };
    CalendarDate.prototype.yearLength = function (y) {
        return this.monthStart(y + 1, 0, false) - this.monthStart(y, 0, false);
    };
    CalendarDate.prototype.weekNumber = function (firstDay, minDays, desiredDay, dayOfPeriod, dayOfWeek) {
        var psow = (dayOfWeek - firstDay - dayOfPeriod + 1) % 7;
        if (psow < 0) {
            psow += 7;
        }
        var weekNo = floor((desiredDay + psow - 1) / 7);
        return 7 - psow >= minDays ? weekNo + 1 : weekNo;
    };
    CalendarDate.prototype.utcfields = function () {
        var u = this.unixEpoch();
        var f = this._fields.slice(0);
        jdFromUnixEpoch(u, f);
        computeBaseFields(f);
        this.initFields(f);
        return f;
    };
    return CalendarDate;
}());
export { CalendarDate };
var clamp = function (n, min, max) { return Math.max(Math.min(n, max), min) | 0; };
/**
 * Compute Julian day from timezone-adjusted Unix epoch milliseconds.
 */
var jdFromUnixEpoch = function (ms, f) {
    var oneDayMS = 86400000 /* CalendarConstants.ONE_DAY_MS */;
    var days = floor(ms / oneDayMS);
    var jd = days + 2440588 /* CalendarConstants.JD_UNIX_EPOCH */;
    var msDay = floor(ms - days * oneDayMS);
    f[1 /* DateField.JULIAN_DAY */] = jd;
    f[13 /* DateField.MILLIS_IN_DAY */] = msDay;
};
/**
 * Compute fields common to all calendars. Before calling this, we must
 * have the JULIAN_DAY and MILLIS_IN_DAY fields set. Every calculation
 * is relative to these.
 */
var computeBaseFields = function (f) {
    var jd = clamp(f[1 /* DateField.JULIAN_DAY */], 0 /* CalendarConstants.JD_MIN */, 4881503 /* CalendarConstants.JD_MAX */);
    // checkJDRange(jd);
    var msDay = f[13 /* DateField.MILLIS_IN_DAY */];
    var ms = msDay + (jd - 2440588 /* CalendarConstants.JD_UNIX_EPOCH */) * 86400000 /* CalendarConstants.ONE_DAY_MS */;
    f[0 /* DateField.LOCAL_MILLIS */] = ms;
    f[1 /* DateField.JULIAN_DAY */] = jd;
    f[13 /* DateField.MILLIS_IN_DAY */] = msDay;
    f[19 /* DateField.MILLIS */] = msDay % 1000;
    msDay = (msDay / 1000) | 0;
    f[18 /* DateField.SECOND */] = msDay % 60;
    msDay = (msDay / 60) | 0;
    f[17 /* DateField.MINUTE */] = msDay % 60;
    msDay = (msDay / 60) | 0;
    f[15 /* DateField.HOUR_OF_DAY */] = msDay;
    f[14 /* DateField.AM_PM */] = (msDay / 12) | 0;
    f[16 /* DateField.HOUR */] = msDay % 12;
    var dow = (jd + 2 /* DayOfWeek.MONDAY */) % 7;
    if (dow < 1 /* DayOfWeek.SUNDAY */) {
        dow += 7;
    }
    f[11 /* DateField.DAY_OF_WEEK */] = dow;
};
// TODO: clamp range instead of throwing error.
// const checkJDRange = (jd: number): void => {
//   if (jd < CalendarConstants.JD_MIN || jd > CalendarConstants.JD_MAX) {
//     throw new Error(
//       `Julian day ${jd} is outside the supported range of this library: ` +
//         `${ConstantsDesc.JD_MIN} to ${ConstantsDesc.JD_MAX}`,
//     );
//   }
// };
/**
 * Given a Julian day and local milliseconds (in UTC), return the Unix
 * epoch milliseconds UTC.
 */
var unixEpochFromJD = function (jd, msDay) {
    var days = jd - 2440588 /* CalendarConstants.JD_UNIX_EPOCH */;
    return days * 86400000 /* CalendarConstants.ONE_DAY_MS */ + Math.round(msDay);
};
//# sourceMappingURL=calendar.js.map