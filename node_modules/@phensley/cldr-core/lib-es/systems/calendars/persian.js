import { __assign, __extends } from "tslib";
import { CalendarDate } from './calendar';
import { floorDiv } from './utils';
/**
 * Construct a date using the rules of the Persian calendar.
 *
 * type: persian
 *
 * @public
 */
var PersianDate = /** @class */ (function (_super) {
    __extends(PersianDate, _super);
    function PersianDate(firstDay, minDays) {
        return _super.call(this, 'persian', firstDay, minDays) || this;
    }
    PersianDate.prototype.relatedYear = function () {
        return this._fields[3 /* DateField.EXTENDED_YEAR */] + 622;
    };
    PersianDate.prototype.set = function (fields) {
        var f = __assign(__assign({}, this.fields()), fields);
        var jd = this._ymdToJD(f.year, f.month, f.day);
        var ms = this._timeToMs(f) - this.timeZoneOffset();
        return this._new().initFromJD(jd, ms, this.timeZoneId());
    };
    PersianDate.prototype.add = function (fields) {
        var _a = this._add(fields), jd = _a[0], ms = _a[1];
        return this._new().initFromJD(jd, ms, this.timeZoneId());
    };
    PersianDate.prototype.subtract = function (fields) {
        return this.add(this._invertPeriod(fields));
    };
    PersianDate.prototype.withZone = function (zoneId) {
        return this._new().initFromUnixEpoch(this.unixEpoch(), zoneId);
    };
    PersianDate.prototype.toString = function () {
        return this._toString('Persian');
    };
    PersianDate.fromFields = function (fields, firstDay, minDays) {
        return new PersianDate(firstDay, minDays).set(__assign({ year: 1, month: 1, day: 1 }, fields));
    };
    PersianDate.fromUnixEpoch = function (epoch, zoneId, firstDay, minDays) {
        return new PersianDate(firstDay, minDays).initFromUnixEpoch(epoch, zoneId);
    };
    PersianDate.prototype._new = function () {
        return new PersianDate(this._firstDay, this._minDays);
    };
    PersianDate.prototype.initFromUnixEpoch = function (epoch, zoneId) {
        _super.prototype.initFromUnixEpoch.call(this, epoch, zoneId);
        computePersianFields(this._fields);
        return this;
    };
    PersianDate.prototype.initFromJD = function (jd, msDay, zoneId) {
        _super.prototype.initFromJD.call(this, jd, msDay, zoneId);
        computePersianFields(this._fields);
        return this;
    };
    PersianDate.prototype.initFields = function (f) {
        computePersianFields(f);
    };
    PersianDate.prototype.monthCount = function () {
        return 12;
    };
    PersianDate.prototype.daysInMonth = function (y, m) {
        return MONTH_COUNT[m][leapPersian(y) ? 1 : 0];
    };
    PersianDate.prototype.daysInYear = function (y) {
        return leapPersian(y) ? 366 : 365;
    };
    PersianDate.prototype.monthStart = function (eyear, month, _useMonth) {
        var jd = 1948320 /* CalendarConstants.JD_PERSIAN_EPOCH */ - 1 + 365 * (eyear - 1) + floor((8 * eyear + 21) / 33);
        if (month !== 0) {
            var mc = MONTH_COUNT;
            var m = floor(month);
            var d = month - m;
            jd += mc[m][2];
            // TODO: we never reach the block below since all internal uses of monthStart
            // pass in an integer
            // Check if there is a fractional month part, and if so add the number
            // of the days in the next month multiplied by the fraction
            /* istanbul ignore if */
            if (d !== 0) {
                // number of days in Esfand determined by:
                // "number of days between two vernal equinoxes"
                var isLeap = leapPersian(eyear);
                // note: the 'month' parameter must always be <= # months in the calendar
                // year, so <= 12 in this case.
                jd += d * mc[m + 1][isLeap ? 1 : 0];
            }
        }
        return jd;
    };
    PersianDate.prototype._ymdToJD = function (y, m, d) {
        y |= 0;
        var leap = leapPersian(y);
        var mc = this.monthCount();
        m = m < 1 ? 1 : m > mc ? mc : m;
        var dc = MONTH_COUNT[m - 1][leap ? 1 : 0];
        d = d < 1 ? 1 : d > dc ? dc : d;
        var favardin1 = 365 * (y - 1) + floor((8 * y + 21) / 33);
        var mdays = MONTH_COUNT[m - 1][2];
        var days = favardin1 + d + mdays - 1;
        return days + 1948320 /* CalendarConstants.JD_PERSIAN_EPOCH */;
    };
    return PersianDate;
}(CalendarDate));
export { PersianDate };
var floor = Math.floor;
var MONTH_COUNT = [
    [31, 31, 0], // Farvardin
    [31, 31, 31], // Ordibehesht
    [31, 31, 62], // Khordad
    [31, 31, 93], // Tir
    [31, 31, 124], // Mordad
    [31, 31, 155], // Shahrivar
    [30, 30, 186], // Mehr
    [30, 30, 216], // Aban
    [30, 30, 246], // Azar
    [30, 30, 276], // Dey
    [30, 30, 306], // Bahman
    [29, 30, 336], // Esfand
];
var computePersianFields = function (f) {
    var jd = f[1 /* DateField.JULIAN_DAY */];
    var days = jd - 1948320 /* CalendarConstants.JD_PERSIAN_EPOCH */;
    var year = 1 + floor((33 * days + 3) / 12053);
    var favardin1 = 365 * (year - 1) + floor((8 * year + 21) / 33);
    var doy = days - favardin1;
    var month = floor(doy < 216 ? doy / 31 : (doy - 6) / 30);
    var dom = doy - MONTH_COUNT[month][2] + 1;
    f[2 /* DateField.ERA */] = 0;
    f[4 /* DateField.YEAR */] = year;
    f[3 /* DateField.EXTENDED_YEAR */] = year;
    f[7 /* DateField.MONTH */] = month + 1;
    f[10 /* DateField.DAY_OF_MONTH */] = dom;
    f[9 /* DateField.DAY_OF_YEAR */] = doy + 1;
    f[21 /* DateField.IS_LEAP */] = leapPersian(year) ? 1 : 0;
};
/**
 * Return true if the given year is a leap year in the Persian calendar; false otherwise;
 */
var leapPersian = function (y) {
    var rem = [0];
    floorDiv(25 * y + 11, 33, rem);
    return rem[0] < 8;
};
//# sourceMappingURL=persian.js.map