import { LRU } from '@phensley/cldr-utils';
import { CalendarsImpl, GeneralImpl, NumbersImpl, PrivateApiImpl, UnitsImpl, } from './api';
import { InternalsImpl } from './internals';
import { availableLocales } from './locale';
import { parseLanguageTag } from '@phensley/language-tag';
import { LanguageResolver } from '@phensley/locale';
import { Pack } from './resource';
import { VERSION } from './utils/version';
/**
 * Implements CLDR
 *
 * @public
 */
var CLDRImpl = /** @class */ (function () {
    function CLDRImpl(locale, bundle, internals) {
        this.locale = locale;
        this.bundle = bundle;
        this.internals = internals;
    }
    Object.defineProperty(CLDRImpl.prototype, "Calendars", {
        /**
         * Calendar functions.
         */
        get: function () {
            if (this._calendars === undefined) {
                this._calendars = new CalendarsImpl(this.bundle, this.internals, this.privateApi);
            }
            return this._calendars;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "General", {
        /**
         * General functions.
         */
        get: function () {
            if (this._general === undefined) {
                this._general = new GeneralImpl(this.bundle, this.locale, this.internals, this.privateApi);
            }
            return this._general;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Numbers", {
        /**
         * Number and currency functions.
         */
        get: function () {
            if (this._numbers === undefined) {
                this._numbers = new NumbersImpl(this.bundle, this.internals.numbers, this.internals.general, this.privateApi);
            }
            return this._numbers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Units", {
        /**
         * Unit quantity functions.
         */
        get: function () {
            if (this._units === undefined) {
                this._units = new UnitsImpl(this.bundle, this.internals, this.privateApi);
            }
            return this._units;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Schema", {
        /**
         * UNDOCUMENTED AND EXPERIMENTAL
         *
         * Provides access to the low-level schema for accessing CLDR fields.
         *
         * Currently undocumented. In the future an internal api can be
         * exposed allowing access to low-level functions of the library.
         *
         * @internal
         */
        get: function () {
            return this.internals.schema;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Internals", {
        /**
         * UNDOCUMENTED AND EXPERIMENTAL
         *
         * Provides access to the low-level library internals.
         *
         * @internal
         */
        get: function () {
            return this.internals;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "privateApi", {
        get: function () {
            if (this._privateApi === undefined) {
                this._privateApi = new PrivateApiImpl(this.bundle, this.internals);
            }
            return this._privateApi;
        },
        enumerable: false,
        configurable: true
    });
    return CLDRImpl;
}());
var EMPTY_CONFIG = {};
/**
 * Top-level entry point for the library. It's only purpose at the
 * moment is to construct API instances for a particular locale.
 * All other functionality should be available statically through
 * exported types and functions.
 *
 * @public
 */
var CLDRFramework = /** @class */ (function () {
    function CLDRFramework(options) {
        this.options = options;
        this.packCache = new LRU(options.packCacheSize || 2);
        this.loader = options.loader;
        this.asyncLoader = options.asyncLoader;
        this._config = options.config || CLDRFramework.defaultConfig || EMPTY_CONFIG;
        var patternCacheSize = options.patternCacheSize || 200;
        this.internals = new InternalsImpl(this._config, VERSION, options.debug, options.skipChecksum, patternCacheSize);
    }
    /**
     * Specify a configuration to use as a fallback.
     */
    CLDRFramework.setDefaultConfig = function (config) {
        this.defaultConfig = config;
    };
    CLDRFramework.prototype.config = function () {
        return this._config;
    };
    CLDRFramework.prototype.info = function () {
        return "packs loaded: ".concat(this.packCache.size());
    };
    /**
     * Return the library version.
     */
    CLDRFramework.version = function () {
        return VERSION;
    };
    /**
     * Return an array of the available locales.
     */
    CLDRFramework.availableLocales = function () {
        return availableLocales();
    };
    /**
     * Parse a locale identifier and resolve it. This returns a Locale object
     * that includes the original id string or tag's compact form, and
     * a resolved LanguageTag.
     */
    CLDRFramework.resolveLocale = function (id) {
        var _id = typeof id === 'string' ? id : id.compact();
        var tag = LanguageResolver.resolve(id);
        return { id: _id, tag: tag };
    };
    /**
     * Parses a string into a BCP47 language tag
     */
    CLDRFramework.parseLanguageTag = function (s) {
        return parseLanguageTag(s);
    };
    /**
     * Synchronously load a bundle and construct an instance of an API for
     * a given locale. Mainly used when you want to load a language statically
     * when your application's state store is initialized.
     */
    CLDRFramework.prototype.get = function (locale) {
        must(this.loader, "A synchronous resource loader is not defined" /* Messages.NO_SYNC_LOADER */);
        must(locale, "The \"locale\" argument is undefined" /* Messages.LOCALE_UNDEFINED */);
        var resolved = typeof locale === 'string' ? CLDRFramework.resolveLocale(locale) : locale;
        var language = resolved.tag.language();
        var pack = this.packCache.get(language);
        if (pack === undefined) {
            var data = this.loader(language);
            pack = new Pack(data);
            this.check(pack);
            this.packCache.set(language, pack);
        }
        return this.build(resolved, pack);
    };
    /**
     * Asynchronously load a bundle and construct an instance of an API for
     * a given locale.
     */
    CLDRFramework.prototype.getAsync = function (locale) {
        var _this = this;
        must(this.asyncLoader, "A Promise-based resource loader is not defined" /* Messages.NO_ASYNC_LOADER */);
        must(locale, "The \"locale\" argument is undefined" /* Messages.LOCALE_UNDEFINED */);
        var resolved = typeof locale === 'string' ? CLDRFramework.resolveLocale(locale) : locale;
        var language = resolved.tag.language();
        var promise = new Promise(function (resolve, reject) {
            var pack = _this.packCache.get(language);
            if (pack !== undefined) {
                resolve(_this.build(resolved, pack));
                return;
            }
            // Resolve via the promise loader
            _this.asyncLoader(language)
                .then(function (raw) {
                var _pack = new Pack(raw);
                _this.check(_pack);
                _this.packCache.set(language, _pack);
                resolve(_this.build(resolved, _pack));
            })
                .catch(reject);
        });
        return promise;
    };
    /**
     * Builds an API instance.
     */
    CLDRFramework.prototype.build = function (locale, pack) {
        var bundle = pack.get(locale.tag);
        return new CLDRImpl(locale, bundle, this.internals);
    };
    /**
     * Verify the resource pack is compatible with the schema config checksum.
     */
    CLDRFramework.prototype.check = function (pack) {
        if (!this.options.skipChecksum && pack.checksum !== this.internals.checksum) {
            throw new Error("Checksum mismatch on resource pack! The schema config used to generate the resource pack must be identical to the one used at runtime." /* Messages.CHECKSUM */);
        }
    };
    return CLDRFramework;
}());
export { CLDRFramework };
var must = function (arg, message) {
    if (arg === undefined) {
        throw new Error(message);
    }
};
//# sourceMappingURL=cldr.js.map