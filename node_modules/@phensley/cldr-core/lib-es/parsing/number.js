var MINUS_NODE = [0 /* NumberField.MINUS */];
var newPattern = function () { return ({ nodes: [], minInt: 0, maxFrac: 0, minFrac: 0, priGroup: 0, secGroup: 0 }); };
var NumberPatternParser = /** @class */ (function () {
    function NumberPatternParser() {
        this.curr = newPattern();
        this.buf = '';
        this.attached = false;
    }
    NumberPatternParser.prototype.parse = function (raw) {
        var len = raw.length;
        var save;
        var curr = this.curr;
        var ingroup = false;
        var indecimal = false;
        var i = 0;
        outer: while (i < len) {
            var ch = raw[i];
            switch (ch) {
                case "'":
                    while (i++ < len) {
                        ch = raw[i];
                        if (ch === "'") {
                            break;
                        }
                        this.buf += ch;
                    }
                    break;
                case ';':
                    // If we encounter more than one pattern separator, bail out
                    if (save) {
                        break outer;
                    }
                    this.pushText();
                    // Save current pattern and start parsing a new one
                    save = curr;
                    curr = newPattern();
                    this.curr = curr;
                    // Reset state for next parse
                    indecimal = false;
                    ingroup = false;
                    this.attached = false;
                    break;
                case '-':
                    this.pushText();
                    curr.nodes.push(0 /* NumberField.MINUS */);
                    break;
                case '%':
                    this.pushText();
                    curr.nodes.push(1 /* NumberField.PERCENT */);
                    break;
                case '\u00a4':
                    this.pushText();
                    curr.nodes.push(2 /* NumberField.CURRENCY */);
                    break;
                case 'E':
                    this.pushText();
                    curr.nodes.push(4 /* NumberField.EXPONENT */);
                    break;
                case '+':
                    this.pushText();
                    curr.nodes.push(5 /* NumberField.PLUS */);
                    break;
                case '#':
                    this.attach();
                    if (ingroup) {
                        curr.priGroup++;
                    }
                    else if (indecimal) {
                        curr.maxFrac++;
                    }
                    break;
                case ',':
                    this.attach();
                    if (ingroup) {
                        curr.secGroup = curr.priGroup;
                        curr.priGroup = 0;
                    }
                    else {
                        ingroup = true;
                    }
                    break;
                case '.':
                    ingroup = false;
                    this.attach();
                    indecimal = true;
                    break;
                case '0':
                    this.attach();
                    if (ingroup) {
                        curr.priGroup++;
                    }
                    else if (indecimal) {
                        curr.maxFrac++;
                        curr.minFrac++;
                    }
                    if (!indecimal) {
                        curr.minInt++;
                    }
                    break;
                default:
                    this.buf += ch;
                    break;
            }
            i++;
        }
        this.pushText();
        if (save === undefined) {
            // Derive positive from negative by prepending a minus node
            var nodes = curr.nodes, minInt = curr.minInt, maxFrac = curr.maxFrac, minFrac = curr.minFrac, priGroup = curr.priGroup, secGroup = curr.secGroup;
            save = curr;
            curr = { nodes: MINUS_NODE.concat(nodes.slice(0)), minInt: minInt, maxFrac: maxFrac, minFrac: minFrac, priGroup: priGroup, secGroup: secGroup };
        }
        return [save, curr];
    };
    NumberPatternParser.prototype.attach = function () {
        this.pushText();
        if (!this.attached) {
            this.curr.nodes.push(3 /* NumberField.NUMBER */);
            this.attached = true;
        }
    };
    NumberPatternParser.prototype.pushText = function () {
        if (this.buf.length > 0) {
            this.curr.nodes.push(this.buf);
            this.buf = '';
        }
    };
    return NumberPatternParser;
}());
export var parseNumberPattern = function (raw) { return new NumberPatternParser().parse(raw); };
//# sourceMappingURL=number.js.map