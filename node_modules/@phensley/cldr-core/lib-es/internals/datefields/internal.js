import { coerceDecimal, DecimalConstants } from '@phensley/decimal';
// TODO: expose a method to calculate field difference with different options, e.g.
// include weekdays
/**
 * @internal
 */
var DateFieldInternalsImpl = /** @class */ (function () {
    function DateFieldInternalsImpl(internals) {
        this.internals = internals;
        this.relativeTimes = internals.schema.DateFields.relativeTimes;
    }
    // formatRelativeTime(bundle: Bundle, start: CalendarDate, end: CalendarDate,
    // options: RelativeTimeFormatOptions, params: NumberParams): string {
    // TODO: need to compute integral difference for multiple fields. for example, year
    // may differ between 2017-12-01 and 2018-02-02 but they are only 3 months apart, so
    // we might format "3 months" or "9 weeks" or "9 Fridays" or "63 days".
    // return '';
    // }
    DateFieldInternalsImpl.prototype.formatRelativeTimeField = function (bundle, value, field, options, params, transform) {
        var width = options.width || 'wide';
        var format = this.relativeTimes[width] || this.relativeTimes.wide;
        var group = options.group === undefined ? true : options.group;
        var n = coerceDecimal(value);
        n = this.internals.numbers.adjustDecimal(n, options);
        var negative = n.isNegative();
        if (negative) {
            n = n.negate();
        }
        var iszero = n.compare(DecimalConstants.ZERO) === 0;
        var res = '';
        if (iszero) {
            if (options.alwaysNow || !options.numericOnly) {
                res = format.current.get(bundle, field);
            }
        }
        else if (!options.numericOnly) {
            switch (field) {
                case 'hour':
                case 'minute':
                case 'second':
                    break;
                default:
                    if (n.compare(DecimalConstants.TWO) === 0) {
                        var p = negative ? format.previous2.get(bundle, field) : format.next2.get(bundle, field);
                        if (p !== '') {
                            res = p;
                        }
                        // Fall through
                    }
                    else if (n.compare(DecimalConstants.ONE) === 0) {
                        res = negative ? format.previous.get(bundle, field) : format.next.get(bundle, field);
                    }
                    break;
            }
        }
        // If we output anything above, return it
        if (res) {
            if (options.context) {
                res = this.internals.general.contextTransform(res, transform, options.context, 'relative');
            }
            return res;
        }
        // Format a pluralized future / past.
        var plural = bundle.plurals().cardinal(n);
        var arrow = negative ? format.past : format.future;
        var raw = arrow.get(bundle, plural, field);
        if (options.context) {
            raw = this.internals.general.contextTransform(raw, transform, options.context, 'relative');
        }
        var num = params.system.formatString(n, group, 1);
        return this.internals.general.formatWrapper(raw, [num]);
    };
    return DateFieldInternalsImpl;
}());
export { DateFieldInternalsImpl };
//# sourceMappingURL=internal.js.map