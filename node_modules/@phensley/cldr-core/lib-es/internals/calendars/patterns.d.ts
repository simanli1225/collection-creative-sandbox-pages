import { CalendarSchema } from '@phensley/cldr-types';
import { Internals } from '../../internals';
import { Bundle } from '../../resource';
import { DateSkeleton } from './skeleton';
import { DateTimeNode } from '../../parsing/date';
import { CalendarDate } from '../../systems/calendars';
export interface CachedSkeletonRequest {
    dateSkel?: DateSkeleton;
    date?: DateTimeNode[];
    time?: DateTimeNode[];
}
export interface CachedIntervalRequest {
    date?: DateTimeNode[];
    range?: DateTimeNode[];
    skeleton?: string;
}
export type StandaloneFieldType = 'dayPeriods' | 'eras' | 'months' | 'quarters' | 'weekdays';
export type TwoLevelMap = {
    [x: string]: {
        [y: string]: string;
    };
};
export type ThreeLevelMap = {
    [x: string]: {
        [y: string]: {
            [z: string]: string;
        };
    };
};
/**
 * Caches all available date formatting patterns for a given calendar schema.
 * We must cache all available skeletons in order to perform best-fit matching
 * to a given input skeleton. We also need to cache the standard date and time
 * patterns for use in best-fit matching.
 */
export declare class CalendarPatterns {
    protected readonly bundle: Bundle;
    protected readonly internals: Internals;
    private readonly schema;
    readonly cacheSize: number;
    protected readonly language: string;
    private readonly region;
    private readonly skeletonParser;
    private readonly intervalRequestCache;
    private readonly dateFormats;
    private readonly timeFormats;
    private readonly wrapperFormats;
    private readonly wrapperFormatsAt;
    private readonly availableMatcher;
    private readonly intervalMatcher;
    private readonly rawIntervalFormats;
    private readonly intervalFallback;
    protected readonly rawAvailableFormats: {
        [x: string]: string;
    };
    protected readonly rawPluralFormats: {
        [x: string]: {
            [y: string]: string;
        };
    };
    constructor(bundle: Bundle, internals: Internals, schema: CalendarSchema, cacheSize?: number);
    dayPeriods(): ThreeLevelMap;
    eras(): ThreeLevelMap;
    months(): TwoLevelMap;
    weekdays(): TwoLevelMap;
    quarters(): TwoLevelMap;
    parseSkeleton(raw: string): DateSkeleton;
    getDatePattern(width: string): DateTimeNode[];
    getTimePattern(width: string): DateTimeNode[];
    getCachedIntervalRequest(key: string): CachedIntervalRequest | undefined;
    setCachedIntervalRequest(key: string, req: CachedIntervalRequest): void;
    getWrapperPattern(width: string, atTime: boolean): string;
    getAvailablePattern(_d: CalendarDate, s: DateSkeleton): DateTimeNode[];
    getIntervalPattern(field: string, skeleton: string): DateTimeNode[];
    getIntervalFallback(): string;
    adjustPattern(pattern: DateTimeNode[], skeleton: DateSkeleton, decimal: string): DateTimeNode[];
    matchAvailable(skeleton: DateSkeleton): DateSkeleton;
    matchInterval(skeleton: DateSkeleton, field: string): DateSkeleton | undefined;
    private buildSkeletonParser;
    private buildAvailableMatcher;
    private buildIntervalMatcher;
    getTimeData(): [string, string];
}
export declare class GregorianPatterns extends CalendarPatterns {
    /**
     * Apply pluralization rules to select a skeleton pattern. Note: this is slightly
     * future-proofing since at the time of this writing these patterns don't actually
     * differ based on the plural category. This is here so the design has a chance of
     * supporting pluralization of skeleton patterns in the future.
     */
    getAvailablePattern(d: CalendarDate, s: DateSkeleton): DateTimeNode[];
}
