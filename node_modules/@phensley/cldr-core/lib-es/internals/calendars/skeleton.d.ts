import { DateTimeNode } from '../../parsing/date';
import { Field } from './fields';
export interface SkeletonField {
    input: string;
    field: string;
    type: Field;
    width: number;
    repeat: number;
}
/**
 * Represents an abstract date pattern, denoting the fields that appear in
 * the actual pattern.
 */
export declare class DateSkeleton {
    type: number[];
    info: (SkeletonField | undefined)[];
    skeleton: string;
    pattern?: string;
    isDate: boolean;
    isTime: boolean;
    compound(): boolean;
    has(field: number): boolean;
    monthWidth(): number;
    /**
     * Split this compound skeleton, removing all time fields and copying
     * them to another skeleton.
     */
    split(): DateSkeleton;
    /**
     * Build a canonical representation of the skeleton.
     */
    canonical(): string;
}
export declare const EMPTY: DateSkeleton;
export declare class DateSkeletonParser {
    readonly preferredFlex: DateTimeNode[];
    readonly allowedFlex: DateTimeNode[];
    constructor(preferredFlex: DateTimeNode[], allowedFlex: DateTimeNode[]);
    parse(skeleton: string, isPattern?: boolean): DateSkeleton;
    private _parse;
    private setDayPeriod;
    private setMeta;
    private set;
    private clear;
    private index;
}
/**
 * Cache of date patterns and skeletons with ICU-compatible best-fit matching.
 */
export declare class DatePatternMatcher {
    private exact;
    private entries;
    add(skeleton: DateSkeleton, _pattern?: DateTimeNode[]): void;
    match(input: DateSkeleton): DateSkeleton;
    /**
     * Make field width adjustments to pattern using the given skeleton.
     */
    adjust(pattern: DateTimeNode[], skeleton: DateSkeleton, decimal: string): DateTimeNode[];
    protected getDistance(a: DateSkeleton, b: DateSkeleton, _mask?: number): number;
}
