import { __extends } from "tslib";
import { coerceDecimal } from '@phensley/decimal';
import { LRU } from '@phensley/cldr-utils';
import { timeData, timeStrings } from './autogen.timedata';
import { DatePatternMatcher, DateSkeletonParser } from './skeleton';
import { parseDatePattern } from '../../parsing/date';
/**
 * Caches all available date formatting patterns for a given calendar schema.
 * We must cache all available skeletons in order to perform best-fit matching
 * to a given input skeleton. We also need to cache the standard date and time
 * patterns for use in best-fit matching.
 */
var CalendarPatterns = /** @class */ (function () {
    function CalendarPatterns(bundle, internals, schema, cacheSize) {
        if (cacheSize === void 0) { cacheSize = 50; }
        this.bundle = bundle;
        this.internals = internals;
        this.schema = schema;
        this.cacheSize = cacheSize;
        this.availableMatcher = new DatePatternMatcher();
        this.intervalMatcher = {};
        this.rawIntervalFormats = {};
        this.rawAvailableFormats = {};
        this.rawPluralFormats = {};
        this.language = bundle.language();
        this.region = bundle.region();
        this.skeletonParser = this.buildSkeletonParser();
        this.intervalRequestCache = new LRU(cacheSize);
        // Fetch this locale's main formats
        this.dateFormats = schema.dateFormats.mapping(bundle);
        this.timeFormats = schema.timeFormats.mapping(bundle);
        this.wrapperFormats = schema.dateTimeFormats.mapping(bundle);
        this.wrapperFormatsAt = schema.dateTimeFormatsAt.mapping(bundle);
        // Fetch skeletons and build best-fit matchers
        this.rawAvailableFormats = this.schema.availableFormats.mapping(bundle);
        this.rawPluralFormats = this.schema.pluralFormats.mapping(bundle);
        this.rawIntervalFormats = this.schema.intervalFormats.mapping(bundle);
        this.buildAvailableMatcher();
        this.buildIntervalMatcher();
        this.intervalFallback = this.schema.intervalFormatFallback.get(bundle);
    }
    CalendarPatterns.prototype.dayPeriods = function () {
        return this.schema.standAlone.dayPeriods.mapping(this.bundle);
    };
    CalendarPatterns.prototype.eras = function () {
        return this.schema.eras.mapping(this.bundle);
    };
    CalendarPatterns.prototype.months = function () {
        return this.schema.standAlone.months.mapping(this.bundle);
    };
    CalendarPatterns.prototype.weekdays = function () {
        return this.schema.standAlone.weekdays.mapping(this.bundle);
    };
    CalendarPatterns.prototype.quarters = function () {
        return this.schema.standAlone.quarters.mapping(this.bundle);
    };
    CalendarPatterns.prototype.parseSkeleton = function (raw) {
        return this.skeletonParser.parse(raw);
    };
    CalendarPatterns.prototype.getDatePattern = function (width) {
        return this.internals.calendars.parseDatePattern(this.dateFormats[width] || '');
    };
    CalendarPatterns.prototype.getTimePattern = function (width) {
        return this.internals.calendars.parseDatePattern(this.timeFormats[width] || '');
    };
    CalendarPatterns.prototype.getCachedIntervalRequest = function (key) {
        return this.intervalRequestCache.get(key);
    };
    CalendarPatterns.prototype.setCachedIntervalRequest = function (key, req) {
        this.intervalRequestCache.set(key, req);
    };
    CalendarPatterns.prototype.getWrapperPattern = function (width, atTime) {
        var w = this.wrapperFormatsAt[width];
        return atTime && w ? w : this.wrapperFormats[width] || '';
    };
    CalendarPatterns.prototype.getAvailablePattern = function (_d, s) {
        var pattern = s.pattern
            ? s.pattern
            : this.rawAvailableFormats[s.skeleton] || (this.rawPluralFormats.other || {})[s.skeleton];
        return this.internals.calendars.parseDatePattern(pattern || '');
    };
    CalendarPatterns.prototype.getIntervalPattern = function (field, skeleton) {
        var group = this.rawIntervalFormats[field];
        var pattern = group ? group[skeleton] : '';
        return this.internals.calendars.parseDatePattern(pattern || '');
    };
    CalendarPatterns.prototype.getIntervalFallback = function () {
        return this.intervalFallback;
    };
    CalendarPatterns.prototype.adjustPattern = function (pattern, skeleton, decimal) {
        return this.availableMatcher.adjust(pattern, skeleton, decimal);
    };
    CalendarPatterns.prototype.matchAvailable = function (skeleton) {
        return this.availableMatcher.match(skeleton);
    };
    CalendarPatterns.prototype.matchInterval = function (skeleton, field) {
        field = field === 's' ? 'm' : field;
        var m = this.intervalMatcher[field];
        return m ? m.match(skeleton) : undefined;
    };
    CalendarPatterns.prototype.buildSkeletonParser = function () {
        var pair = this.getTimeData();
        var allowedFlex = pair[0].split(' ').map(parseDatePattern);
        var preferredFlex = parseDatePattern(pair[1]);
        return new DateSkeletonParser(preferredFlex, allowedFlex[0]);
    };
    CalendarPatterns.prototype.buildAvailableMatcher = function () {
        for (var _i = 0, _a = Object.keys(this.dateFormats); _i < _a.length; _i++) {
            var width = _a[_i];
            this.availableMatcher.add(this.skeletonParser.parse(this.dateFormats[width], true));
            this.availableMatcher.add(this.skeletonParser.parse(this.timeFormats[width], true));
        }
        // For the pluralized formats use the 'other' category which will
        // be populated for every locale.
        for (var _b = 0, _c = [this.rawAvailableFormats, this.rawPluralFormats.other || {}]; _b < _c.length; _b++) {
            var formats = _c[_b];
            for (var _e = 0, _f = Object.keys(formats); _e < _f.length; _e++) {
                var skeleton = _f[_e];
                this.availableMatcher.add(this.skeletonParser.parse(skeleton));
            }
        }
    };
    CalendarPatterns.prototype.buildIntervalMatcher = function () {
        for (var _i = 0, _a = Object.keys(this.rawIntervalFormats); _i < _a.length; _i++) {
            var field = _a[_i];
            var group = this.rawIntervalFormats[field];
            var m = new DatePatternMatcher();
            for (var _b = 0, _c = Object.keys(group); _b < _c.length; _b++) {
                var skeleton = _c[_b];
                m.add(this.skeletonParser.parse(skeleton));
            }
            this.intervalMatcher[field] = m;
        }
    };
    CalendarPatterns.prototype.getTimeData = function () {
        var w = timeData['']['001'];
        var t = timeData[''][this.region] || (timeData[this.language] || /* istanbul ignore next */ {})[this.region];
        return timeStrings[t !== undefined ? t : w].split('|');
    };
    return CalendarPatterns;
}());
export { CalendarPatterns };
var GregorianPatterns = /** @class */ (function (_super) {
    __extends(GregorianPatterns, _super);
    function GregorianPatterns() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Apply pluralization rules to select a skeleton pattern. Note: this is slightly
     * future-proofing since at the time of this writing these patterns don't actually
     * differ based on the plural category. This is here so the design has a chance of
     * supporting pluralization of skeleton patterns in the future.
     */
    GregorianPatterns.prototype.getAvailablePattern = function (d, s) {
        var plural = 'other';
        var pattern = s.pattern;
        if (!pattern) {
            switch (s.skeleton) {
                case 'MMMMW':
                case 'yw': {
                    var week = coerceDecimal(s.skeleton === 'yw' ? d.weekOfYear() : d.weekOfMonth());
                    plural = this.bundle.plurals().cardinal(week);
                    pattern = this.rawPluralFormats[plural][s.skeleton];
                    break;
                }
                default:
                    pattern = this.rawAvailableFormats[s.skeleton];
                    break;
            }
        }
        return this.internals.calendars.parseDatePattern(pattern);
    };
    return GregorianPatterns;
}(CalendarPatterns));
export { GregorianPatterns };
//# sourceMappingURL=patterns.js.map