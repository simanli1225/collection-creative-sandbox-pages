import { DateTimePatternFieldType } from '@phensley/cldr-types';
import { Internals } from '../internals';
import { Bundle } from '../../resource';
import { DateFormatOptions, DateIntervalFormatOptions } from '../../common';
import { CalendarDate } from '../../systems/calendars';
import { NumberParams } from '../../common/private';
import { CalendarPatterns } from './patterns';
import { DateFormatRequest, DateIntervalFormatRequest } from './types';
export declare class CalendarManager {
    private readonly bundle;
    private readonly internals;
    private readonly patternCache;
    private readonly availableCalendars;
    constructor(bundle: Bundle, internals: Internals);
    getCalendarPatterns(calendar: string): CalendarPatterns;
    getDateFormatRequest(date: CalendarDate, options: DateFormatOptions, params: NumberParams): DateFormatRequest;
    /**
     * Best-fit match an input skeleton. The skeleton can contain both date and
     * time fields.
     *
     * The field of greatest difference between the start and end dates can be
     * either a date or time field.
     *
     * Given this we need to cover the following cases:
     *
     * 1. Input skeleton requests both date and time fields.
     *  a. "yMd" same: split skeleton, format date standalone, followed by time range.
     *  b. "yMd" differ: format full start / end with fallback format.
     *
     * 2. Input skeleton requests date fields only:
     *  a. "yMd" same: format date standalone
     *  b. "yMd" differ: select and format date range
     *
     * 3. Input skeleton requests time fields only:
     *  a. "yMd" same, "ahms" same: format time standalone
     *  b. "yMd" same, "ahms" differ: select and format time range.
     *  c. "yMd" differ: prepend "yMd" to skeleton and go to (1a).
     */
    getDateIntervalFormatRequest(calendar: string, start: CalendarDate, fieldDiff: DateTimePatternFieldType, options: DateIntervalFormatOptions, params: NumberParams): DateIntervalFormatRequest;
    private matchAvailablePattern;
    private getAvailablePattern;
    /**
     * Select appropriate wrapper based on fields in the date skeleton.
     */
    private selectWrapper;
    private supportedOption;
}
