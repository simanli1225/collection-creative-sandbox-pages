{"version":3,"file":"skeleton.js","sourceRoot":"","sources":["../../../src/internals/calendars/skeleton.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateTimeNode, DATE_PATTERN_CHARS } from '../../parsing/date';\n\nimport {\n  getFieldType,\n  skeletonFields,\n  EXTRA_FIELD,\n  Field,\n  FieldType,\n  FIELD_INDEX,\n  FIELD_TYPES,\n  MISSING_FIELD,\n} from './fields';\n\nexport interface SkeletonField {\n  input: string;\n  field: string;\n  type: Field;\n  width: number;\n  repeat: number;\n}\n\n/**\n * Represents an abstract date pattern, denoting the fields that appear in\n * the actual pattern.\n */\nexport class DateSkeleton {\n  type: number[] = skeletonFields();\n  info: (SkeletonField | undefined)[] = [];\n\n  skeleton: string = '';\n  pattern?: string;\n\n  isDate: boolean = false;\n  isTime: boolean = false;\n\n  compound(): boolean {\n    return this.isDate && this.isTime;\n  }\n\n  has(field: number): boolean {\n    return this.type[field] !== 0;\n  }\n\n  monthWidth(): number {\n    const m = this.info[Field.MONTH];\n    return m ? m.width : 0;\n  }\n\n  /**\n   * Split this compound skeleton, removing all time fields and copying\n   * them to another skeleton.\n   */\n  split(): DateSkeleton {\n    const r = new DateSkeleton();\n    // Copy time fields to other skeleton and clear them.\n    for (let i = Field.DAYPERIOD; i < Field.MAX_TYPE; i++) {\n      if (this.type[i] !== 0) {\n        r.type[i] = this.type[i];\n        // ensure we copy the properties\n        const { input, field, type, width, repeat } = this.info[i]!;\n        r.info[i] = { input, field, type, width, repeat };\n        this.type[i] = 0;\n        this.info[i] = undefined;\n      }\n    }\n    this.isTime = false;\n    this.skeleton = this.canonical();\n    r.isTime = true;\n    r.skeleton = r.canonical();\n    return r;\n  }\n\n  /**\n   * Build a canonical representation of the skeleton.\n   */\n  canonical(): string {\n    let r = '';\n    for (let i = 0; i < Field.MAX_TYPE; i++) {\n      const info = this.info[i];\n      if (info !== undefined) {\n        const { field } = info;\n        // Skip day period for backwards-compatibility\n        if (field !== '' && field !== 'a') {\n          let repeat = info.repeat;\n          // Override skeleton repeat for these fields.\n          if ('GEzvQ'.indexOf(field) !== -1) {\n            repeat = 1;\n          }\n          for (let j = 0; j < repeat; j++) {\n            r += field;\n          }\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport const EMPTY = new DateSkeleton();\n\nexport class DateSkeletonParser {\n  constructor(\n    readonly preferredFlex: DateTimeNode[],\n    readonly allowedFlex: DateTimeNode[],\n  ) {}\n\n  parse(skeleton: string, isPattern: boolean = false): DateSkeleton {\n    const s = new DateSkeleton();\n    this._parse(s, skeleton, isPattern);\n    return s;\n  }\n\n  private _parse(s: DateSkeleton, raw: string, isPattern: boolean): void {\n    const len = raw.length;\n    let noDayPeriod = false;\n    let field = '';\n    let width = 0;\n    let inquote = false;\n    let i = 0;\n    while (i < len) {\n      const ch = raw[i];\n      if (inquote) {\n        if (ch === \"'\") {\n          inquote = false;\n        }\n        i++;\n        continue;\n      }\n      if (ch === \"'\") {\n        inquote = true;\n      } else if (DATE_PATTERN_CHARS[ch] > 0) {\n        if (ch !== field) {\n          if (field) {\n            noDayPeriod = this.setDayPeriod(s, field, width, noDayPeriod);\n          }\n          field = ch;\n          width = 1;\n        } else {\n          width++;\n        }\n      }\n\n      // Lenient parse.. skip all non-field charaters.\n      i++;\n    }\n\n    // Push the last field. For a non-empty skeleton this will always\n    // be true.\n    if (width > 0 && field) {\n      noDayPeriod = this.setDayPeriod(s, field, width, noDayPeriod);\n    }\n\n    // Handle some special hour cycle / day period behaviors\n    const hour = s.info[Field.HOUR];\n    const dayPeriod = s.info[Field.DAYPERIOD];\n    if (noDayPeriod) {\n      this.clear(s, Field.DAYPERIOD);\n    } else if (hour && hour.field) {\n      // If we have a 12-hour-cycle but no dayperiod, add the default.\n      if (hour.field === 'h' || hour.field === 'K') {\n        if (!dayPeriod) {\n          // Add the default day period\n          const idx = FIELD_INDEX.get('a')![0];\n          const row = FIELD_TYPES[idx];\n          s.type[Field.DAYPERIOD] = row[2];\n          s.info[Field.DAYPERIOD] = {\n            input: 'a',\n            field: 'a',\n            type: Field.DAYPERIOD,\n            width: row[3],\n            repeat: row[3],\n          };\n        }\n      } else if (dayPeriod && dayPeriod.field) {\n        this.clear(s, Field.DAYPERIOD);\n      }\n    }\n\n    s.skeleton = isPattern ? s.canonical() : raw;\n    if (isPattern) {\n      s.pattern = raw;\n    }\n  }\n\n  private setDayPeriod(s: DateSkeleton, field: string, width: number, noDayPeriod: boolean): boolean {\n    if ('jJC'.indexOf(field) !== -1) {\n      noDayPeriod = field === 'J';\n      this.setMeta(s, field);\n    } else {\n      this.set(s, field, field, width);\n    }\n    return noDayPeriod;\n  }\n\n  private setMeta(s: DateSkeleton, field: string): void {\n    const meta = field === 'C' ? this.allowedFlex : this.preferredFlex;\n    for (const n of meta) {\n      // Flex types have no static pattern fields\n      /* istanbul ignore else */\n      if (typeof n !== 'string') {\n        this.set(s, field, n[0], n[1]);\n      }\n    }\n  }\n\n  private set(s: DateSkeleton, input: string, field: string, width: number): void {\n    const ft = getFieldType(field, width);\n    // Will never fail as field types are whitelisted at a higher call point\n    /* istanbul ignore else */\n    if (ft !== undefined) {\n      this.index(s, input, field, width, ft);\n    }\n  }\n\n  private clear(s: DateSkeleton, field: number): void {\n    s.type[field] = 0;\n    s.info[field] = undefined;\n  }\n\n  private index(s: DateSkeleton, input: string, field: string, width: number, ft: FieldType): void {\n    const idx = ft[1];\n    s.type[idx] = ft[2] + (ft[2] > 0 ? width : 0);\n    s.info[idx] = { input, field, type: idx, width, repeat: ft[3] };\n    s.isDate = s.isDate || idx < Field.DAYPERIOD;\n    s.isTime = s.isTime || idx >= Field.DAYPERIOD;\n  }\n}\n\nconst cmp = (a: number, b: number): number => (a < b ? -1 : a > b ? 1 : 0);\n\n/**\n * Cache of date patterns and skeletons with ICU-compatible best-fit matching.\n */\nexport class DatePatternMatcher {\n  // Save some work for exact matches.\n  private exact: { [x: string]: DateSkeleton } = {};\n\n  // Array for matching by distances\n  private entries: DateSkeleton[] = [];\n\n  add(skeleton: DateSkeleton, _pattern?: DateTimeNode[]): void {\n    const key = skeleton.skeleton;\n    // Avoid adding patterns with duplicate skeletons\n    if (this.exact[key] === undefined) {\n      this.exact[key] = skeleton;\n      this.entries.push(skeleton);\n    }\n    this.entries.sort((a, b) => cmp(a.skeleton.length, b.skeleton.length));\n  }\n\n  // TODO: future options to control the match\n\n  match(input: DateSkeleton): DateSkeleton {\n    const match = this.exact[input.skeleton];\n    if (match !== undefined) {\n      return match;\n    }\n\n    let best: DateSkeleton = EMPTY;\n    let bestDist: number = Number.MAX_SAFE_INTEGER;\n\n    for (const entry of this.entries) {\n      const dist = this.getDistance(entry, input);\n      if (dist < bestDist) {\n        best = entry;\n        bestDist = dist;\n        if (dist === 0) {\n          break;\n        }\n      }\n    }\n    return best;\n  }\n\n  /**\n   * Make field width adjustments to pattern using the given skeleton.\n   */\n  adjust(pattern: DateTimeNode[], skeleton: DateSkeleton, decimal: string): DateTimeNode[] {\n    const r: DateTimeNode[] = [];\n    for (const n of pattern) {\n      if (typeof n === 'string') {\n        r.push(n);\n        continue;\n      }\n\n      const [field, width] = n;\n      const p = getFieldType(field, width)!;\n\n      // Adjust field and width to match skeleton below\n      let adjfield = field;\n      let adjwidth = width;\n\n      const i = p[1];\n\n      // For hour, minute and second we use the width from the pattern.\n      if (i === Field.HOUR || i === Field.MINUTE || i === Field.SECOND) {\n        r.push([adjfield, adjwidth]);\n\n        // See if skeleton requested fractional seconds and augment the seconds field.\n        if (i === Field.SECOND) {\n          const info = skeleton.info[Field.FRACTIONAL_SECOND];\n          if (info !== undefined) {\n            r.push(decimal);\n            r.push([info.field, info.width]);\n          }\n        }\n        continue;\n      }\n\n      const ptype = p[2];\n      const stype = skeleton.type[i];\n      // Ensure magnitudes are the same\n      if ((ptype < 0 && stype < 0) || (ptype > 0 && stype > 0)) {\n        const _info = skeleton.info[i];\n        // Since the 'i' comes from a parsed date pattern, this should\n        // always be defined.\n        /* istanbul ignore else */\n        if (_info) {\n          adjfield = _info.field;\n          adjwidth = _info.width;\n        }\n      }\n\n      // TODO: UNREACHABLE as field replacement has been selected above\n      // // Metacharacters have already been replaced in the pattern.\n      // if ('jJC'.indexOf(adjfield) !== -1) {\n      //   console.log('adjust skeleton', adjfield);\n      //   adjfield = field;\n      // }\n      r.push([adjfield, adjwidth]);\n    }\n\n    // TODO: handle appending missing fields\n    return r;\n  }\n\n  // TODO: mask is currently unused\n  protected getDistance(a: DateSkeleton, b: DateSkeleton, _mask: number = 0): number {\n    let result = 0;\n    for (let i = 0; i < Field.MAX_TYPE; i++) {\n      // const atype = mask > 0 && (mask & (1 << i)) === 0 ? 0 : a.type[i];\n      const atype = a.type[i];\n      const btype = b.type[i];\n      if (atype === btype) {\n        continue;\n      }\n      if (atype === 0) {\n        result += EXTRA_FIELD;\n      } else if (btype === 0) {\n        result += MISSING_FIELD;\n      } else {\n        result += Math.abs(atype - btype);\n      }\n    }\n    return result;\n  }\n}\n"]}