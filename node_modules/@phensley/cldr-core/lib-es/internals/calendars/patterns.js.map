{"version":3,"file":"patterns.js","sourceRoot":"","sources":["../../../src/internals/calendars/patterns.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalendarSchema, PluralType } from '@phensley/cldr-types';\nimport { coerceDecimal } from '@phensley/decimal';\nimport { LRU } from '@phensley/cldr-utils';\n\nimport { timeData, timeStrings } from './autogen.timedata';\nimport { Internals } from '../../internals';\nimport { Bundle } from '../../resource';\nimport { DatePatternMatcher, DateSkeleton, DateSkeletonParser } from './skeleton';\nimport { parseDatePattern, DateTimeNode } from '../../parsing/date';\nimport { CalendarDate } from '../../systems/calendars';\n\nexport interface CachedSkeletonRequest {\n  dateSkel?: DateSkeleton;\n  date?: DateTimeNode[];\n  time?: DateTimeNode[];\n}\n\nexport interface CachedIntervalRequest {\n  date?: DateTimeNode[];\n  range?: DateTimeNode[];\n  skeleton?: string;\n}\n\nexport type StandaloneFieldType = 'dayPeriods' | 'eras' | 'months' | 'quarters' | 'weekdays';\n\nexport type TwoLevelMap = { [x: string]: { [y: string]: string } };\nexport type ThreeLevelMap = { [x: string]: { [y: string]: { [z: string]: string } } };\n\n/**\n * Caches all available date formatting patterns for a given calendar schema.\n * We must cache all available skeletons in order to perform best-fit matching\n * to a given input skeleton. We also need to cache the standard date and time\n * patterns for use in best-fit matching.\n */\nexport class CalendarPatterns {\n  protected readonly language: string;\n\n  private readonly region: string;\n  private readonly skeletonParser: DateSkeletonParser;\n  private readonly intervalRequestCache: LRU<CachedIntervalRequest>;\n  private readonly dateFormats: { [x: string]: string };\n  private readonly timeFormats: { [x: string]: string };\n  private readonly wrapperFormats: { [x: string]: string };\n  private readonly wrapperFormatsAt: { [x: string]: string };\n\n  private readonly availableMatcher: DatePatternMatcher = new DatePatternMatcher();\n  private readonly intervalMatcher: { [x: string]: DatePatternMatcher } = {};\n\n  private readonly rawIntervalFormats: { [x: string]: { [y: string]: string } } = {};\n  private readonly intervalFallback: string;\n\n  protected readonly rawAvailableFormats: { [x: string]: string } = {};\n  protected readonly rawPluralFormats: { [x: string]: { [y: string]: string } } = {};\n\n  constructor(\n    protected readonly bundle: Bundle,\n    protected readonly internals: Internals,\n    private readonly schema: CalendarSchema,\n    readonly cacheSize: number = 50,\n  ) {\n    this.language = bundle.language();\n    this.region = bundle.region();\n    this.skeletonParser = this.buildSkeletonParser();\n    this.intervalRequestCache = new LRU(cacheSize);\n\n    // Fetch this locale's main formats\n    this.dateFormats = schema.dateFormats.mapping(bundle);\n    this.timeFormats = schema.timeFormats.mapping(bundle);\n    this.wrapperFormats = schema.dateTimeFormats.mapping(bundle);\n    this.wrapperFormatsAt = schema.dateTimeFormatsAt.mapping(bundle);\n\n    // Fetch skeletons and build best-fit matchers\n    this.rawAvailableFormats = this.schema.availableFormats.mapping(bundle);\n    this.rawPluralFormats = this.schema.pluralFormats.mapping(bundle);\n    this.rawIntervalFormats = this.schema.intervalFormats.mapping(bundle);\n    this.buildAvailableMatcher();\n    this.buildIntervalMatcher();\n\n    this.intervalFallback = this.schema.intervalFormatFallback.get(bundle);\n  }\n\n  dayPeriods(): ThreeLevelMap {\n    return this.schema.standAlone.dayPeriods.mapping(this.bundle);\n  }\n\n  eras(): ThreeLevelMap {\n    return this.schema.eras.mapping(this.bundle);\n  }\n\n  months(): TwoLevelMap {\n    return this.schema.standAlone.months.mapping(this.bundle);\n  }\n\n  weekdays(): TwoLevelMap {\n    return this.schema.standAlone.weekdays.mapping(this.bundle);\n  }\n\n  quarters(): TwoLevelMap {\n    return this.schema.standAlone.quarters.mapping(this.bundle);\n  }\n\n  parseSkeleton(raw: string): DateSkeleton {\n    return this.skeletonParser.parse(raw);\n  }\n\n  getDatePattern(width: string): DateTimeNode[] {\n    return this.internals.calendars.parseDatePattern(this.dateFormats[width] || '');\n  }\n\n  getTimePattern(width: string): DateTimeNode[] {\n    return this.internals.calendars.parseDatePattern(this.timeFormats[width] || '');\n  }\n\n  getCachedIntervalRequest(key: string): CachedIntervalRequest | undefined {\n    return this.intervalRequestCache.get(key);\n  }\n\n  setCachedIntervalRequest(key: string, req: CachedIntervalRequest): void {\n    this.intervalRequestCache.set(key, req);\n  }\n\n  getWrapperPattern(width: string, atTime: boolean): string {\n    let w = this.wrapperFormatsAt[width];\n    return atTime && w ? w : this.wrapperFormats[width] || '';\n  }\n\n  getAvailablePattern(_d: CalendarDate, s: DateSkeleton): DateTimeNode[] {\n    const pattern = s.pattern\n      ? s.pattern\n      : this.rawAvailableFormats[s.skeleton] || (this.rawPluralFormats.other || {})[s.skeleton];\n    return this.internals.calendars.parseDatePattern(pattern || '');\n  }\n\n  getIntervalPattern(field: string, skeleton: string): DateTimeNode[] {\n    const group = this.rawIntervalFormats[field];\n    const pattern = group ? group[skeleton] : '';\n    return this.internals.calendars.parseDatePattern(pattern || '');\n  }\n\n  getIntervalFallback(): string {\n    return this.intervalFallback;\n  }\n\n  adjustPattern(pattern: DateTimeNode[], skeleton: DateSkeleton, decimal: string): DateTimeNode[] {\n    return this.availableMatcher.adjust(pattern, skeleton, decimal);\n  }\n\n  matchAvailable(skeleton: DateSkeleton): DateSkeleton {\n    return this.availableMatcher.match(skeleton);\n  }\n\n  matchInterval(skeleton: DateSkeleton, field: string): DateSkeleton | undefined {\n    field = field === 's' ? 'm' : field;\n    const m = this.intervalMatcher[field];\n    return m ? m.match(skeleton) : undefined;\n  }\n\n  private buildSkeletonParser(): DateSkeletonParser {\n    const pair = this.getTimeData();\n    const allowedFlex = pair[0].split(' ').map(parseDatePattern);\n    const preferredFlex = parseDatePattern(pair[1]);\n    return new DateSkeletonParser(preferredFlex, allowedFlex[0]);\n  }\n\n  private buildAvailableMatcher(): void {\n    for (const width of Object.keys(this.dateFormats)) {\n      this.availableMatcher.add(this.skeletonParser.parse(this.dateFormats[width], true));\n      this.availableMatcher.add(this.skeletonParser.parse(this.timeFormats[width], true));\n    }\n\n    // For the pluralized formats use the 'other' category which will\n    // be populated for every locale.\n    for (const formats of [this.rawAvailableFormats, this.rawPluralFormats.other || {}]) {\n      for (const skeleton of Object.keys(formats)) {\n        this.availableMatcher.add(this.skeletonParser.parse(skeleton));\n      }\n    }\n  }\n\n  private buildIntervalMatcher(): void {\n    for (const field of Object.keys(this.rawIntervalFormats)) {\n      const group = this.rawIntervalFormats[field];\n      const m = new DatePatternMatcher();\n      for (const skeleton of Object.keys(group)) {\n        m.add(this.skeletonParser.parse(skeleton));\n      }\n      this.intervalMatcher[field] = m;\n    }\n  }\n\n  getTimeData(): [string, string] {\n    const w = timeData['']['001'];\n    const t = timeData[''][this.region] || (timeData[this.language] || /* istanbul ignore next */ {})[this.region];\n    return timeStrings[t !== undefined ? t : w].split('|') as [string, string];\n  }\n}\n\nexport class GregorianPatterns extends CalendarPatterns {\n  /**\n   * Apply pluralization rules to select a skeleton pattern. Note: this is slightly\n   * future-proofing since at the time of this writing these patterns don't actually\n   * differ based on the plural category. This is here so the design has a chance of\n   * supporting pluralization of skeleton patterns in the future.\n   */\n  getAvailablePattern(d: CalendarDate, s: DateSkeleton): DateTimeNode[] {\n    let plural: PluralType = 'other';\n    let pattern = s.pattern;\n    if (!pattern) {\n      switch (s.skeleton) {\n        case 'MMMMW':\n        case 'yw': {\n          const week = coerceDecimal(s.skeleton === 'yw' ? d.weekOfYear() : d.weekOfMonth());\n          plural = this.bundle.plurals().cardinal(week) as PluralType;\n          pattern = this.rawPluralFormats[plural][s.skeleton];\n          break;\n        }\n        default:\n          pattern = this.rawAvailableFormats[s.skeleton];\n          break;\n      }\n    }\n    return this.internals.calendars.parseDatePattern(pattern);\n  }\n}\n"]}