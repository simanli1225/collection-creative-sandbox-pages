var min = Math.min;
var getTZC = function (offset) {
    var negative = offset < 0;
    if (negative) {
        offset *= -1;
    }
    offset /= 60000;
    var hours = (offset / 60) | 0;
    var minutes = offset % 60 | 0;
    return [offset, negative, hours, minutes];
};
var widthKey1 = function (w) { return (w === 5 ? 'narrow' : w === 4 ? 'wide' : 'abbreviated'); };
/**
 * Format a number using the main numbering system, with the given minimum integers.
 */
var _num = function (ctx, n, minInt) {
    return ctx.system.formatString(n, false, minInt);
};
var _year = function (ctx, year, width) {
    return _num(ctx, width === 2 ? year % 100 : year, width);
};
var CalendarFormatterImpl = /** @class */ (function () {
    function CalendarFormatterImpl(internals, cal) {
        this.internals = internals;
        this.cal = cal;
        this.general = internals.general;
        this.tz = internals.schema.TimeZones;
    }
    CalendarFormatterImpl.prototype.format = function (val, ctx, nodes, first) {
        if (first === void 0) { first = true; }
        var len = nodes.length;
        for (var i = 0; i < len; i++) {
            var n = nodes[i];
            if (typeof n === 'string') {
                val.add('literal', n);
                continue;
            }
            var w = n[1];
            var field = void 0;
            var type = '';
            var value = '';
            // Date field symbol table
            // https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
            switch (n[0]) {
                // ERA
                case 'G': {
                    type = 'era';
                    var era = "".concat(ctx.date.era());
                    var width = w === 5 ? 'narrow' : w === 4 ? 'names' : 'abbr';
                    value = this.cal.eras.get(ctx.bundle, width, era, [ctx.alt.era, 'none']);
                    if (w !== 5) {
                        field = w === 4 ? 'era-name' : 'era-abbr';
                    }
                    break;
                }
                // YEAR
                case 'y':
                    type = 'year';
                    value = _year(ctx, ctx.date.year(), w);
                    break;
                // YEAR IN WEEK OF YEAR
                case 'Y':
                    type = 'year';
                    value = _year(ctx, ctx.date.yearOfWeekOfYear(), w);
                    break;
                // EXTENDED YEAR
                case 'u':
                    type = 'year';
                    value = _num(ctx, ctx.date.extendedYear(), w);
                    break;
                // CYCLIC YEAR
                case 'U':
                    type = 'cyclic-year';
                    // TODO: support chinese cyclical years
                    value = '';
                    break;
                // RELATED YEAR
                case 'r':
                    type = 'related-year';
                    // Note: this is always rendered using 'latn' digits
                    value = ctx.latnSystem.formatString(ctx.date.relatedYear(), false, w);
                    break;
                // QUARTER
                case 'Q':
                case 'q':
                    type = 'quarter';
                    value = this.quarter(ctx, n);
                    break;
                // MONTH FORMAT
                case 'M':
                    type = 'month';
                    value = this.month(ctx, n);
                    switch (w) {
                        case 3:
                        case 4:
                            field = 'month-format-except-narrow';
                            break;
                    }
                    break;
                // MONTH STANDALONE
                case 'L':
                    type = 'month';
                    value = this.month(ctx, n);
                    switch (w) {
                        case 3:
                        case 4:
                            field = 'month-standalone-except-narrow';
                            break;
                    }
                    break;
                // 'l' - deprecated
                // WEEK OF WEEK YEAR
                case 'w':
                    type = 'week';
                    value = _num(ctx, ctx.date.weekOfYear(), min(w, 2));
                    break;
                // WEEK OF MONTH
                case 'W':
                    type = 'week';
                    value = _num(ctx, ctx.date.weekOfMonth(), 1);
                    break;
                // DAY OF MONTH
                case 'd':
                    type = 'day';
                    value = _num(ctx, ctx.date.dayOfMonth(), min(w, 2));
                    break;
                // DAY OF YEAR
                case 'D':
                    type = 'day';
                    value = _num(ctx, ctx.date.dayOfYear(), min(w, 3));
                    break;
                // DAY OF WEEK IN MONTH
                case 'F':
                    type = 'day';
                    value = _num(ctx, ctx.date.dayOfWeekInMonth(), 1);
                    break;
                // MODIFIED JULIAN DAY
                case 'g':
                    type = 'mjulian-day';
                    value = _num(ctx, ctx.date.modifiedJulianDay(), w);
                    break;
                // WEEKDAY FORMAT
                case 'E':
                    type = 'weekday';
                    value = this._weekday(ctx.bundle, this.cal.format.weekdays, ctx.date, w);
                    if (w !== 5) {
                        field = 'day-format-except-narrow';
                    }
                    break;
                // WEEKDAY LOCAL
                case 'e':
                    type = 'weekday';
                    value = this._weekdayLocal(ctx, n, false);
                    break;
                // WEEKDAY LOCAL STANDALONE
                case 'c':
                    type = 'weekday';
                    value = this._weekdayLocal(ctx, n, true);
                    if (w !== 5) {
                        field = 'day-standalone-except-narrow';
                    }
                    break;
                // DAY PERIOD AM/PM
                case 'a': {
                    var ampm = ctx.date.hourOfDay() < 12 ? 'am' : 'pm';
                    var width = widthKey1(w);
                    type = 'dayperiod';
                    value = this.cal.format.dayPeriods.get(ctx.bundle, width, ampm, [ctx.alt.dayPeriod, 'none']);
                    break;
                }
                // DAY PERIOD EXTENDED
                case 'b':
                    type = 'dayperiod';
                    value = this.dayPeriodExt(ctx, n);
                    break;
                // DAY PERIOD FLEXIBLE
                case 'B':
                    type = 'dayperiod';
                    value = this.dayPeriodFlex(ctx, n);
                    break;
                // HOUR 1-12 and 0-23
                case 'h':
                case 'H':
                    type = 'hour';
                    value = this.hour(ctx, n);
                    break;
                // HOUR 0-11 and 1-24
                case 'K':
                case 'k':
                    type = 'hour';
                    value = this.hourAlt(ctx, n);
                    break;
                // 'j', 'J', 'C' - input skeleton symbols, not present in formats
                // MINUTE
                case 'm':
                    type = 'minute';
                    value = _num(ctx, ctx.date.minute(), min(w, 2));
                    break;
                // SECOND
                case 's':
                    type = 'second';
                    value = _num(ctx, ctx.date.second(), min(w, 2));
                    break;
                // FRACTIONAL SECOND
                case 'S':
                    type = 'fracsec';
                    value = this.fractionalSecond(ctx, n);
                    break;
                // MILLISECONDS IN DAY
                case 'A':
                    type = 'millis-in-day';
                    value = _num(ctx, ctx.date.millisecondsInDay(), w);
                    break;
                // TIMEZONE SPECIFIC NON-LOCATION
                case 'z':
                    type = 'timezone';
                    value = this.timezone_z(ctx, n);
                    break;
                // TIMEZONE ISO-8601 EXTENDED
                case 'Z':
                    type = 'timezone';
                    value = this.timezone_Z(ctx, n);
                    break;
                // TIMEZONE LOCALIZED
                case 'O':
                    type = 'timezone';
                    value = this.timezone_O(ctx, n);
                    break;
                // TIMEZONE GENERIC NON-LOCATION
                case 'v':
                    type = 'timezone';
                    value = this.timezone_v(ctx, n);
                    break;
                // TIMEZONE ID, EXEMPLAR CITY, GENERIC LOCATION
                case 'V':
                    type = 'timezone';
                    value = this.timezone_V(ctx, n);
                    break;
                // TIMEZONE ISO-8601 BASIC, EXTENDED
                case 'X':
                case 'x':
                    type = 'timezone';
                    value = this.timezone_x(ctx, n);
                    break;
                default:
                    continue;
            }
            if (first && i === 0 && ctx.context && field) {
                value = this.internals.general.contextTransform(value, ctx.transform, ctx.context, field);
            }
            val.add(type, value);
        }
    };
    CalendarFormatterImpl.prototype._formatQuarterOrMonth = function (ctx, format, value, width) {
        return width >= 3 ? format.get(ctx.bundle, widthKey1(width), String(value)) : _num(ctx, value, width);
    };
    CalendarFormatterImpl.prototype.quarter = function (ctx, node) {
        var field = node[0], width = node[1];
        var format = field === 'Q' ? this.cal.format : this.cal.standAlone;
        var quarters = format.quarters;
        var quarter = (((ctx.date.month() - 1) / 3) | 0) + 1;
        return this._formatQuarterOrMonth(ctx, quarters, quarter, width);
    };
    CalendarFormatterImpl.prototype.month = function (ctx, node) {
        var format = node[0] === 'M' ? this.cal.format : this.cal.standAlone;
        return this._formatQuarterOrMonth(ctx, format.months, ctx.date.month(), node[1]);
    };
    CalendarFormatterImpl.prototype._weekday = function (bundle, format, date, width) {
        var key2 = String(date.dayOfWeek());
        var key1 = 'abbreviated';
        switch (width) {
            case 6:
                key1 = 'short';
                break;
            case 5:
                key1 = 'narrow';
                break;
            case 4:
                key1 = 'wide';
                break;
        }
        return format.get(bundle, key1, key2);
    };
    CalendarFormatterImpl.prototype._weekdayLocal = function (ctx, node, standAlone) {
        var bundle = ctx.bundle, date = ctx.date;
        var width = node[1];
        if (width > 2) {
            var format = standAlone ? this.cal.standAlone : this.cal.format;
            return this._weekday(bundle, format.weekdays, date, width);
        }
        var ord = date.ordinalDayOfWeek();
        if (standAlone) {
            width = 1;
        }
        return ctx.system.formatString(ord, false, width);
    };
    CalendarFormatterImpl.prototype.dayPeriodExt = function (ctx, node) {
        var bundle = ctx.bundle, date = ctx.date;
        var key1 = widthKey1(node[1]);
        var key2 = date.isAM() ? 'am' : 'pm';
        var key2ext = key2;
        if (date.minute() === 0) {
            var hour = date.hourOfDay();
            key2ext = hour === 0 ? 'midnight' : hour === 12 ? 'noon' : key2;
        }
        var format = this.cal.format.dayPeriods;
        // Try extended and if it doesn't exist fall back to am/pm
        return format.get(bundle, key1, [key2ext, key2], [ctx.alt.dayPeriod, 'none']);
    };
    CalendarFormatterImpl.prototype.dayPeriodFlex = function (ctx, node) {
        var bundle = ctx.bundle, date = ctx.date;
        var minutes = date.hourOfDay() * 60 + date.minute();
        var key2 = this.internals.calendars.flexDayPeriod(bundle, minutes);
        var res = '';
        if (key2) {
            var width = widthKey1(node[1]);
            // TODO: more compact fallbacks for alternatives
            res = this.cal.format.dayPeriods.get(bundle, width, key2, [ctx.alt.dayPeriod, 'none']);
        }
        return res ? res : this.dayPeriodExt(ctx, node);
    };
    CalendarFormatterImpl.prototype.hour = function (ctx, node) {
        var date = ctx.date;
        var twelve = node[0] === 'h';
        var hour = twelve ? date.hour() : date.hourOfDay();
        if (twelve && hour === 0) {
            hour = 12;
        }
        return _num(ctx, hour, min(node[1], 2));
    };
    CalendarFormatterImpl.prototype.hourAlt = function (ctx, node) {
        var date = ctx.date;
        var twelve = node[0] === 'K';
        var hour = twelve ? date.hour() : date.hourOfDay();
        if (!twelve && hour === 0) {
            hour = 24;
        }
        return _num(ctx, hour, min(node[1], 2));
    };
    CalendarFormatterImpl.prototype.fractionalSecond = function (ctx, node) {
        var w = node[1];
        var m = ctx.date.milliseconds();
        var d = w > 3 ? w - 3 : 0;
        w -= d;
        if (d > 0) {
            m *= Math.pow(10, d);
        }
        // Milliseconds always have precision of 3, so handle the cases compactly.
        var n = w === 3 ? m : (w === 2 ? m / 10 : m / 100) | 0;
        return _num(ctx, n, node[1]);
    };
    /**
     * Timezone: short/long specific non-location format.
     * https://www.unicode.org/reports/tr35/tr35-dates.html#dfst-zone
     */
    CalendarFormatterImpl.prototype.timezone_z = function (ctx, node) {
        if (node[1] > 4) {
            return '';
        }
        var key2 = ctx.date.metaZoneId();
        if (key2) {
            var _a = this.tz.metaZones, long = _a.long, short = _a.short;
            var format = node[1] === 4 ? long : short;
            var name_1 = format.get(ctx.bundle, ctx.date.isDaylightSavings() ? 'daylight' : 'standard', key2);
            if (name_1) {
                return name_1;
            }
        }
        return this.timezone_O(ctx, node);
    };
    /**
     * Timezone: ISO8601 basic/extended format, long localized GMT format.
     * https://www.unicode.org/reports/tr35/tr35-dates.html#dfst-zone
     */
    CalendarFormatterImpl.prototype.timezone_Z = function (ctx, node) {
        var width = node[1];
        if (width === 4) {
            return this.timezone_O(ctx, ['O', width]);
        }
        var _a = getTZC(ctx.date.timeZoneOffset()), negative = _a[1], hours = _a[2], minutes = _a[3];
        var fmt = '';
        if (width <= 5) {
            // TODO: use number params
            fmt += negative ? '-' : '+';
            fmt += _num(ctx, hours, 2);
            if (width === 5) {
                fmt += ':';
            }
            fmt += _num(ctx, minutes, 2);
        }
        return fmt;
    };
    /**
     * Timezone: short/long localized GMT format.
     */
    CalendarFormatterImpl.prototype.timezone_O = function (ctx, node) {
        return node[1] === 1 || node[1] === 4 ? this._wrapGMT(ctx, node[1] === 1) : '';
    };
    /**
     * Timezone: short/long generic non-location format.
     */
    CalendarFormatterImpl.prototype.timezone_v = function (ctx, node) {
        var width = node[1];
        if (width !== 1 && width !== 4) {
            return '';
        }
        var name = '';
        var key = ctx.date.metaZoneId();
        var _a = this.tz.metaZones, long = _a.long, short = _a.short;
        var format = width === 1 ? short : long;
        name = format.get(ctx.bundle, 'generic', key);
        return name ? name : this.timezone_O(ctx, ['O', width]);
    };
    /**
     * Timezone: short/long zone ID, exemplar city, generic location format.
     * https://www.unicode.org/reports/tr35/tr35-dates.html#dfst-zone
     */
    CalendarFormatterImpl.prototype.timezone_V = function (ctx, node) {
        var bundle = ctx.bundle;
        var stableId = ctx.date.timeZoneStableId();
        var exemplarCity = this.tz.exemplarCity;
        var city = '';
        switch (node[1]) {
            case 4:
                city = exemplarCity.get(bundle, stableId);
                if (!city) {
                    return this.timezone_O(ctx, ['O', 4]);
                }
                var pattern = this.tz.regionFormat.get(bundle);
                return this.general.formatWrapper(pattern, [city]);
            case 3:
                // Exemplar city for the timezone.
                city = exemplarCity.get(bundle, stableId);
                return city ? city : exemplarCity.get(bundle, 'Etc/Unknown');
            case 2:
                var zoneId = ctx.date.timeZoneId();
                return zoneId;
            case 1:
                return 'unk';
        }
        return '';
    };
    /**
     * Timezone: ISO8601 basic format
     * https://www.unicode.org/reports/tr35/tr35-dates.html#dfst-zone
     */
    CalendarFormatterImpl.prototype.timezone_x = function (ctx, node) {
        var field = node[0], width = node[1];
        var _a = getTZC(ctx.date.timeZoneOffset()), offset = _a[0], negative = _a[1], hours = _a[2], minutes = _a[3];
        var fmt = '';
        if (width >= 1 && width <= 5) {
            var zero = hours === 0 && minutes === 0;
            fmt += zero ? '+' : negative ? '-' : '+';
            fmt += _num(ctx, hours, 2);
            if (width === 3 || width === 5) {
                fmt += ':';
            }
            if (width !== 1 || minutes > 0) {
                fmt += _num(ctx, minutes, 2);
            }
            if (field === 'X' && offset === 0) {
                fmt += 'Z';
            }
        }
        return fmt;
    };
    CalendarFormatterImpl.prototype._wrapGMT = function (ctx, short) {
        var bundle = ctx.bundle, date = ctx.date;
        var _offset = date.timeZoneOffset();
        if (_offset === 0) {
            return this.tz.gmtZeroFormat.get(bundle);
        }
        var _a = getTZC(_offset), negative = _a[1], hours = _a[2], minutes = _a[3];
        var emitMins = !short || minutes > 0;
        var hourPattern = this._hourPattern(bundle, negative);
        var fmt = '';
        for (var _i = 0, hourPattern_1 = hourPattern; _i < hourPattern_1.length; _i++) {
            var n = hourPattern_1[_i];
            if (typeof n === 'string') {
                var sep = n === '.' || n === ':';
                if (!sep || emitMins) {
                    fmt += n;
                }
            }
            else {
                var field = n[0], width = n[1];
                if (field === 'H') {
                    fmt += width === 1 ? _num(ctx, hours, 1) : _num(ctx, hours, short ? 1 : width);
                }
                else if (field === 'm' && emitMins) {
                    fmt += _num(ctx, minutes, width);
                }
            }
        }
        var wrap = this.tz.gmtFormat.get(bundle);
        return this.general.formatWrapper(wrap, [fmt]);
    };
    CalendarFormatterImpl.prototype._hourPattern = function (bundle, negative) {
        var raw = this.tz.hourFormat.get(bundle);
        return this.internals.calendars.getHourPattern(raw, negative);
    };
    return CalendarFormatterImpl;
}());
export { CalendarFormatterImpl };
//# sourceMappingURL=formatterimpl.js.map