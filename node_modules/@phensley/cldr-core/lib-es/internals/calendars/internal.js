import { Cache } from '@phensley/cldr-utils';
import { calendarIds, calendarPrefData } from './autogen.calprefs';
import { weekFirstDay, weekMinDays } from './autogen.weekdata';
import { CalendarFormatterImpl } from './formatterimpl';
import { intervalPatternBoundary, parseDatePattern } from '../../parsing/date';
import { DayPeriodRules } from './rules';
/**
 * Framework scoped calendar functions.
 *
 * @internal
 */
var CalendarInternalsImpl = /** @class */ (function () {
    function CalendarInternalsImpl(internals, cacheSize) {
        var _this = this;
        this.internals = internals;
        this.schema = internals.schema;
        this.dayPeriodRules = new DayPeriodRules(cacheSize);
        this.patternCache = new Cache(parseDatePattern, cacheSize);
        this.availableCalendars = new Set(internals.config.calendars || []);
        this.hourPatternCache = new Cache(function (raw) {
            var parts = raw.split(';');
            return [_this.patternCache.get(parts[0]), _this.patternCache.get(parts[1])];
        }, cacheSize);
        this.calendarFormatterCache = new Cache(function (calendar) {
            var s;
            if (_this.availableCalendars.has(calendar)) {
                switch (calendar) {
                    case 'buddhist':
                        s = _this.schema.Buddhist;
                        break;
                    case 'japanese':
                        s = _this.schema.Japanese;
                        break;
                    case 'persian':
                        s = _this.schema.Persian;
                        break;
                }
            }
            if (s === undefined) {
                s = _this.schema.Gregorian;
            }
            return new CalendarFormatterImpl(_this.internals, s);
        }, cacheSize);
    }
    CalendarInternalsImpl.prototype.flexDayPeriod = function (bundle, minutes) {
        return this.dayPeriodRules.get(bundle, minutes);
    };
    CalendarInternalsImpl.prototype.getCalendarFormatter = function (type) {
        return this.calendarFormatterCache.get(type);
    };
    CalendarInternalsImpl.prototype.parseDatePattern = function (raw) {
        return this.patternCache.get(raw);
    };
    CalendarInternalsImpl.prototype.getHourPattern = function (raw, negative) {
        var patterns = this.hourPatternCache.get(raw);
        return patterns[negative ? 1 : 0];
    };
    CalendarInternalsImpl.prototype.weekFirstDay = function (region) {
        return weekFirstDay[region] || weekFirstDay['001'];
    };
    CalendarInternalsImpl.prototype.weekMinDays = function (region) {
        return weekMinDays[region] || weekMinDays['001'];
    };
    CalendarInternalsImpl.prototype.formatDateTime = function (calendar, ctx, value, first, date, time, wrapper) {
        var formatter = this.getCalendarFormatter(calendar);
        var _date;
        var _time;
        if (date) {
            formatter.format(value, ctx, date, first);
            _date = value.render();
        }
        if (time) {
            formatter.format(value, ctx, time, !!date && first);
            _time = value.render();
        }
        if (_date && _time && wrapper) {
            var pattern = this.internals.general.parseWrapper(wrapper);
            value.wrap(pattern, [_time, _date]);
            return value.render();
        }
        return _date ? _date : _time ? _time : value.empty();
    };
    CalendarInternalsImpl.prototype.formatInterval = function (calendar, ctx, value, first, end, pattern) {
        var idx = intervalPatternBoundary(pattern);
        var s = this.formatDateTime(calendar, ctx, value, first, pattern.slice(0, idx));
        ctx.date = end;
        var e = this.formatDateTime(calendar, ctx, value, false, pattern.slice(idx));
        return value.join(s, e);
    };
    CalendarInternalsImpl.prototype.selectCalendar = function (bundle, ca) {
        var calendar = this.supportedCalendar(ca) || this.supportedCalendar(bundle.calendarSystem());
        if (!calendar) {
            var prefs = calendarPrefData[bundle.region()] || calendarPrefData['001'];
            for (var _i = 0, prefs_1 = prefs; _i < prefs_1.length; _i++) {
                var id = prefs_1[_i];
                calendar = this.supportedCalendar(calendarIds[id]);
                if (calendar) {
                    return calendar;
                }
            }
            return 'gregory';
        }
        return calendar;
    };
    /**
     * Translates a string into a supported calendar type, or undefined if none match.
     */
    CalendarInternalsImpl.prototype.supportedCalendar = function (c) {
        // NOTE: cldr constrains identifiers to have segments that are 8 characters in length,
        // so "gregorian" is invalid. instead, "gregory" is used. "islamic-umalqura" is valid since
        // each segment is <= 8 characters. check for "gregorian" here.
        if (c === 'gregorian') {
            c = 'gregory';
        }
        if (c && this.availableCalendars.has(c)) {
            switch (c) {
                case 'buddhist':
                case 'iso8601':
                case 'japanese':
                case 'persian':
                case 'gregory':
                    return c;
            }
        }
        return undefined;
    };
    return CalendarInternalsImpl;
}());
export { CalendarInternalsImpl };
//# sourceMappingURL=internal.js.map