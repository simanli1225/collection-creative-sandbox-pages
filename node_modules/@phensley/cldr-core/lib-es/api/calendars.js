import { TZ } from '@phensley/timezone';
import { BuddhistDate, CalendarDate, GregorianDate, ISO8601Date, JapaneseDate, PersianDate, TIME_PERIOD_FIELDS, } from '../systems/calendars';
import { CalendarManager } from '../internals/calendars/manager';
import { PartsValue, StringValue } from '../utils/render';
import { getStableTimeZoneId, substituteZoneAlias, currentMetazone } from '../systems/calendars/timezone';
import { TimeZoneTypeIndex } from '../schema';
var DOW_FIELDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
/**
 * @internal
 */
var CalendarsImpl = /** @class */ (function () {
    function CalendarsImpl(bundle, internals, privateApi) {
        this.bundle = bundle;
        this.internals = internals;
        this.privateApi = privateApi;
        this.manager = new CalendarManager(bundle, internals);
        var region = bundle.region();
        this._firstDay = internals.calendars.weekFirstDay(region);
        this._minDays = internals.calendars.weekMinDays(region);
    }
    CalendarsImpl.prototype.firstDayOfWeek = function () {
        return this._firstDay;
    };
    CalendarsImpl.prototype.minDaysInFirstWeek = function () {
        return this._minDays;
    };
    CalendarsImpl.prototype.dateField = function (type, opt) {
        opt = opt || {};
        var field = this.internals.schema.DateFields.displayName.get(this.bundle, type, opt.width || 'wide');
        return this._transformField(field, 'calendar-field', opt.context);
    };
    CalendarsImpl.prototype.dayPeriods = function (opt) {
        opt = opt || {};
        var fields = this._getPatterns(opt.ca).dayPeriods()[opt.width || 'wide'];
        return this._transformFields(fields, undefined, opt.context);
    };
    CalendarsImpl.prototype.eras = function (opt) {
        opt = opt || {};
        var w = opt.width || 'names';
        var fields = this._getPatterns(opt.ca).eras()[w];
        var tx = w === 'abbr' ? 'era-abbr' : w === 'names' ? 'era-name' : undefined;
        return this._transformFields(fields, tx, opt.context);
    };
    CalendarsImpl.prototype.months = function (opt) {
        opt = opt || {};
        var w = opt.width === 'short' ? 'narrow' : opt.width || 'wide';
        var fields = this._getPatterns(opt.ca).months()[w];
        var tx = w !== 'narrow' ? 'month-standalone-except-narrow' : undefined;
        return this._transformFields(fields, tx, opt.context);
    };
    CalendarsImpl.prototype.quarters = function (opt) {
        opt = opt || {};
        var fields = this._getPatterns(opt.ca).quarters()[opt.width || 'wide'];
        return this._transformFields(fields, undefined, opt.context);
    };
    CalendarsImpl.prototype.weekdays = function (opt) {
        opt = opt || {};
        var w = opt.width || 'wide';
        var fields = this._getPatterns(opt.ca).weekdays()[w];
        var tx = w !== 'narrow' ? 'day-standalone-except-narrow' : undefined;
        return this._transformFields(fields, tx, opt.context);
    };
    /**
     * Alias for nowGregorian()
     */
    CalendarsImpl.prototype.now = function (zoneId) {
        return this.nowGregorian(zoneId);
    };
    /**
     * Convert the given date to the Buddhist calendar.
     */
    CalendarsImpl.prototype.toBuddhistDate = function (date) {
        return this.convertDate(BuddhistDate.fromUnixEpoch, date);
    };
    /**
     * Construct a new date in the Buddhist calendar with the given fields.
     */
    CalendarsImpl.prototype.newBuddhistDate = function (fields) {
        return BuddhistDate.fromFields(fields, this._firstDay, this._minDays);
    };
    /**
     * Construct a new date in the Buddhist calendar representing the current date and time.
     */
    CalendarsImpl.prototype.nowBuddhist = function (zoneId) {
        return BuddhistDate.fromUnixEpoch(new Date().getTime(), zoneId || '', this._firstDay, this._minDays);
    };
    /**
     * Convert the given date to the Gregorian calendar.
     */
    CalendarsImpl.prototype.toGregorianDate = function (date) {
        return this.convertDate(GregorianDate.fromUnixEpoch, date);
    };
    /**
     * Construct a new date in the Gregorian calendar with the given fields.
     */
    CalendarsImpl.prototype.newGregorianDate = function (fields) {
        return GregorianDate.fromFields(fields, this._firstDay, this._minDays);
    };
    /**
     * Construct a new date in the Gregorian calendar representing the current date and time.
     */
    CalendarsImpl.prototype.nowGregorian = function (zoneId) {
        return GregorianDate.fromUnixEpoch(new Date().getTime(), zoneId || '', this._firstDay, this._minDays);
    };
    /**
     * Convert the given date to the ISO-8601 calendar.
     */
    CalendarsImpl.prototype.toISO8601Date = function (date) {
        return this.convertDate(ISO8601Date.fromUnixEpoch, date);
    };
    /**
     * Construct a new date in the ISO-8601 calendar with the given fields.
     */
    CalendarsImpl.prototype.newISO8601Date = function (fields) {
        return ISO8601Date.fromFields(fields, this._firstDay, this._minDays);
    };
    /**
     * Construct a new date in the ISO8601 calendar representing the current date and time.
     */
    CalendarsImpl.prototype.nowISO8601 = function (zoneId) {
        return ISO8601Date.fromUnixEpoch(new Date().getTime(), zoneId || '', this._firstDay, this._minDays);
    };
    /**
     * Convert the given date to the Japanese calendar.
     */
    CalendarsImpl.prototype.toJapaneseDate = function (date) {
        return this.convertDate(JapaneseDate.fromUnixEpoch, date);
    };
    /**
     * Construct a new date in the Japanese calendar with the given fields.
     */
    CalendarsImpl.prototype.newJapaneseDate = function (fields) {
        return JapaneseDate.fromFields(fields, this._firstDay, this._minDays);
    };
    /**
     * Construct a new date in the Japanese calendar representing the current date and time.
     */
    CalendarsImpl.prototype.nowJapanese = function (zoneId) {
        return JapaneseDate.fromUnixEpoch(new Date().getTime(), zoneId || '', this._firstDay, this._minDays);
    };
    /**
     * Convert the given date to the Persian calendar.
     */
    CalendarsImpl.prototype.toPersianDate = function (date) {
        return this.convertDate(PersianDate.fromUnixEpoch, date);
    };
    /**
     * Construct a new date in the Persian calendar with the given fields.
     */
    CalendarsImpl.prototype.newPersianDate = function (fields) {
        return PersianDate.fromFields(fields, this._firstDay, this._minDays);
    };
    /**
     * Construct a new date in the Persian calendar representing the current date and time.
     */
    CalendarsImpl.prototype.nowPersian = function (zoneId) {
        return PersianDate.fromUnixEpoch(new Date().getTime(), zoneId || '', this._firstDay, this._minDays);
    };
    /**
     * Find the field of visual difference between two dates. For example, the
     * dates "2019-03-31" and "2019-04-01" differ visually in the month field,
     * even though the dates are only 1 day apart.
     *
     * This can be used by applications to select an appropriate skeleton for date
     * interval formatting, e.g. to format "March 31 - April 01, 2019"
     */
    CalendarsImpl.prototype.fieldOfVisualDifference = function (a, b) {
        // Date is interpreted as UTC
        if (a instanceof Date) {
            a = { date: a };
        }
        if (b instanceof Date) {
            b = { date: b };
        }
        // Determine calendar type to use for comparison, falling back to the default for the
        // current locale.
        var type = a instanceof CalendarDate
            ? a.type()
            : b instanceof CalendarDate
                ? b.type()
                : this.internals.calendars.selectCalendar(this.bundle);
        // Convert a and b to CalendarDate having the correct type, ensuring their types and timezones match.
        if (!(a instanceof CalendarDate) || type !== a.type()) {
            a = this.convertDateTo(type, a);
        }
        if (!(b instanceof CalendarDate) || type !== b.type() || a.timeZoneId() !== b.timeZoneId()) {
            b = this.convertDateTo(type, b, a.timeZoneId());
        }
        return a.fieldOfVisualDifference(b);
    };
    /**
     * Format a calendar date to string using the given options.
     */
    CalendarsImpl.prototype.formatDate = function (date, options) {
        return this._formatDate(new StringValue(), date, options);
    };
    /**
     * Format a calendar date to a parts array using the given options.
     */
    CalendarsImpl.prototype.formatDateToParts = function (date, options) {
        return this._formatDate(new PartsValue(), date, options);
    };
    CalendarsImpl.prototype.formatDateInterval = function (start, end, options) {
        return this._formatInterval(new StringValue(), start, end, options);
    };
    CalendarsImpl.prototype.formatDateIntervalToParts = function (start, end, options) {
        return this._formatInterval(new PartsValue(), start, end, options);
    };
    // TODO: need to sort out the options
    // formatRelativeTime(start: CalendarDate | ZonedDateTime, end: CalendarDate | ZonedDateTime,
    //     options?: RelativeTimeFormatOptions): string {
    //   options = options || DEFAULT_RELTIME_OPTIONS;
    //   const params = this.privateApi.getNumberParams(options.nu);
    //   const calendar = this.internals.calendars.selectCalendar(this.bundle);
    //   start = this.convertDateTo(calendar, start);
    //   end = this.convertDateTo(calendar, end, start.timeZoneId());
    //   return this.internals.dateFields.formatRelativeTime(
    //     this.bundle, start, end, options, params);
    // }
    CalendarsImpl.prototype.formatRelativeTimeField = function (value, field, options) {
        options = options || { width: 'wide' };
        var transform = this.privateApi.getContextTransformInfo();
        var params = this.privateApi.getNumberParams(options.nu);
        return this.internals.dateFields.formatRelativeTimeField(this.bundle, value, field, options, params, transform);
    };
    CalendarsImpl.prototype.formatRelativeTime = function (start, end, options) {
        options = options || { width: 'wide', maximumFractionDigits: 0, group: true };
        var calendar = this.internals.calendars.selectCalendar(this.bundle, options.ca);
        var _start = this.convertDateTo(calendar, start);
        var _end = this.convertDateTo(calendar, end);
        var _a = _start.relativeTime(_end, options.field), field = _a[0], amount = _a[1];
        if (_start.compare(_end) === 1) {
            amount *= -1;
        }
        if (field === 'millis') {
            amount /= 1000.0;
            field = 'second';
        }
        var _field = field;
        // See if we can use day of week formatting
        if (options.dayOfWeek && field === 'week' && _start.dayOfWeek() === _end.dayOfWeek()) {
            var dow = _end.dayOfWeek() - 1;
            _field = DOW_FIELDS[dow];
        }
        return this.formatRelativeTimeField(amount, _field, options);
    };
    /**
     * Format a raw date pattern. Note: This should not be used, but is available for debugging or
     * extreme cases where an application must implement a custom format.
     */
    CalendarsImpl.prototype.formatDateRaw = function (date, options) {
        return this._formatDateRaw(new StringValue(), date, options || {});
    };
    CalendarsImpl.prototype.formatDateRawToParts = function (date, options) {
        return this._formatDateRaw(new PartsValue(), date, options || {});
    };
    CalendarsImpl.prototype.formatDateWrapper = function (date, time, options) {
        return this._formatDateWrapper(new StringValue(), date, time, options || {});
    };
    CalendarsImpl.prototype.formatDateWrapperToParts = function (date, time, options) {
        return this._formatDateWrapper(new PartsValue(), date, time, options || {});
    };
    CalendarsImpl.prototype.timeData = function () {
        var patterns = this._getPatterns('gregory');
        var _a = patterns.getTimeData(), allowed = _a[0], preferred = _a[1];
        return {
            preferred: preferred,
            allowed: allowed.split(' '),
        };
    };
    CalendarsImpl.prototype.timeZoneIds = function () {
        return TZ.zoneIds();
    };
    CalendarsImpl.prototype.resolveTimeZoneId = function (zoneid) {
        return TZ.resolveId(substituteZoneAlias(zoneid));
    };
    CalendarsImpl.prototype.timeZoneInfo = function (zoneid) {
        var tz = this.internals.schema.TimeZones;
        if (!this.exemplarCities) {
            this.exemplarCities = tz.exemplarCity.mapping(this.bundle);
        }
        var id = this.resolveTimeZoneId(zoneid) || 'Factory';
        var stableid = getStableTimeZoneId(id);
        var city = this.exemplarCities[stableid] || this.exemplarCities['Etc/Unknown'];
        var metazone = (currentMetazone(id) || '');
        var names = {
            long: { generic: '', standard: '', daylight: '' },
            short: { generic: '', standard: '', daylight: '' },
        };
        for (var _i = 0, _a = TimeZoneTypeIndex.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            names.long[key] = tz.metaZones.long.get(this.bundle, key, metazone);
            names.short[key] = tz.metaZones.short.get(this.bundle, key, metazone);
        }
        var _b = TZ.zoneMeta(id), countries = _b.countries, latitude = _b.latitude, longitude = _b.longitude, stdoffset = _b.stdoffset; // Factory fallback will return a record
        return {
            id: id,
            city: {
                name: city,
            },
            countries: countries,
            latitude: latitude,
            longitude: longitude,
            stdoffset: stdoffset,
            metazone: metazone,
            names: names,
        };
    };
    CalendarsImpl.prototype.timeZoneFromUTC = function (utc, zoneid) {
        return TZ.fromUTC(zoneid, utc);
    };
    CalendarsImpl.prototype.timeZoneFromWall = function (wall, zoneid) {
        return TZ.fromWall(zoneid, wall);
    };
    CalendarsImpl.prototype.timePeriodToQuantity = function (period) {
        var q = [];
        for (var _i = 0, TIME_PERIOD_FIELDS_1 = TIME_PERIOD_FIELDS; _i < TIME_PERIOD_FIELDS_1.length; _i++) {
            var f = TIME_PERIOD_FIELDS_1[_i];
            var v = period[f];
            if (v) {
                var unit = f === 'millis' ? 'millisecond' : f;
                q.push({ unit: unit, value: v });
            }
        }
        return q;
    };
    CalendarsImpl.prototype._getPatterns = function (type) {
        var calendar = this.internals.calendars.selectCalendar(this.bundle, type);
        return this.manager.getCalendarPatterns(calendar);
    };
    /**
     * Copy fields, applying an optional context transform to the values.
     */
    CalendarsImpl.prototype._transformFields = function (fields, type, context) {
        var res = {};
        if (fields) {
            for (var _i = 0, _a = Object.keys(fields); _i < _a.length; _i++) {
                var key = _a[_i];
                var val = fields[key];
                res[key] =
                    typeof val === 'string'
                        ? this._transformField(val, type, context)
                        : this._transformFields(val, type, context);
            }
        }
        return res;
    };
    CalendarsImpl.prototype._transformField = function (field, type, context) {
        var info = this.privateApi.getContextTransformInfo();
        return context ? this.internals.general.contextTransform(field, info, context, type) : field;
    };
    CalendarsImpl.prototype._formatDate = function (value, date, options) {
        var calendars = this.internals.calendars;
        options = options || { date: 'full' };
        var calendar = calendars.selectCalendar(this.bundle, options.ca);
        var params = this.privateApi.getNumberParams(options.nu, 'default');
        date = this.convertDateTo(calendar, date);
        var req = this.manager.getDateFormatRequest(date, options, params);
        var ctx = this._context(date, params, options.context, options.alt);
        return calendars.formatDateTime(calendar, ctx, value, true, req.date, req.time, req.wrapper);
    };
    CalendarsImpl.prototype._formatInterval = function (value, start, end, options) {
        // options = options || { skeleton: 'yMd' };
        options = options || {};
        var calendar = this.internals.calendars.selectCalendar(this.bundle, options.ca);
        start = this.convertDateTo(calendar, start);
        end = this.convertDateTo(calendar, end);
        var fieldDiff = this.fieldOfVisualDifference(start, end);
        var params = this.privateApi.getNumberParams(options.nu, 'default');
        var req = this.manager.getDateIntervalFormatRequest(calendar, start, fieldDiff, options, params);
        if (req.skeleton) {
            var ca = options.ca, nu = options.nu;
            var r = this.manager.getDateFormatRequest(start, { ca: ca, nu: nu, skeleton: req.skeleton }, params);
            var ctx = this._context(start, params, options.context, options.alt);
            var _start = this.internals.calendars.formatDateTime(calendar, ctx, value, true, r.date, r.time, r.wrapper);
            ctx.date = end;
            var _end = this.internals.calendars.formatDateTime(calendar, ctx, value, false, r.date, r.time, r.wrapper);
            var wrapper = this.internals.general.parseWrapper(req.wrapper);
            value.wrap(wrapper, [_start, _end]);
            return value.render();
        }
        var _date;
        if (req.date) {
            var ctx = this._context(start, params, options.context, options.alt);
            _date = this.internals.calendars.formatDateTime(calendar, ctx, value, true, req.date);
        }
        if (req.range) {
            var ctx = this._context(start, params, options.context, options.alt);
            var _range = this.internals.calendars.formatInterval(calendar, ctx, value, !_date, end, req.range);
            if (!_date) {
                return _range;
            }
            // Note: This case is covered in ICU but not mentioned in the CLDR docs. Use the MEDIUM
            // dateTimeFormat to join a common date with a time range.
            // Ticket referencing the discrepancy:
            // https://www.unicode.org/cldr/trac/ticket/11158
            // Docs don't mention this edge case:
            // https://www.unicode.org/reports/tr35/tr35-dates.html#intervalFormats
            var patterns = this.manager.getCalendarPatterns(calendar);
            var atTime = options.atTime === false ? false : true;
            var wrapper = this.internals.general.parseWrapper(patterns.getWrapperPattern('medium', atTime));
            value.wrap(wrapper, [_range, _date]);
            return value.render();
        }
        // Here, the request should always be:
        //   { date }
        //   { date, range }
        //   { range }
        // Unless the schema config contains no relevant patterns.
        return _date || value.empty();
    };
    CalendarsImpl.prototype._context = function (date, params, context, alt) {
        if (alt === void 0) { alt = {}; }
        return {
            alt: alt,
            date: date,
            bundle: this.bundle,
            system: params.system,
            latnSystem: params.latnSystem,
            context: context,
            transform: this.privateApi.getContextTransformInfo(),
        };
    };
    CalendarsImpl.prototype._formatDateRaw = function (value, date, options) {
        if (!options.pattern) {
            return value.empty();
        }
        var pattern = this.internals.calendars.parseDatePattern(options.pattern);
        var calendar = this.internals.calendars.selectCalendar(this.bundle, options.ca);
        var params = this.privateApi.getNumberParams(options.nu, 'default');
        var ctx = this._context(this.convertDateTo(calendar, date), params, options.context, options.alt);
        return this.internals.calendars.formatDateTime(calendar, ctx, value, true, pattern);
    };
    CalendarsImpl.prototype._formatDateWrapper = function (value, date, time, options) {
        var calendar = this.internals.calendars.selectCalendar(this.bundle, options.ca);
        var patterns = this.manager.getCalendarPatterns(calendar);
        var atTime = options.atTime === false ? false : true;
        var wrapper = this.internals.general.parseWrapper(patterns.getWrapperPattern(options.width || 'medium', atTime));
        value.wrap(wrapper, [time, date]);
        return value.render();
    };
    CalendarsImpl.prototype.convertDate = function (cons, date) {
        if (date instanceof Date) {
            date = { date: date, zoneId: 'UTC' };
        }
        return date instanceof CalendarDate
            ? this.convertEpoch(cons, date.unixEpoch(), date.timeZoneId())
            : this.convertEpoch(cons, getEpochUTC(date.date), date.zoneId || 'UTC');
    };
    CalendarsImpl.prototype.convertEpoch = function (cons, epoch, zoneId) {
        return cons(epoch, zoneId, this._firstDay, this._minDays);
    };
    CalendarsImpl.prototype.convertDateTo = function (target, date, zoneId) {
        if (date instanceof CalendarDate && target === date.type() && (!zoneId || zoneId === date.timeZoneId())) {
            return date;
        }
        else if (date instanceof Date) {
            date = { date: date, zoneId: zoneId };
        }
        switch (target) {
            case 'buddhist':
                return this.toBuddhistDate(date);
            case 'japanese':
                return this.toJapaneseDate(date);
            case 'persian':
                return this.toPersianDate(date);
        }
        // All others convert to 'gregory'
        return this.toGregorianDate(date);
    };
    return CalendarsImpl;
}());
export { CalendarsImpl };
var getEpochUTC = function (date) {
    var n = +date;
    return isFinite(n) ? n : 0;
};
//# sourceMappingURL=calendars.js.map