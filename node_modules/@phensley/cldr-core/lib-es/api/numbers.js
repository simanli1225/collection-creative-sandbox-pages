import { coerceDecimal } from '@phensley/decimal';
import { getCurrencyForRegion, getCurrencyFractions, } from '../internals';
var DEFAULT_CURRENCY_OPTIONS = { context: 'begin-sentence' };
/**
 * Number and currency formatting.
 *
 * @internal
 */
var NumbersImpl = /** @class */ (function () {
    function NumbersImpl(bundle, numbers, general, privateApi) {
        this.bundle = bundle;
        this.numbers = numbers;
        this.general = general;
        this.privateApi = privateApi;
        this.transform = privateApi.getContextTransformInfo();
    }
    NumbersImpl.prototype.adjustDecimal = function (n, opts) {
        return this.numbers.adjustDecimal(coerceDecimal(n), opts);
    };
    NumbersImpl.prototype.parseDecimal = function (n) {
        return coerceDecimal(n);
    };
    NumbersImpl.prototype.getCurrencySymbol = function (code, width) {
        return this.numbers.getCurrencySymbol(this.bundle, code, width);
    };
    NumbersImpl.prototype.getCurrencyDisplayName = function (code, opts) {
        if (opts === void 0) { opts = DEFAULT_CURRENCY_OPTIONS; }
        var name = this.numbers.getCurrencyDisplayName(this.bundle, code);
        return this.general.contextTransform(name, this.transform, _ctx(opts), 'currencyName');
    };
    NumbersImpl.prototype.getCurrencyFractions = function (code) {
        return getCurrencyFractions(code);
    };
    NumbersImpl.prototype.getCurrencyForRegion = function (region) {
        return getCurrencyForRegion(region);
    };
    NumbersImpl.prototype.getCurrencyPluralName = function (n, code, opts) {
        if (opts === void 0) { opts = DEFAULT_CURRENCY_OPTIONS; }
        var plural = this.getPluralCardinal(n);
        var name = this.numbers.getCurrencyPluralName(this.bundle, code, plural);
        return this.general.contextTransform(name, this.transform, _ctx(opts), 'currencyName');
    };
    NumbersImpl.prototype.getPluralCardinal = function (n, options) {
        var d = options ? this.adjustDecimal(n, options) : coerceDecimal(n);
        return this.bundle.plurals().cardinal(d);
    };
    NumbersImpl.prototype.getPluralOrdinal = function (n, options) {
        var d = options ? this.adjustDecimal(n, options) : coerceDecimal(n);
        return this.bundle.plurals().ordinal(d);
    };
    NumbersImpl.prototype.formatDecimal = function (n, options) {
        options = options || {};
        var params = this.privateApi.getNumberParams(options.nu);
        var renderer = this.numbers.stringRenderer(params);
        return this.formatDecimalImpl(renderer, params, n, options);
    };
    NumbersImpl.prototype.formatDecimalToParts = function (n, options) {
        options = options || {};
        var params = this.privateApi.getNumberParams(options.nu);
        var renderer = this.numbers.partsRenderer(params);
        return this.formatDecimalImpl(renderer, params, n, options);
    };
    NumbersImpl.prototype.formatCurrency = function (n, code, options) {
        options = options || {};
        var params = this.privateApi.getNumberParams(options.nu, 'finance');
        var renderer = this.numbers.stringRenderer(params);
        return this.formatCurrencyImpl(renderer, params, n, code, options);
    };
    NumbersImpl.prototype.formatCurrencyToParts = function (n, code, options) {
        options = options || {};
        var params = this.privateApi.getNumberParams(options.nu, 'finance');
        var renderer = this.numbers.partsRenderer(params);
        return this.formatCurrencyImpl(renderer, params, n, code, options);
    };
    NumbersImpl.prototype.formatDecimalImpl = function (renderer, params, n, options) {
        // A NaN or Infinity value will just return the locale's representation
        var d = coerceDecimal(n);
        var v = validate(d, options, renderer, params);
        if (v !== undefined) {
            return v;
        }
        var result = this.numbers.formatDecimal(this.bundle, renderer, d, options, params)[0];
        return result;
    };
    NumbersImpl.prototype.formatCurrencyImpl = function (renderer, params, n, code, options) {
        // Not much to be done with NaN and Infinity with currencies, so we always
        // throw an error.
        var d = coerceDecimal(n);
        validate(d, FORCE_ERRORS, renderer, params);
        return this.numbers.formatCurrency(this.bundle, renderer, coerceDecimal(n), code, options, params);
    };
    return NumbersImpl;
}());
export { NumbersImpl };
var FORCE_ERRORS = { errors: ['nan', 'infinity'] };
/**
 * Check if the number is a NaN or Infinity and whether this should throw
 * an error, or return the locale's string representation.
 */
var validate = function (n, opts, renderer, params) {
    // Check if we have NaN or Infinity
    var isnan = n.isNaN();
    var isinfinity = n.isInfinity();
    if (Array.isArray(opts.errors)) {
        // Check if we should throw an error on either of these
        if (isnan && opts.errors.indexOf('nan') !== -1) {
            throw Error("Invalid argument: NaN");
        }
        if (isinfinity && opts.errors.indexOf('infinity') !== -1) {
            throw Error("Invalid argument: Infinity");
        }
    }
    return isnan
        ? renderer.make('nan', params.symbols.nan)
        : isinfinity
            ? renderer.make('infinity', params.symbols.infinity)
            : undefined;
};
// Default an options context value
var _ctx = function (o) { return _def(o, 'context', 'begin-sentence'); };
// Default an option value
var _def = function (o, k, t) { return o[k] || t; };
//# sourceMappingURL=numbers.js.map