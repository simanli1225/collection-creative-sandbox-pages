import { Schema } from '@phensley/cldr-types';
import { SchemaConfig } from './schema';
import { LRU } from '@phensley/cldr-utils';
import { Calendars, General, Numbers, Units } from './api';
import { Internals } from './internals';
import { LanguageTag } from '@phensley/language-tag';
import { Locale } from '@phensley/locale';
import { Pack } from './resource';
/**
 * Interface exporting all functionality for a given locale.
 *
 * @public
 */
export interface CLDR {
    /**
     * Calendar functions.
     */
    readonly Calendars: Calendars;
    /**
     * General functions.
     */
    readonly General: General;
    /**
     * Number and currency functions.
     */
    readonly Numbers: Numbers;
    /**
     * Unit quantity functions.
     */
    readonly Units: Units;
    /**
     * UNDOCUMENTED AND EXPERIMENTAL
     *
     * Provides access to the low-level schema for accessing CLDR fields.
     *
     * Currently undocumented. In the future an internal api can be
     * exposed allowing access to low-level functions of the library.
     *
     * @internal
     */
    readonly Schema: Schema;
    /**
     * UNDOCUMENTED AND EXPERIMENTAL
     *
     * Provides access to the low-level library internals.
     *
     * @internal
     */
    readonly Internals: Internals;
}
/**
 * Options to initialize the library.
 *
 * @public
 */
export interface CLDROptions {
    /**
     * Log some messages.
     */
    debug?: boolean;
    /**
     * Customizing of the schema.
     */
    config?: SchemaConfig;
    /**
     * Given a language identifier, fetch the resource pack from the
     * filesystem, webserver, etc, and return the raw decompressed string.
     */
    loader?: (language: string) => any;
    asyncLoader?: (language: string) => Promise<any>;
    /**
     * Number of language-wide resource packs to keep in memory.
     *
     * Note: a language pack will only be garbage collected once all instances
     * using it are garbage collected, so if you hold onto instances the cache
     * may be ineffective.
     */
    packCacheSize?: number;
    /**
     * Size of internal pattern caches.
     */
    patternCacheSize?: number;
    /**
     * Skip calculting the schema checksums. The checksum detects when the schema
     * does not match the loaded resource pack and throws an error.
     */
    skipChecksum?: boolean;
}
/**
 * Top-level entry point for the library. It's only purpose at the
 * moment is to construct API instances for a particular locale.
 * All other functionality should be available statically through
 * exported types and functions.
 *
 * @public
 */
export declare class CLDRFramework {
    protected options: CLDROptions;
    protected readonly packCache: LRU<Pack>;
    protected readonly loader?: (language: string) => any;
    protected readonly asyncLoader?: (language: string) => Promise<any>;
    protected readonly internals: Internals;
    protected readonly _config: SchemaConfig;
    protected static defaultConfig?: SchemaConfig;
    constructor(options: CLDROptions);
    /**
     * Specify a configuration to use as a fallback.
     */
    static setDefaultConfig(config: SchemaConfig): void;
    config(): SchemaConfig;
    info(): string;
    /**
     * Return the library version.
     */
    static version(): string;
    /**
     * Return an array of the available locales.
     */
    static availableLocales(): Locale[];
    /**
     * Parse a locale identifier and resolve it. This returns a Locale object
     * that includes the original id string or tag's compact form, and
     * a resolved LanguageTag.
     */
    static resolveLocale(id: string | LanguageTag): Locale;
    /**
     * Parses a string into a BCP47 language tag
     */
    static parseLanguageTag(s: string): LanguageTag;
    /**
     * Synchronously load a bundle and construct an instance of an API for
     * a given locale. Mainly used when you want to load a language statically
     * when your application's state store is initialized.
     */
    get(locale: Locale | string): CLDR;
    /**
     * Asynchronously load a bundle and construct an instance of an API for
     * a given locale.
     */
    getAsync(locale: Locale | string): Promise<CLDR>;
    /**
     * Builds an API instance.
     */
    protected build(locale: Locale, pack: Pack): CLDR;
    /**
     * Verify the resource pack is compatible with the schema config checksum.
     */
    protected check(pack: Pack): void;
}
