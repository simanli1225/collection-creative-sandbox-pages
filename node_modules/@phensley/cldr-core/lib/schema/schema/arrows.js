"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorArrowImpl = exports.DigitsArrowImpl = exports.ScopeArrowImpl = exports.FieldArrowImpl = void 0;
/**
 * @public
 */
var FieldArrowImpl = /** @class */ (function () {
    function FieldArrowImpl(offset) {
        this.offset = offset;
    }
    FieldArrowImpl.prototype.get = function (bundle) {
        return bundle.get(this.offset);
    };
    return FieldArrowImpl;
}());
exports.FieldArrowImpl = FieldArrowImpl;
/**
 * @public
 */
var ScopeArrowImpl = /** @class */ (function () {
    function ScopeArrowImpl(map) {
        this.map = map;
    }
    ScopeArrowImpl.prototype.get = function (key) {
        return this.map[key];
    };
    return ScopeArrowImpl;
}());
exports.ScopeArrowImpl = ScopeArrowImpl;
/**
 * Special vector to store a pluralized number pattern and its divisor together.
 *
 * @public
 */
var DigitsArrowImpl = /** @class */ (function () {
    function DigitsArrowImpl(offset, index, values) {
        this.offset = offset;
        this.index = index;
        this.values = values;
        this.size2 = values.length * 2; // store pattern and divisor as a pair
    }
    DigitsArrowImpl.prototype.get = function (bundle, key, digits) {
        if (digits > this.values.length) {
            digits = this.values.length;
        }
        if (digits > 0) {
            var i = this.index.get(key);
            if (i !== -1) {
                var k = this.offset + i * this.size2 + (digits - 1) * 2;
                var p = bundle.get(k);
                var d = bundle.get(k + 1);
                return [p, Number(d)];
            }
        }
        return DigitsArrowImpl.EMPTY;
    };
    DigitsArrowImpl.EMPTY = ['', 0];
    return DigitsArrowImpl;
}());
exports.DigitsArrowImpl = DigitsArrowImpl;
/**
 * Generalized multi-dimensional vector arrow.
 *
 * @public
 */
var VectorArrowImpl = /** @class */ (function () {
    function VectorArrowImpl(offset, keysets) {
        this.keysets = keysets;
        this.offset = offset + 1; // skip over header
        this.len = keysets.length;
        this.last = this.len - 1;
        this.factors = new Array(this.len);
        // Pre-compute the address factor for each dimension:
        //  1-dim:        [ index0 ]
        //  2-dim:        [ (index0 * size1), index1 ]
        //  3-dim:        [ (index0 * size1 * size2), (index1 * size), index2 ]
        //  ...
        for (var i = 0; i < this.len; i++) {
            var k = 1;
            for (var j = i + 1; j < this.len; j++) {
                k *= this.keysets[j].size;
            }
            this.factors[i] = k;
        }
    }
    VectorArrowImpl.prototype.valid = function () {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        return this._index(keys, 0, this.offset) !== -1;
    };
    VectorArrowImpl.prototype.exists = function (bundle) {
        return bundle.get(this.offset - 1) === 'E';
    };
    VectorArrowImpl.prototype.get = function (bundle) {
        var keys = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            keys[_i - 1] = arguments[_i];
        }
        if (keys.length !== this.len) {
            // Impossible lookup, will never reach a valid field
            throw new Error("Warning: impossible vector lookup with keys ".concat(JSON.stringify(keys)));
        }
        if (!this.exists(bundle)) {
            return '';
        }
        return this._get(bundle, keys, 0, this.offset);
    };
    VectorArrowImpl.prototype.mapping = function (bundle) {
        return this.exists(bundle) ? this._mapping(bundle, 0, 0) : {};
    };
    VectorArrowImpl.prototype._index = function (keys, ix, k) {
        var key = keys[ix];
        var args = typeof key === 'string' ? [key] : key;
        var last = args.length - 1;
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            var j = this.keysets[ix].get(arg);
            if (j === -1) {
                if (i !== last) {
                    continue;
                }
                return -1;
            }
            var kk = k + j * this.factors[ix];
            if (ix === this.last) {
                return kk;
            }
            var result = this._index(keys, ix + 1, kk);
            if (result !== -1) {
                return result;
            }
        }
        return -1;
    };
    VectorArrowImpl.prototype._get = function (bundle, keys, ix, k) {
        var key = keys[ix];
        var args = typeof key === 'string' ? [key] : key;
        var last = args.length - 1;
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            var j = this.keysets[ix].get(arg);
            if (j === -1) {
                if (i !== last) {
                    continue;
                }
                return '';
            }
            var kk = k + j * this.factors[ix];
            var val = ix === this.last ? bundle.get(kk) : this._get(bundle, keys, ix + 1, kk);
            if (!!val) {
                return val;
            }
        }
        return '';
    };
    VectorArrowImpl.prototype._mapping = function (bundle, k, ix) {
        var o = {};
        var keys = this.keysets[k].keys;
        var last = k === this.last;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (last) {
                // We're at the value level of the map, so lookup the corresponding string
                var val = bundle.get(this.offset + i + ix);
                if (val) {
                    o[key] = val;
                }
            }
            else {
                // Drill one level deeper
                o[key] = this._mapping(bundle, k + 1, ix + i * this.factors[k]);
            }
        }
        return o;
    };
    return VectorArrowImpl;
}());
exports.VectorArrowImpl = VectorArrowImpl;
//# sourceMappingURL=arrows.js.map