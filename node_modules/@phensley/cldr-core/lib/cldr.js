"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CLDRFramework = void 0;
var cldr_utils_1 = require("@phensley/cldr-utils");
var api_1 = require("./api");
var internals_1 = require("./internals");
var locale_1 = require("./locale");
var language_tag_1 = require("@phensley/language-tag");
var locale_2 = require("@phensley/locale");
var resource_1 = require("./resource");
var version_1 = require("./utils/version");
/**
 * Implements CLDR
 *
 * @public
 */
var CLDRImpl = /** @class */ (function () {
    function CLDRImpl(locale, bundle, internals) {
        this.locale = locale;
        this.bundle = bundle;
        this.internals = internals;
    }
    Object.defineProperty(CLDRImpl.prototype, "Calendars", {
        /**
         * Calendar functions.
         */
        get: function () {
            if (this._calendars === undefined) {
                this._calendars = new api_1.CalendarsImpl(this.bundle, this.internals, this.privateApi);
            }
            return this._calendars;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "General", {
        /**
         * General functions.
         */
        get: function () {
            if (this._general === undefined) {
                this._general = new api_1.GeneralImpl(this.bundle, this.locale, this.internals, this.privateApi);
            }
            return this._general;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Numbers", {
        /**
         * Number and currency functions.
         */
        get: function () {
            if (this._numbers === undefined) {
                this._numbers = new api_1.NumbersImpl(this.bundle, this.internals.numbers, this.internals.general, this.privateApi);
            }
            return this._numbers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Units", {
        /**
         * Unit quantity functions.
         */
        get: function () {
            if (this._units === undefined) {
                this._units = new api_1.UnitsImpl(this.bundle, this.internals, this.privateApi);
            }
            return this._units;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Schema", {
        /**
         * UNDOCUMENTED AND EXPERIMENTAL
         *
         * Provides access to the low-level schema for accessing CLDR fields.
         *
         * Currently undocumented. In the future an internal api can be
         * exposed allowing access to low-level functions of the library.
         *
         * @internal
         */
        get: function () {
            return this.internals.schema;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "Internals", {
        /**
         * UNDOCUMENTED AND EXPERIMENTAL
         *
         * Provides access to the low-level library internals.
         *
         * @internal
         */
        get: function () {
            return this.internals;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CLDRImpl.prototype, "privateApi", {
        get: function () {
            if (this._privateApi === undefined) {
                this._privateApi = new api_1.PrivateApiImpl(this.bundle, this.internals);
            }
            return this._privateApi;
        },
        enumerable: false,
        configurable: true
    });
    return CLDRImpl;
}());
var EMPTY_CONFIG = {};
/**
 * Top-level entry point for the library. It's only purpose at the
 * moment is to construct API instances for a particular locale.
 * All other functionality should be available statically through
 * exported types and functions.
 *
 * @public
 */
var CLDRFramework = /** @class */ (function () {
    function CLDRFramework(options) {
        this.options = options;
        this.packCache = new cldr_utils_1.LRU(options.packCacheSize || 2);
        this.loader = options.loader;
        this.asyncLoader = options.asyncLoader;
        this._config = options.config || CLDRFramework.defaultConfig || EMPTY_CONFIG;
        var patternCacheSize = options.patternCacheSize || 200;
        this.internals = new internals_1.InternalsImpl(this._config, version_1.VERSION, options.debug, options.skipChecksum, patternCacheSize);
    }
    /**
     * Specify a configuration to use as a fallback.
     */
    CLDRFramework.setDefaultConfig = function (config) {
        this.defaultConfig = config;
    };
    CLDRFramework.prototype.config = function () {
        return this._config;
    };
    CLDRFramework.prototype.info = function () {
        return "packs loaded: ".concat(this.packCache.size());
    };
    /**
     * Return the library version.
     */
    CLDRFramework.version = function () {
        return version_1.VERSION;
    };
    /**
     * Return an array of the available locales.
     */
    CLDRFramework.availableLocales = function () {
        return (0, locale_1.availableLocales)();
    };
    /**
     * Parse a locale identifier and resolve it. This returns a Locale object
     * that includes the original id string or tag's compact form, and
     * a resolved LanguageTag.
     */
    CLDRFramework.resolveLocale = function (id) {
        var _id = typeof id === 'string' ? id : id.compact();
        var tag = locale_2.LanguageResolver.resolve(id);
        return { id: _id, tag: tag };
    };
    /**
     * Parses a string into a BCP47 language tag
     */
    CLDRFramework.parseLanguageTag = function (s) {
        return (0, language_tag_1.parseLanguageTag)(s);
    };
    /**
     * Synchronously load a bundle and construct an instance of an API for
     * a given locale. Mainly used when you want to load a language statically
     * when your application's state store is initialized.
     */
    CLDRFramework.prototype.get = function (locale) {
        must(this.loader, "A synchronous resource loader is not defined" /* Messages.NO_SYNC_LOADER */);
        must(locale, "The \"locale\" argument is undefined" /* Messages.LOCALE_UNDEFINED */);
        var resolved = typeof locale === 'string' ? CLDRFramework.resolveLocale(locale) : locale;
        var language = resolved.tag.language();
        var pack = this.packCache.get(language);
        if (pack === undefined) {
            var data = this.loader(language);
            pack = new resource_1.Pack(data);
            this.check(pack);
            this.packCache.set(language, pack);
        }
        return this.build(resolved, pack);
    };
    /**
     * Asynchronously load a bundle and construct an instance of an API for
     * a given locale.
     */
    CLDRFramework.prototype.getAsync = function (locale) {
        var _this = this;
        must(this.asyncLoader, "A Promise-based resource loader is not defined" /* Messages.NO_ASYNC_LOADER */);
        must(locale, "The \"locale\" argument is undefined" /* Messages.LOCALE_UNDEFINED */);
        var resolved = typeof locale === 'string' ? CLDRFramework.resolveLocale(locale) : locale;
        var language = resolved.tag.language();
        var promise = new Promise(function (resolve, reject) {
            var pack = _this.packCache.get(language);
            if (pack !== undefined) {
                resolve(_this.build(resolved, pack));
                return;
            }
            // Resolve via the promise loader
            _this.asyncLoader(language)
                .then(function (raw) {
                var _pack = new resource_1.Pack(raw);
                _this.check(_pack);
                _this.packCache.set(language, _pack);
                resolve(_this.build(resolved, _pack));
            })
                .catch(reject);
        });
        return promise;
    };
    /**
     * Builds an API instance.
     */
    CLDRFramework.prototype.build = function (locale, pack) {
        var bundle = pack.get(locale.tag);
        return new CLDRImpl(locale, bundle, this.internals);
    };
    /**
     * Verify the resource pack is compatible with the schema config checksum.
     */
    CLDRFramework.prototype.check = function (pack) {
        if (!this.options.skipChecksum && pack.checksum !== this.internals.checksum) {
            throw new Error("Checksum mismatch on resource pack! The schema config used to generate the resource pack must be identical to the one used at runtime." /* Messages.CHECKSUM */);
        }
    };
    return CLDRFramework;
}());
exports.CLDRFramework = CLDRFramework;
var must = function (arg, message) {
    if (arg === undefined) {
        throw new Error(message);
    }
};
//# sourceMappingURL=cldr.js.map