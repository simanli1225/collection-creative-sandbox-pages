"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.intervalPatternBoundary = exports.parseDatePattern = exports.DATE_PATTERN_CHARS = void 0;
// prettier-ignore
exports.DATE_PATTERN_CHARS = [
    'G', 'y', 'Y', 'u', 'U', 'r', 'Q', 'q', 'M', 'L', 'l', 'w', 'W', 'd', 'D',
    'F', 'g', 'E', 'e', 'c', 'a', 'b', 'B', 'h', 'H', 'K', 'k', 'j', 'J', 'C',
    'm', 's', 'S', 'A', 'z', 'Z', 'O', 'v', 'V', 'X', 'x'
].reduce(function (o, c, i) {
    o[c] = i + 1;
    return o;
}, {});
/**
 * Parse a datetime pattern into an array of nodes.
 */
var parseDatePattern = function (raw) {
    var nodes = [];
    if (!raw) {
        return nodes;
    }
    var len = raw.length;
    var buf = '';
    var field = '';
    var width = 0;
    var inquote = false;
    var i = 0;
    while (i < len) {
        var ch = raw[i];
        if (inquote) {
            if (ch === "'") {
                inquote = false;
                field = '';
            }
            else {
                buf += ch;
            }
            i++;
            continue;
        }
        if (exports.DATE_PATTERN_CHARS[ch] > 0) {
            if (buf.length > 0) {
                nodes.push(buf);
                buf = '';
            }
            if (ch !== field) {
                if (field !== '') {
                    nodes.push([field, width]);
                }
                field = ch;
                width = 1;
            }
            else {
                // Widen the current field.
                width++;
            }
        }
        else {
            if (field !== '') {
                nodes.push([field, width]);
            }
            field = '';
            if (ch === "'") {
                inquote = true;
            }
            else {
                buf += ch;
            }
        }
        i++;
    }
    // In the final state we'll either have a field+width or
    // some characters in the buf.
    if (width > 0 && field !== '') {
        nodes.push([field, width]);
    }
    else {
        nodes.push(buf);
    }
    return nodes;
};
exports.parseDatePattern = parseDatePattern;
/**
 * Scan the date interval pattern and return the index of the first repeated field.
 */
var intervalPatternBoundary = function (pattern) {
    // Use bit flags to detect first repeated field.
    var data = [0, 0];
    for (var i = 0; i < pattern.length; i++) {
        var node = pattern[i];
        if (typeof node !== 'string') {
            var n = exports.DATE_PATTERN_CHARS[node[0]];
            var idx = n >>> 5;
            if (((data[idx] >>> n % 32) & 1) === 1) {
                return i;
            }
            data[idx] |= 1 << n;
        }
    }
    return -1;
};
exports.intervalPatternBoundary = intervalPatternBoundary;
//# sourceMappingURL=date.js.map