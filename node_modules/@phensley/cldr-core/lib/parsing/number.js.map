{"version":3,"file":"number.js","sourceRoot":"","sources":["../../src/parsing/number.ts"],"names":[],"mappings":"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","sourcesContent":["export const enum NumberField {\n  MINUS = 0,\n  PERCENT = 1,\n  CURRENCY = 2,\n  NUMBER = 3,\n  EXPONENT = 4,\n  PLUS = 5,\n}\n\nexport interface NumberPattern {\n  nodes: NumberNode[];\n  minInt: number;\n  maxFrac: number;\n  minFrac: number;\n  priGroup: number;\n  secGroup: number;\n}\n\nexport type NumberNode = string | NumberField;\n\nconst MINUS_NODE: NumberNode[] = [NumberField.MINUS];\n\nconst newPattern = (): NumberPattern => ({ nodes: [], minInt: 0, maxFrac: 0, minFrac: 0, priGroup: 0, secGroup: 0 });\n\nclass NumberPatternParser {\n  private curr: NumberPattern = newPattern();\n  private buf: string = '';\n  private attached: boolean = false;\n\n  parse(raw: string): NumberPattern[] {\n    const len = raw.length;\n\n    let save: NumberPattern | undefined;\n    let curr = this.curr;\n    let ingroup = false;\n    let indecimal = false;\n    let i = 0;\n\n    outer: while (i < len) {\n      let ch = raw[i];\n      switch (ch) {\n        case \"'\":\n          while (i++ < len) {\n            ch = raw[i];\n            if (ch === \"'\") {\n              break;\n            }\n            this.buf += ch;\n          }\n          break;\n\n        case ';':\n          // If we encounter more than one pattern separator, bail out\n          if (save) {\n            break outer;\n          }\n          this.pushText();\n          // Save current pattern and start parsing a new one\n          save = curr;\n          curr = newPattern();\n          this.curr = curr;\n          // Reset state for next parse\n          indecimal = false;\n          ingroup = false;\n          this.attached = false;\n          break;\n\n        case '-':\n          this.pushText();\n          curr.nodes.push(NumberField.MINUS);\n          break;\n\n        case '%':\n          this.pushText();\n          curr.nodes.push(NumberField.PERCENT);\n          break;\n\n        case '\\u00a4':\n          this.pushText();\n          curr.nodes.push(NumberField.CURRENCY);\n          break;\n\n        case 'E':\n          this.pushText();\n          curr.nodes.push(NumberField.EXPONENT);\n          break;\n\n        case '+':\n          this.pushText();\n          curr.nodes.push(NumberField.PLUS);\n          break;\n\n        case '#':\n          this.attach();\n          if (ingroup) {\n            curr.priGroup++;\n          } else if (indecimal) {\n            curr.maxFrac++;\n          }\n          break;\n\n        case ',':\n          this.attach();\n          if (ingroup) {\n            curr.secGroup = curr.priGroup;\n            curr.priGroup = 0;\n          } else {\n            ingroup = true;\n          }\n          break;\n\n        case '.':\n          ingroup = false;\n          this.attach();\n          indecimal = true;\n          break;\n\n        case '0':\n          this.attach();\n          if (ingroup) {\n            curr.priGroup++;\n          } else if (indecimal) {\n            curr.maxFrac++;\n            curr.minFrac++;\n          }\n          if (!indecimal) {\n            curr.minInt++;\n          }\n          break;\n\n        default:\n          this.buf += ch;\n          break;\n      }\n\n      i++;\n    }\n    this.pushText();\n    if (save === undefined) {\n      // Derive positive from negative by prepending a minus node\n      const { nodes, minInt, maxFrac, minFrac, priGroup, secGroup } = curr;\n      save = curr;\n      curr = { nodes: MINUS_NODE.concat(nodes.slice(0)), minInt, maxFrac, minFrac, priGroup, secGroup };\n    }\n    return [save, curr];\n  }\n\n  private attach(): void {\n    this.pushText();\n    if (!this.attached) {\n      this.curr.nodes.push(NumberField.NUMBER);\n      this.attached = true;\n    }\n  }\n\n  private pushText(): void {\n    if (this.buf.length > 0) {\n      this.curr.nodes.push(this.buf);\n      this.buf = '';\n    }\n  }\n}\n\nexport const parseNumberPattern = (raw: string): NumberPattern[] => new NumberPatternParser().parse(raw);\n"]}