"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatePatternMatcher = exports.DateSkeletonParser = exports.EMPTY = exports.DateSkeleton = void 0;
var date_1 = require("../../parsing/date");
var fields_1 = require("./fields");
/**
 * Represents an abstract date pattern, denoting the fields that appear in
 * the actual pattern.
 */
var DateSkeleton = /** @class */ (function () {
    function DateSkeleton() {
        this.type = (0, fields_1.skeletonFields)();
        this.info = [];
        this.skeleton = '';
        this.isDate = false;
        this.isTime = false;
    }
    DateSkeleton.prototype.compound = function () {
        return this.isDate && this.isTime;
    };
    DateSkeleton.prototype.has = function (field) {
        return this.type[field] !== 0;
    };
    DateSkeleton.prototype.monthWidth = function () {
        var m = this.info[3 /* Field.MONTH */];
        return m ? m.width : 0;
    };
    /**
     * Split this compound skeleton, removing all time fields and copying
     * them to another skeleton.
     */
    DateSkeleton.prototype.split = function () {
        var r = new DateSkeleton();
        // Copy time fields to other skeleton and clear them.
        for (var i = 10 /* Field.DAYPERIOD */; i < 16 /* Field.MAX_TYPE */; i++) {
            if (this.type[i] !== 0) {
                r.type[i] = this.type[i];
                // ensure we copy the properties
                var _a = this.info[i], input = _a.input, field = _a.field, type = _a.type, width = _a.width, repeat = _a.repeat;
                r.info[i] = { input: input, field: field, type: type, width: width, repeat: repeat };
                this.type[i] = 0;
                this.info[i] = undefined;
            }
        }
        this.isTime = false;
        this.skeleton = this.canonical();
        r.isTime = true;
        r.skeleton = r.canonical();
        return r;
    };
    /**
     * Build a canonical representation of the skeleton.
     */
    DateSkeleton.prototype.canonical = function () {
        var r = '';
        for (var i = 0; i < 16 /* Field.MAX_TYPE */; i++) {
            var info = this.info[i];
            if (info !== undefined) {
                var field = info.field;
                // Skip day period for backwards-compatibility
                if (field !== '' && field !== 'a') {
                    var repeat = info.repeat;
                    // Override skeleton repeat for these fields.
                    if ('GEzvQ'.indexOf(field) !== -1) {
                        repeat = 1;
                    }
                    for (var j = 0; j < repeat; j++) {
                        r += field;
                    }
                }
            }
        }
        return r;
    };
    return DateSkeleton;
}());
exports.DateSkeleton = DateSkeleton;
exports.EMPTY = new DateSkeleton();
var DateSkeletonParser = /** @class */ (function () {
    function DateSkeletonParser(preferredFlex, allowedFlex) {
        this.preferredFlex = preferredFlex;
        this.allowedFlex = allowedFlex;
    }
    DateSkeletonParser.prototype.parse = function (skeleton, isPattern) {
        if (isPattern === void 0) { isPattern = false; }
        var s = new DateSkeleton();
        this._parse(s, skeleton, isPattern);
        return s;
    };
    DateSkeletonParser.prototype._parse = function (s, raw, isPattern) {
        var len = raw.length;
        var noDayPeriod = false;
        var field = '';
        var width = 0;
        var inquote = false;
        var i = 0;
        while (i < len) {
            var ch = raw[i];
            if (inquote) {
                if (ch === "'") {
                    inquote = false;
                }
                i++;
                continue;
            }
            if (ch === "'") {
                inquote = true;
            }
            else if (date_1.DATE_PATTERN_CHARS[ch] > 0) {
                if (ch !== field) {
                    if (field) {
                        noDayPeriod = this.setDayPeriod(s, field, width, noDayPeriod);
                    }
                    field = ch;
                    width = 1;
                }
                else {
                    width++;
                }
            }
            // Lenient parse.. skip all non-field charaters.
            i++;
        }
        // Push the last field. For a non-empty skeleton this will always
        // be true.
        if (width > 0 && field) {
            noDayPeriod = this.setDayPeriod(s, field, width, noDayPeriod);
        }
        // Handle some special hour cycle / day period behaviors
        var hour = s.info[11 /* Field.HOUR */];
        var dayPeriod = s.info[10 /* Field.DAYPERIOD */];
        if (noDayPeriod) {
            this.clear(s, 10 /* Field.DAYPERIOD */);
        }
        else if (hour && hour.field) {
            // If we have a 12-hour-cycle but no dayperiod, add the default.
            if (hour.field === 'h' || hour.field === 'K') {
                if (!dayPeriod) {
                    // Add the default day period
                    var idx = fields_1.FIELD_INDEX.get('a')[0];
                    var row = fields_1.FIELD_TYPES[idx];
                    s.type[10 /* Field.DAYPERIOD */] = row[2];
                    s.info[10 /* Field.DAYPERIOD */] = {
                        input: 'a',
                        field: 'a',
                        type: 10 /* Field.DAYPERIOD */,
                        width: row[3],
                        repeat: row[3],
                    };
                }
            }
            else if (dayPeriod && dayPeriod.field) {
                this.clear(s, 10 /* Field.DAYPERIOD */);
            }
        }
        s.skeleton = isPattern ? s.canonical() : raw;
        if (isPattern) {
            s.pattern = raw;
        }
    };
    DateSkeletonParser.prototype.setDayPeriod = function (s, field, width, noDayPeriod) {
        if ('jJC'.indexOf(field) !== -1) {
            noDayPeriod = field === 'J';
            this.setMeta(s, field);
        }
        else {
            this.set(s, field, field, width);
        }
        return noDayPeriod;
    };
    DateSkeletonParser.prototype.setMeta = function (s, field) {
        var meta = field === 'C' ? this.allowedFlex : this.preferredFlex;
        for (var _i = 0, meta_1 = meta; _i < meta_1.length; _i++) {
            var n = meta_1[_i];
            // Flex types have no static pattern fields
            /* istanbul ignore else */
            if (typeof n !== 'string') {
                this.set(s, field, n[0], n[1]);
            }
        }
    };
    DateSkeletonParser.prototype.set = function (s, input, field, width) {
        var ft = (0, fields_1.getFieldType)(field, width);
        // Will never fail as field types are whitelisted at a higher call point
        /* istanbul ignore else */
        if (ft !== undefined) {
            this.index(s, input, field, width, ft);
        }
    };
    DateSkeletonParser.prototype.clear = function (s, field) {
        s.type[field] = 0;
        s.info[field] = undefined;
    };
    DateSkeletonParser.prototype.index = function (s, input, field, width, ft) {
        var idx = ft[1];
        s.type[idx] = ft[2] + (ft[2] > 0 ? width : 0);
        s.info[idx] = { input: input, field: field, type: idx, width: width, repeat: ft[3] };
        s.isDate = s.isDate || idx < 10 /* Field.DAYPERIOD */;
        s.isTime = s.isTime || idx >= 10 /* Field.DAYPERIOD */;
    };
    return DateSkeletonParser;
}());
exports.DateSkeletonParser = DateSkeletonParser;
var cmp = function (a, b) { return (a < b ? -1 : a > b ? 1 : 0); };
/**
 * Cache of date patterns and skeletons with ICU-compatible best-fit matching.
 */
var DatePatternMatcher = /** @class */ (function () {
    function DatePatternMatcher() {
        // Save some work for exact matches.
        this.exact = {};
        // Array for matching by distances
        this.entries = [];
    }
    DatePatternMatcher.prototype.add = function (skeleton, _pattern) {
        var key = skeleton.skeleton;
        // Avoid adding patterns with duplicate skeletons
        if (this.exact[key] === undefined) {
            this.exact[key] = skeleton;
            this.entries.push(skeleton);
        }
        this.entries.sort(function (a, b) { return cmp(a.skeleton.length, b.skeleton.length); });
    };
    // TODO: future options to control the match
    DatePatternMatcher.prototype.match = function (input) {
        var match = this.exact[input.skeleton];
        if (match !== undefined) {
            return match;
        }
        var best = exports.EMPTY;
        var bestDist = Number.MAX_SAFE_INTEGER;
        for (var _i = 0, _a = this.entries; _i < _a.length; _i++) {
            var entry = _a[_i];
            var dist = this.getDistance(entry, input);
            if (dist < bestDist) {
                best = entry;
                bestDist = dist;
                if (dist === 0) {
                    break;
                }
            }
        }
        return best;
    };
    /**
     * Make field width adjustments to pattern using the given skeleton.
     */
    DatePatternMatcher.prototype.adjust = function (pattern, skeleton, decimal) {
        var r = [];
        for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {
            var n = pattern_1[_i];
            if (typeof n === 'string') {
                r.push(n);
                continue;
            }
            var field = n[0], width = n[1];
            var p = (0, fields_1.getFieldType)(field, width);
            // Adjust field and width to match skeleton below
            var adjfield = field;
            var adjwidth = width;
            var i = p[1];
            // For hour, minute and second we use the width from the pattern.
            if (i === 11 /* Field.HOUR */ || i === 12 /* Field.MINUTE */ || i === 13 /* Field.SECOND */) {
                r.push([adjfield, adjwidth]);
                // See if skeleton requested fractional seconds and augment the seconds field.
                if (i === 13 /* Field.SECOND */) {
                    var info = skeleton.info[14 /* Field.FRACTIONAL_SECOND */];
                    if (info !== undefined) {
                        r.push(decimal);
                        r.push([info.field, info.width]);
                    }
                }
                continue;
            }
            var ptype = p[2];
            var stype = skeleton.type[i];
            // Ensure magnitudes are the same
            if ((ptype < 0 && stype < 0) || (ptype > 0 && stype > 0)) {
                var _info = skeleton.info[i];
                // Since the 'i' comes from a parsed date pattern, this should
                // always be defined.
                /* istanbul ignore else */
                if (_info) {
                    adjfield = _info.field;
                    adjwidth = _info.width;
                }
            }
            // TODO: UNREACHABLE as field replacement has been selected above
            // // Metacharacters have already been replaced in the pattern.
            // if ('jJC'.indexOf(adjfield) !== -1) {
            //   console.log('adjust skeleton', adjfield);
            //   adjfield = field;
            // }
            r.push([adjfield, adjwidth]);
        }
        // TODO: handle appending missing fields
        return r;
    };
    // TODO: mask is currently unused
    DatePatternMatcher.prototype.getDistance = function (a, b, _mask) {
        if (_mask === void 0) { _mask = 0; }
        var result = 0;
        for (var i = 0; i < 16 /* Field.MAX_TYPE */; i++) {
            // const atype = mask > 0 && (mask & (1 << i)) === 0 ? 0 : a.type[i];
            var atype = a.type[i];
            var btype = b.type[i];
            if (atype === btype) {
                continue;
            }
            if (atype === 0) {
                result += fields_1.EXTRA_FIELD;
            }
            else if (btype === 0) {
                result += fields_1.MISSING_FIELD;
            }
            else {
                result += Math.abs(atype - btype);
            }
        }
        return result;
    };
    return DatePatternMatcher;
}());
exports.DatePatternMatcher = DatePatternMatcher;
//# sourceMappingURL=skeleton.js.map