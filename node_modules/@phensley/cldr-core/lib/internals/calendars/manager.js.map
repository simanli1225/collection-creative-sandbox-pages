{"version":3,"file":"manager.js","sourceRoot":"","sources":["../../../src/internals/calendars/manager.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateTimePatternFieldType } from '@phensley/cldr-types';\nimport { Cache } from '@phensley/cldr-utils';\n\nimport { Internals } from '../internals';\nimport { Bundle } from '../../resource';\nimport { DateFormatOptions, DateIntervalFormatOptions } from '../../common';\nimport { DateTimeNode } from '../../parsing/date';\nimport { CalendarDate } from '../../systems/calendars';\nimport { NumberParams } from '../../common/private';\nimport { CalendarPatterns, GregorianPatterns } from './patterns';\nimport { DateSkeleton } from './skeleton';\nimport { DateFormatRequest, DateIntervalFormatRequest } from './types';\nimport { Field } from './fields';\n\nexport class CalendarManager {\n  private readonly patternCache: Cache<CalendarPatterns>;\n  private readonly availableCalendars: Set<string>;\n\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly internals: Internals,\n  ) {\n    // calendars config array should always be non-empty\n    this.availableCalendars = new Set(internals.config.calendars || /* istanbul ignore next */ []);\n    const schema = internals.schema;\n    this.patternCache = new Cache((calendar: string) => {\n      if (this.availableCalendars.has(calendar)) {\n        switch (calendar) {\n          case 'buddhist':\n            return new CalendarPatterns(bundle, internals, schema.Buddhist);\n          case 'japanese':\n            return new CalendarPatterns(bundle, internals, schema.Japanese);\n          case 'persian':\n            return new CalendarPatterns(bundle, internals, schema.Persian);\n        }\n      }\n      return new GregorianPatterns(bundle, internals, schema.Gregorian);\n    }, 20);\n  }\n\n  getCalendarPatterns(calendar: string): CalendarPatterns {\n    return this.patternCache.get(calendar);\n  }\n\n  getDateFormatRequest(date: CalendarDate, options: DateFormatOptions, params: NumberParams): DateFormatRequest {\n    const calendar = this.internals.calendars.selectCalendar(this.bundle, options.ca);\n    const patterns = this.getCalendarPatterns(calendar);\n\n    let dateKey = this.supportedOption(options.datetime || options.date);\n    const timeKey = this.supportedOption(options.datetime || options.time);\n    const wrapKey = this.supportedOption(options.wrap);\n    let skelKey = options.skeleton || '';\n\n    if (!dateKey && !timeKey && !skelKey) {\n      dateKey = 'long';\n    }\n\n    const atTime = options.atTime === false ? false : true;\n\n    let wrapper = '';\n    if (wrapKey) {\n      wrapper = patterns.getWrapperPattern(wrapKey, atTime);\n    } else if (dateKey && timeKey) {\n      wrapper = patterns.getWrapperPattern(dateKey, atTime);\n    }\n\n    const req: DateFormatRequest = { wrapper, params };\n    if (dateKey) {\n      req.date = patterns.getDatePattern(dateKey);\n    }\n    if (timeKey) {\n      req.time = patterns.getTimePattern(timeKey);\n    }\n\n    let query: DateSkeleton;\n\n    // We have both standard formats, we're done\n    if (req.date && req.time) {\n      return req;\n    }\n\n    // We have at least a date/time standard format.\n    if (req.date || req.time) {\n      // If no skeleton specified, we're done\n      if (!skelKey) {\n        return req;\n      }\n\n      // We have a standard date or time pattern along with a skeleton.\n      // We split the skeleton into date/time parts, then use the one\n      // that doesn't conflict with the specified standard format\n      query = patterns.parseSkeleton(skelKey);\n\n      // Use the part of the skeleton that does not conflict\n      const time = query.split();\n      if (req.date) {\n        query = time;\n      }\n\n      // Update skeleton key with only the used fields\n      skelKey = query.canonical();\n    } else {\n      // No standard format specified, so just parse the skeleton\n      query = patterns.parseSkeleton(skelKey);\n    }\n\n    // TODO: skeleton caching disabled for now due to mixed formats\n    // Check if we've cached the patterns for this skeleton before\n    // let entry = patterns.getCachedSkeletonRequest(skelKey);\n    // if (entry) {\n    //   req.date = entry.date;\n    //   req.time = entry.time;\n    //   if (!wrapKey && entry.dateSkel && req.date && req.time) {\n    //     // If wrapper not explicitly requested, select based on skeleton date fields.\n    //     req.wrapper = this.selectWrapper(patterns, entry.dateSkel, req.date);\n    //   }\n    //   return req;\n    // }\n\n    // Perform a best-fit match on the skeleton\n\n    let timeQuery: DateSkeleton | undefined;\n    let dateSkel: DateSkeleton | undefined;\n    let timeSkel: DateSkeleton | undefined;\n\n    // Check if skeleton specifies date or time fields, or both.\n    if (query.compound()) {\n      // Separate into a date and a time skeletons.\n      timeQuery = query.split();\n      dateSkel = patterns.matchAvailable(query);\n      timeSkel = patterns.matchAvailable(timeQuery);\n    } else if (query.isDate) {\n      dateSkel = patterns.matchAvailable(query);\n    } else {\n      timeQuery = query;\n      timeSkel = patterns.matchAvailable(query);\n    }\n\n    if (dateSkel) {\n      req.date = this.getAvailablePattern(patterns, date, query, dateSkel, params);\n    }\n    if (timeQuery && timeSkel) {\n      req.time = this.getAvailablePattern(patterns, date, timeQuery, timeSkel, params);\n    }\n\n    if (!wrapKey) {\n      if (dateSkel && req.date && req.time) {\n        // Select wrapper based on fields in date skeleton\n        req.wrapper = this.selectWrapper(patterns, dateSkel, req.date, atTime);\n      } else {\n        // Select wrapper based on width of standard date format\n        req.wrapper = patterns.getWrapperPattern(dateKey || 'short', atTime);\n      }\n    }\n\n    // TODO: skeleton caching disabled for now due to mixed formats\n    // entry = { date: req.date, time: req.time, dateSkel: dateSkel };\n    // patterns.setCachedSkeletonRequest(skelKey, entry);\n    return req;\n  }\n\n  /**\n   * Best-fit match an input skeleton. The skeleton can contain both date and\n   * time fields.\n   *\n   * The field of greatest difference between the start and end dates can be\n   * either a date or time field.\n   *\n   * Given this we need to cover the following cases:\n   *\n   * 1. Input skeleton requests both date and time fields.\n   *  a. \"yMd\" same: split skeleton, format date standalone, followed by time range.\n   *  b. \"yMd\" differ: format full start / end with fallback format.\n   *\n   * 2. Input skeleton requests date fields only:\n   *  a. \"yMd\" same: format date standalone\n   *  b. \"yMd\" differ: select and format date range\n   *\n   * 3. Input skeleton requests time fields only:\n   *  a. \"yMd\" same, \"ahms\" same: format time standalone\n   *  b. \"yMd\" same, \"ahms\" differ: select and format time range.\n   *  c. \"yMd\" differ: prepend \"yMd\" to skeleton and go to (1a).\n   */\n  getDateIntervalFormatRequest(\n    calendar: string,\n    start: CalendarDate,\n    fieldDiff: DateTimePatternFieldType,\n    options: DateIntervalFormatOptions,\n    params: NumberParams,\n  ): DateIntervalFormatRequest {\n    const patterns = this.getCalendarPatterns(calendar);\n\n    const dateDiffers = 'yMd'.indexOf(fieldDiff) !== -1;\n\n    const wrapper = patterns.getIntervalFallback();\n    const req: DateIntervalFormatRequest = { params, wrapper };\n\n    let origSkeleton = options.skeleton;\n    if (!origSkeleton) {\n      if (dateDiffers && options.date) {\n        origSkeleton = options.date;\n      } else {\n        origSkeleton = options.time;\n      }\n    }\n\n    // If the skeleton is still undefined, select a reasonable default\n    if (!origSkeleton) {\n      origSkeleton = dateDiffers ? 'yMMMd' : 'hmsa';\n    }\n\n    let skeleton = origSkeleton;\n\n    // Cache key consists of the input skeleton and the field of greatest difference between\n    // the start and end dates.\n    const cacheKey = `${skeleton}\\t${fieldDiff}`;\n    let entry = patterns.getCachedIntervalRequest(cacheKey);\n    if (entry) {\n      req.date = entry.date;\n      req.range = entry.range;\n      req.skeleton = entry.skeleton;\n      return req;\n    }\n\n    entry = {};\n\n    let query = patterns.parseSkeleton(skeleton);\n\n    let standalone = fieldDiff === 's' || (query.isDate && !dateDiffers) || (query.isTime && dateDiffers);\n\n    if (!standalone) {\n      if (query.has(Field.DAY) && !query.has(Field.MONTH)) {\n        skeleton = `M${skeleton}`;\n      }\n      if (query.has(Field.MINUTE) && !query.has(Field.HOUR)) {\n        skeleton = `j${skeleton}`;\n      }\n    }\n\n    if (!query.isDate && dateDiffers) {\n      // 3c. prepend \"yMd\" and proceed\n      if (fieldDiff === 'y') {\n        skeleton = `yMd${skeleton}`;\n      } else if (fieldDiff === 'M') {\n        skeleton = `Md${skeleton}`;\n      } else {\n        skeleton = `d${skeleton}`;\n      }\n    }\n\n    if (origSkeleton !== skeleton) {\n      query = patterns.parseSkeleton(skeleton);\n    }\n\n    let timeQuery: DateSkeleton | undefined;\n\n    // If both date and time fields are requested, we have two choices:\n    // a. date fields are the same:  \"<date>, <time start> - <time end>\"\n    // b. date fields differ, format full range: \"<start> - <end>\"\n    if (query.compound()) {\n      if (dateDiffers) {\n        // 1b. format start and end dates with fallback: \"<start> - <end>\"\n        req.skeleton = skeleton;\n        entry.skeleton = skeleton;\n        patterns.setCachedIntervalRequest(cacheKey, entry);\n        return req;\n      }\n\n      // 1a. split skeleton, format date standalone ..\n      timeQuery = query.split();\n      entry.date = this.matchAvailablePattern(patterns, start, query, params);\n\n      // ... followed by time range: \"<date>, <time start> - <time end>\"\n      query = timeQuery;\n    }\n\n    // standalone: in certain cases we cannot display a range.\n    standalone = fieldDiff === 's' || (query.isDate && !dateDiffers) || (query.isTime && dateDiffers);\n    if (standalone) {\n      // 2a. format date standalone: \"<date>\"\n      // 3a. format time standalone: \"<time>\"\n      entry.date = this.matchAvailablePattern(patterns, start, query, params);\n    } else {\n      // 2b. format date interval: \"<date start> - <date end>\"\n      // 3b. format time interval: \"<time start> - <time end>\"\n      const match = patterns.matchInterval(query, fieldDiff);\n      if (match) {\n        const pattern = patterns.getIntervalPattern(fieldDiff, match.skeleton);\n        /* istanbul ignore else */\n        if (pattern.length) {\n          entry.range = patterns.adjustPattern(pattern, query, params.symbols.decimal);\n        }\n      }\n    }\n\n    patterns.setCachedIntervalRequest(cacheKey, entry);\n    req.date = entry.date;\n    req.range = entry.range;\n    return req;\n  }\n\n  private matchAvailablePattern(\n    patterns: CalendarPatterns,\n    date: CalendarDate,\n    query: DateSkeleton,\n    params: NumberParams,\n  ): DateTimeNode[] | undefined {\n    const match = patterns.matchAvailable(query);\n    return this.getAvailablePattern(patterns, date, query, match, params);\n  }\n\n  private getAvailablePattern(\n    patterns: CalendarPatterns,\n    date: CalendarDate,\n    query: DateSkeleton,\n    match: DateSkeleton,\n    params: NumberParams,\n  ): DateTimeNode[] | undefined {\n    const pattern = patterns.getAvailablePattern(date, match);\n    /* istanbul ignore else */\n    if (pattern.length) {\n      return patterns.adjustPattern(pattern, query, params.symbols.decimal);\n    }\n    // Base standard calendar formats are (currently) always defined.\n    /* istanbul ignore next */\n    return undefined;\n  }\n\n  /**\n   * Select appropriate wrapper based on fields in the date skeleton.\n   */\n  private selectWrapper(\n    patterns: CalendarPatterns,\n    dateSkel: DateSkeleton,\n    _date: DateTimeNode[],\n    atTime: boolean,\n  ): string {\n    let wrapKey = 'short';\n    const monthWidth = dateSkel.monthWidth();\n    const hasWeekday = dateSkel.has(Field.WEEKDAY);\n    if (monthWidth === 4) {\n      wrapKey = hasWeekday ? 'full' : 'long';\n    } else if (monthWidth === 3) {\n      wrapKey = 'medium';\n    }\n    return patterns.getWrapperPattern(wrapKey, atTime);\n  }\n\n  private supportedOption(key?: string): string {\n    switch (key) {\n      case 'full':\n      case 'long':\n      case 'medium':\n      case 'short':\n        return key;\n      default:\n        return '';\n    }\n  }\n}\n"]}