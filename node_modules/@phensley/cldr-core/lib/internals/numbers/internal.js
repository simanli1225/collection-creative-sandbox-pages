"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberInternalsImpl = void 0;
var tslib_1 = require("tslib");
var cldr_utils_1 = require("@phensley/cldr-utils");
var context_1 = require("./context");
var number_1 = require("../../parsing/number");
var util_1 = require("./util");
var render_1 = require("./render");
var ADJUST_PATTERN = (0, number_1.parseNumberPattern)('0')[0];
/**
 * If n is zero check if it is signed and return abs.
 */
var negzero = function (n, show) { return (!show && n.isZero() && n.isNegative() ? n.abs() : n); };
/**
 * Number internal engine singleton, shared across all locales.
 *
 * @internal
 */
var NumberInternalsImpl = /** @class */ (function () {
    function NumberInternalsImpl(internals, cacheSize) {
        this.internals = internals;
        var schema = internals.schema;
        this.currencies = schema.Currencies;
        this.numbers = schema.Numbers;
        this.numberPatternCache = new cldr_utils_1.Cache(number_1.parseNumberPattern, cacheSize);
    }
    NumberInternalsImpl.prototype.adjustDecimal = function (num, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign({}, { minInt: 0 }, options);
        var ctx = new context_1.NumberContext(options, options.round || 'half-even', false, false);
        ctx.setPattern(ADJUST_PATTERN);
        return ctx.adjust(num);
    };
    NumberInternalsImpl.prototype.stringRenderer = function (params) {
        return new render_1.StringNumberFormatter(params);
    };
    NumberInternalsImpl.prototype.partsRenderer = function (params) {
        return new render_1.PartsNumberFormatter(params);
    };
    NumberInternalsImpl.prototype.getCurrencySymbol = function (bundle, code, width) {
        return this._getCurrencySymbol(bundle, code, width === 'narrow' ? 'narrow' : 'none');
    };
    NumberInternalsImpl.prototype._getCurrencySymbol = function (bundle, code, alt) {
        var sym = this.currencies.symbol;
        return sym.get(bundle, [alt, 'none'], code) || (sym.valid('none', code) ? code : '');
    };
    NumberInternalsImpl.prototype.getCurrencyDisplayName = function (bundle, code) {
        return this.currencies.displayName.get(bundle, code);
    };
    NumberInternalsImpl.prototype.getCurrencyPluralName = function (bundle, code, plural) {
        return (this.currencies.pluralName.get(bundle, plural, code) ||
            this.currencies.displayName.get(bundle, code));
    };
    NumberInternalsImpl.prototype.getNumberPattern = function (raw, negative) {
        return this.numberPatternCache.get(raw)[negative ? 1 : 0];
    };
    NumberInternalsImpl.prototype.formatDecimal = function (bundle, renderer, n, options, params) {
        var _a, _b;
        // TODO: abstract away pattern selection defaulting
        var style = options.style === undefined ? 'decimal' : options.style;
        var result;
        var plural = 'other';
        var round = options.round || 'half-even';
        var latnInfo = this.numbers.numberSystem.get('latn');
        var info = this.numbers.numberSystem.get(params.numberSystemName) || latnInfo;
        var decimalFormats = info.decimalFormats;
        var latnDecimalFormats = latnInfo.decimalFormats;
        var standardRaw = decimalFormats.standard.get(bundle) || latnDecimalFormats.standard.get(bundle);
        var plurals = bundle.plurals();
        switch (style) {
            case 'long':
            case 'short': {
                var isShort = style === 'short';
                var useLatn = decimalFormats.short.get(bundle, 'other', 4)[0] === '';
                var patternImpl = isShort
                    ? useLatn
                        ? latnInfo.decimalFormats.short
                        : decimalFormats.short
                    : useLatn
                        ? latnInfo.decimalFormats.long
                        : decimalFormats.long;
                var ctx = new context_1.NumberContext(options, round, true, false);
                // Adjust the number using the compact pattern and divisor.
                // const [q2, ndigits] = this.setupCompact(bundle, n, ctx, standardRaw, patternImpl);
                var q2 = void 0;
                var ndigits = void 0;
                if (options.divisor) {
                    _a = this.setupCompactDivisor(bundle, n, ctx, standardRaw, options.divisor, patternImpl), q2 = _a[0], ndigits = _a[1];
                }
                else {
                    _b = this.setupCompact(bundle, n, ctx, standardRaw, patternImpl), q2 = _b[0], ndigits = _b[1];
                }
                q2 = negzero(q2, options.negativeZero);
                // Compute the plural category for the final q2.
                plural = plurals.cardinal(q2);
                // Select the final pluralized compact pattern based on the integer
                // digits of n and the plural category of the rounded / shifted number q2.
                var raw = patternImpl.get(bundle, plural, ndigits)[0] || patternImpl.get(bundle, 'other', ndigits)[0] || standardRaw;
                // Re-select pattern as number may have changed sign due to rounding.
                var pattern = this.getNumberPattern(raw, q2.isNegative());
                result = renderer.render(q2, pattern, '', '', '', ctx.minInt, options.group);
                break;
            }
            case 'percent':
            case 'percent-scaled':
            case 'permille':
            case 'permille-scaled': {
                // Get percent pattern.
                var raw = info.percentFormat.get(bundle) || latnInfo.percentFormat.get(bundle);
                var pattern = this.getNumberPattern(raw, n.isNegative());
                // Scale the number to a percent or permille form as needed.
                if (style === 'percent') {
                    n = n.movePoint(2);
                }
                else if (style === 'permille') {
                    n = n.movePoint(3);
                }
                // Select percent or permille symbol.
                var symbol = style === 'percent' || style === 'percent-scaled' ? params.symbols.percentSign : params.symbols.perMille;
                // Adjust number using pattern and options, then render.
                var ctx = new context_1.NumberContext(options, round, false, false, -1);
                ctx.setPattern(pattern);
                n = ctx.adjust(n);
                n = negzero(n, options.negativeZero);
                plural = plurals.cardinal(n);
                // Re-select pattern as number may have changed sign due to rounding.
                pattern = this.getNumberPattern(raw, n.isNegative());
                result = renderer.render(n, pattern, '', symbol, '', ctx.minInt, options.group);
                break;
            }
            case 'decimal': {
                // Get decimal pattern.
                var pattern = this.getNumberPattern(standardRaw, n.isNegative());
                // Adjust number using pattern and options, then render.
                var ctx = new context_1.NumberContext(options, round, false, false, -1);
                ctx.setPattern(pattern);
                n = ctx.adjust(n);
                n = negzero(n, options.negativeZero);
                plural = plurals.cardinal(n);
                // Re-select pattern as number may have changed sign due to rounding.
                pattern = this.getNumberPattern(standardRaw, n.isNegative());
                result = renderer.render(n, pattern, '', '', '', ctx.minInt, options.group);
                break;
            }
            case 'scientific': {
                var sciFormat = info.scientificFormat;
                var ctx = new context_1.NumberContext(options, round, false, true, -1);
                var latnSciFormat = latnInfo.scientificFormat;
                var format = sciFormat.get(bundle) || latnSciFormat.get(bundle);
                var pattern = this.getNumberPattern(format, n.isNegative());
                ctx.setPattern(pattern, true);
                n = ctx.adjust(n, true);
                n = negzero(n, options.negativeZero !== false);
                pattern = this.getNumberPattern(format, n.isNegative());
                // Split number into coeffcient and exponent
                var _c = n.scientific(ctx.minInt), coeff = _c[0], exponent = _c[1];
                var adjcoeff = ctx.adjust(coeff, true);
                result = renderer.render(adjcoeff, pattern, '', '', '', 1, false, exponent);
                break;
            }
            default:
                result = renderer.empty();
                break;
        }
        // No valid style matched
        return [result, plural];
    };
    NumberInternalsImpl.prototype.formatCurrency = function (bundle, renderer, n, code, options, params) {
        var _a, _b;
        var fractions = (0, util_1.getCurrencyFractions)(code);
        var round = options.round || 'half-even';
        if (options.cash && fractions.cashRounding > 1) {
            // Simple cash rounding to nearest "cash digits" increment
            n = n.divide(fractions.cashRounding);
            n = n.setScale(fractions.cashDigits, round);
            n = n.multiply(fractions.cashRounding);
        }
        // TODO: display context support
        var width = options.symbolWidth === 'narrow' ? 'narrow' : 'none';
        var style = options.style === undefined ? 'symbol' : options.style;
        var latnInfo = this.numbers.numberSystem.get('latn');
        var info = this.numbers.numberSystem.get(params.numberSystemName) || latnInfo;
        var currencyFormats = info.currencyFormats;
        var latnDecimalFormats = latnInfo.decimalFormats;
        var standardRaw = currencyFormats.standard.get(bundle) || latnDecimalFormats.standard.get(bundle);
        // Some locales have a special decimal symbol for certain currencies, e.g. pt-PT and PTE
        var decimal = this.currencies.decimal.get(bundle, code) || '';
        var plurals = bundle.plurals();
        switch (style) {
            case 'code':
            case 'name': {
                var raw = info.decimalFormats.standard.get(bundle) || latnInfo.decimalFormats.standard.get(bundle);
                var pattern = this.getNumberPattern(raw, n.isNegative());
                // Adjust number using pattern and options, then render.
                var ctx = new context_1.NumberContext(options, round, false, false, fractions.digits);
                ctx.setPattern(pattern);
                n = ctx.adjust(n);
                n = negzero(n, false);
                // Re-select pattern as number may have changed sign due to rounding.
                pattern = this.getNumberPattern(raw, n.isNegative());
                var num = renderer.render(n, pattern, '', '', decimal, ctx.minInt, options.group);
                // Compute plural category and select pluralized unit.
                var plural = plurals.cardinal(n);
                var unit = style === 'code' ? code : this.getCurrencyPluralName(bundle, code, plural);
                // Wrap number and unit together.
                // TODO: implement a more concise fallback to 'other' for pluralized lookups
                var unitWrapper = currencyFormats.unitPattern.get(bundle, [plural, 'other']) ||
                    latnInfo.currencyFormats.unitPattern.get(bundle, [plural, 'other']);
                return renderer.wrap(this.internals.general, unitWrapper, num, renderer.make('unit', unit));
            }
            case 'short': {
                // The extra complexity here is to deal with rounding up and selecting the
                // correct pluralized pattern for the final rounded form.
                var patternImpl = currencyFormats.short;
                var ctx = new context_1.NumberContext(options, round, true, false, fractions.digits);
                var symbol = this._getCurrencySymbol(bundle, code, width);
                // Adjust the number using the compact pattern and divisor.
                var q2 = void 0;
                var ndigits = void 0;
                if (options.divisor) {
                    _a = this.setupCompactDivisor(bundle, n, ctx, standardRaw, options.divisor, patternImpl), q2 = _a[0], ndigits = _a[1];
                }
                else {
                    _b = this.setupCompact(bundle, n, ctx, standardRaw, patternImpl), q2 = _b[0], ndigits = _b[1];
                }
                q2 = negzero(q2, false);
                // Compute the plural category for the final q2.
                var plural = plurals.cardinal(q2);
                // Select the final pluralized compact pattern based on the integer
                // digits of n and the plural category of the rounded / shifted number q2.
                var raw = patternImpl.get(bundle, plural, ndigits)[0] || patternImpl.get(bundle, 'other', ndigits)[0] || standardRaw;
                if (raw === '0') {
                    raw = standardRaw;
                }
                var pattern = this.getNumberPattern(raw, q2.isNegative());
                return renderer.render(q2, pattern, symbol, '', decimal, ctx.minInt, options.group);
            }
            case 'accounting':
            case 'symbol': {
                // Select standard or accounting pattern based on style.
                var styleArrow = style === 'symbol' ? currencyFormats.standard : currencyFormats.accounting;
                var raw = styleArrow.get(bundle);
                if (!raw) {
                    styleArrow = style === 'symbol' ? latnInfo.currencyFormats.standard : latnInfo.currencyFormats.accounting;
                    raw = styleArrow.get(bundle);
                }
                var pattern = this.getNumberPattern(raw, n.isNegative());
                // Adjust number using pattern and options, then render.
                var ctx = new context_1.NumberContext(options, round, false, false, fractions.digits);
                ctx.setPattern(pattern);
                n = ctx.adjust(n);
                n = negzero(n, false);
                // Re-select pattern as number may have changed sign due to rounding.
                pattern = this.getNumberPattern(raw, n.isNegative());
                var symbol = this._getCurrencySymbol(bundle, code, width);
                return renderer.render(n, pattern, symbol, '', decimal, ctx.minInt, options.group);
            }
        }
        // No valid style matched
        return renderer.empty();
    };
    /**
     * Setup for a compact pattern. Returns the adjusted number and digits for
     * selecting the pluralized pattern.
     *
     * The extra complexity here is to deal with rounding up and selecting the
     * correct pluralized pattern for the final rounded form.
     */
    NumberInternalsImpl.prototype.setupCompact = function (bundle, n, ctx, standardRaw, patternImpl) {
        var _a, _b;
        // Select the correct divisor based on the number of integer digits in n.
        var negative = n.isNegative();
        var ndigits = n.integerDigits();
        // Select the initial compact pattern based on the integer digits of n.
        // The plural category doesn't matter until the final pattern is selected.
        var raw;
        var ndivisor = 0;
        _a = patternImpl.get(bundle, 'other', ndigits), raw = _a[0], ndivisor = _a[1];
        var pattern = this.getCompactPattern(raw, standardRaw, negative);
        var fracDigits = ctx.useSignificant ? -1 : 0;
        // Move the decimal point of n, producing q1. We always strip trailing
        // zeros on compact patterns.
        var q1 = n;
        if (ndivisor > 0) {
            q1 = q1.movePoint(-ndivisor);
        }
        // Adjust q1 using the compact pattern's parameters, to produce q2.
        var q1digits = q1.integerDigits();
        ctx.setCompact(pattern, q1digits, ndivisor, fracDigits);
        var q2 = ctx.adjust(q1);
        var q2digits = q2.integerDigits();
        negative = q2.isNegative();
        // Check if the number rounded up, adding another integer digit.
        if (q2digits > q1digits) {
            // Select a new divisor and pattern.
            ndigits++;
            var divisor = 0;
            _b = patternImpl.get(bundle, 'other', ndigits), raw = _b[0], divisor = _b[1];
            pattern = this.getCompactPattern(raw, standardRaw, negative);
            // If divisor changed we need to divide and adjust again. We don't divide,
            // we just move the decimal point, since our Decimal type uses a radix that
            // is a power of 10. Otherwise q2 is ready for formatting.
            if (divisor > ndivisor) {
                // We shift right before we move the decimal point. This triggers rounding
                // of the number at its correct scale. Otherwise we would end up with
                // 999,999 becoming 0.999999 and half-even rounding truncating the
                // number to '0M' instead of '1M'.
                q1 = n.movePoint(-divisor);
                q1 = q1.shiftright(divisor);
                ctx.setCompact(pattern, q1.integerDigits(), divisor, fracDigits);
                q2 = ctx.adjust(q1);
            }
        }
        return [q2, ndigits];
    };
    NumberInternalsImpl.prototype.setupCompactDivisor = function (bundle, n, ctx, standardRaw, divisor, patternImpl) {
        var negative = n.isNegative();
        var ndigits = Math.log10(divisor) + 1;
        // Select compact patterns based on number of digits in divisor
        var _a = patternImpl.get(bundle, 'other', ndigits), raw = _a[0], ndivisor = _a[1];
        if (ndivisor > 0) {
            n = n.movePoint(-ndivisor);
        }
        var pattern = this.getCompactPattern(raw, standardRaw, negative);
        var fracDigits = ctx.useSignificant ? -1 : 0;
        ctx.setCompact(pattern, n.integerDigits(), divisor, fracDigits);
        // Hack to avoid extra leading '0' for certain divisor cases.
        // Unless explicit minimum integers is set in options, we force it to
        // 1 to override the compact pattern.
        var minInt = ctx.options.minimumIntegerDigits;
        var noMinInt = minInt === undefined || minInt < 0;
        if (noMinInt) {
            ctx.minInt = 1;
        }
        return [ctx.adjust(n), ndigits];
    };
    NumberInternalsImpl.prototype.getCompactPattern = function (raw, standardRaw, negative) {
        if (raw) {
            return this.getNumberPattern(raw, negative);
        }
        // Adjust standard pattern to have same fraction settings as compact
        var pattern = this.getNumberPattern(standardRaw, negative);
        return tslib_1.__assign(tslib_1.__assign({}, pattern), { minFrac: 0, maxFrac: 0 });
    };
    return NumberInternalsImpl;
}());
exports.NumberInternalsImpl = NumberInternalsImpl;
//# sourceMappingURL=internal.js.map