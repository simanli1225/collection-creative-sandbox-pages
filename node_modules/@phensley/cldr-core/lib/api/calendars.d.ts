import { DateFieldType, DateTimePatternFieldType, RelativeTimeFieldType } from '@phensley/cldr-types';
import { DecimalArg, Part } from '@phensley/decimal';
import { ZoneInfo } from '@phensley/timezone';
import { Bundle } from '../resource';
import { CalendarFieldsOptions, DateFieldFormatOptions, DateFormatOptions, DateIntervalFormatOptions, DateRawFormatOptions, DateWrapperFormatOptions, EraFieldOptions, RelativeTimeFieldFormatOptions, RelativeTimeFormatOptions, TimeData, TimeZoneInfo, ZonedDateTime } from '../common';
import { Internals } from '../internals';
import { Quantity } from '../common';
import { BuddhistDate, CalendarDate, CalendarDateFields, GregorianDate, ISO8601Date, JapaneseDate, PersianDate, TimePeriod } from '../systems/calendars';
import { Calendars } from './api';
import { PrivateApiImpl } from './private';
/**
 * @internal
 */
export declare class CalendarsImpl implements Calendars {
    private readonly bundle;
    private readonly internals;
    private readonly privateApi;
    private manager;
    private _firstDay;
    private _minDays;
    private exemplarCities;
    constructor(bundle: Bundle, internals: Internals, privateApi: PrivateApiImpl);
    firstDayOfWeek(): number;
    minDaysInFirstWeek(): number;
    dateField(type: DateFieldType, opt?: DateFieldFormatOptions): string;
    dayPeriods(opt?: CalendarFieldsOptions): any;
    eras(opt?: EraFieldOptions): any;
    months(opt?: CalendarFieldsOptions): any;
    quarters(opt?: CalendarFieldsOptions): any;
    weekdays(opt?: CalendarFieldsOptions): any;
    /**
     * Alias for nowGregorian()
     */
    now(zoneId?: string): GregorianDate;
    /**
     * Convert the given date to the Buddhist calendar.
     */
    toBuddhistDate(date: CalendarDate | ZonedDateTime | Date): BuddhistDate;
    /**
     * Construct a new date in the Buddhist calendar with the given fields.
     */
    newBuddhistDate(fields: Partial<CalendarDateFields>): BuddhistDate;
    /**
     * Construct a new date in the Buddhist calendar representing the current date and time.
     */
    nowBuddhist(zoneId?: string): BuddhistDate;
    /**
     * Convert the given date to the Gregorian calendar.
     */
    toGregorianDate(date: CalendarDate | ZonedDateTime | Date): GregorianDate;
    /**
     * Construct a new date in the Gregorian calendar with the given fields.
     */
    newGregorianDate(fields: Partial<CalendarDateFields>): GregorianDate;
    /**
     * Construct a new date in the Gregorian calendar representing the current date and time.
     */
    nowGregorian(zoneId?: string): GregorianDate;
    /**
     * Convert the given date to the ISO-8601 calendar.
     */
    toISO8601Date(date: CalendarDate | ZonedDateTime | Date): ISO8601Date;
    /**
     * Construct a new date in the ISO-8601 calendar with the given fields.
     */
    newISO8601Date(fields: Partial<CalendarDateFields>): ISO8601Date;
    /**
     * Construct a new date in the ISO8601 calendar representing the current date and time.
     */
    nowISO8601(zoneId?: string): ISO8601Date;
    /**
     * Convert the given date to the Japanese calendar.
     */
    toJapaneseDate(date: CalendarDate | ZonedDateTime | Date): JapaneseDate;
    /**
     * Construct a new date in the Japanese calendar with the given fields.
     */
    newJapaneseDate(fields: Partial<CalendarDateFields>): JapaneseDate;
    /**
     * Construct a new date in the Japanese calendar representing the current date and time.
     */
    nowJapanese(zoneId?: string): JapaneseDate;
    /**
     * Convert the given date to the Persian calendar.
     */
    toPersianDate(date: CalendarDate | ZonedDateTime | Date): PersianDate;
    /**
     * Construct a new date in the Persian calendar with the given fields.
     */
    newPersianDate(fields: Partial<CalendarDateFields>): PersianDate;
    /**
     * Construct a new date in the Persian calendar representing the current date and time.
     */
    nowPersian(zoneId?: string): PersianDate;
    /**
     * Find the field of visual difference between two dates. For example, the
     * dates "2019-03-31" and "2019-04-01" differ visually in the month field,
     * even though the dates are only 1 day apart.
     *
     * This can be used by applications to select an appropriate skeleton for date
     * interval formatting, e.g. to format "March 31 - April 01, 2019"
     */
    fieldOfVisualDifference(a: CalendarDate | ZonedDateTime | Date, b: CalendarDate | ZonedDateTime | Date): DateTimePatternFieldType;
    /**
     * Format a calendar date to string using the given options.
     */
    formatDate(date: CalendarDate | ZonedDateTime | Date, options?: DateFormatOptions): string;
    /**
     * Format a calendar date to a parts array using the given options.
     */
    formatDateToParts(date: CalendarDate | ZonedDateTime | Date, options?: DateFormatOptions): Part[];
    formatDateInterval(start: CalendarDate | ZonedDateTime | Date, end: CalendarDate | ZonedDateTime | Date, options?: DateIntervalFormatOptions): string;
    formatDateIntervalToParts(start: CalendarDate | ZonedDateTime | Date, end: CalendarDate | ZonedDateTime | Date, options?: DateIntervalFormatOptions): Part[];
    formatRelativeTimeField(value: DecimalArg, field: RelativeTimeFieldType, options?: RelativeTimeFieldFormatOptions): string;
    formatRelativeTime(start: CalendarDate | ZonedDateTime | Date, end: CalendarDate | ZonedDateTime | Date, options?: RelativeTimeFormatOptions): string;
    /**
     * Format a raw date pattern. Note: This should not be used, but is available for debugging or
     * extreme cases where an application must implement a custom format.
     */
    formatDateRaw(date: CalendarDate | ZonedDateTime | Date, options?: DateRawFormatOptions): string;
    formatDateRawToParts(date: CalendarDate | ZonedDateTime | Date, options?: DateRawFormatOptions): Part[];
    formatDateWrapper(date: string, time: string, options?: DateWrapperFormatOptions): string;
    formatDateWrapperToParts(date: Part[], time: Part[], options?: DateWrapperFormatOptions): Part[];
    timeData(): TimeData;
    timeZoneIds(): string[];
    resolveTimeZoneId(zoneid: string): string | undefined;
    timeZoneInfo(zoneid: string): TimeZoneInfo;
    timeZoneFromUTC(utc: number, zoneid: string): ZoneInfo | undefined;
    timeZoneFromWall(wall: number, zoneid: string): [number, ZoneInfo] | undefined;
    timePeriodToQuantity(period: Partial<TimePeriod>): Quantity[];
    private _getPatterns;
    /**
     * Copy fields, applying an optional context transform to the values.
     */
    private _transformFields;
    private _transformField;
    private _formatDate;
    private _formatInterval;
    private _context;
    private _formatDateRaw;
    private _formatDateWrapper;
    private convertDate;
    private convertEpoch;
    private convertDateTo;
}
