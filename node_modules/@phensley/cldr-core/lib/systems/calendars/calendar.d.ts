import { DateTimePatternFieldType, MetaZoneType } from '@phensley/cldr-types';
import { ZoneInfo } from './timezone';
import { TimePeriod, TimePeriodField } from './interval';
import { CalendarDateFields, CalendarType } from './types';
/**
 * @internal
 */
export type CalendarFromUnixEpoch<T> = (epoch: number, zoneId: string, firstDay: number, minDays: number) => T;
/**
 * Base class for dates in supported calendars.
 *
 * @public
 */
export declare abstract class CalendarDate {
    protected readonly _type: CalendarType;
    protected readonly _firstDay: number;
    protected readonly _minDays: number;
    protected static _gregorian: (d: CalendarDate, utc: boolean, firstDate: number, minDays: number) => CalendarDate;
    protected _fields: number[];
    protected _zoneInfo: ZoneInfo;
    /**
     * Minimal fields required to construct any calendar date.
     */
    protected constructor(_type: CalendarType, _firstDay: number, _minDays: number);
    /**
     * Calendar type for this date, e.g. 'gregory' for Gregorian.
     */
    type(): CalendarType;
    /**
     * Returns a formatted ISO-8601 string of the date in UTC. Note that this
     * always returns a date in the Gregorian calendar.
     */
    toISOString(): string;
    /**
     * Returns a formatted ISO 8601 string of the date with local timezone offset.
     * Note that this always returns a date in the Gregorian calendar.
     */
    toLocalISOString(): string;
    /**
     * Unix epoch with no timezone offset.
     */
    unixEpoch(): number;
    firstDayOfWeek(): number;
    minDaysInFirstWeek(): number;
    /**
     * Returns a floating point number representing the real Julian Day, UTC.
     */
    julianDay(): number;
    /**
     * CLDR's modified Julian day used as the basis for all date calculations.
     */
    modifiedJulianDay(): number;
    era(): number;
    extendedYear(): number;
    year(): number;
    relatedYear(): number;
    yearOfWeekOfYear(): number;
    weekOfYear(): number;
    yearOfWeekOfYearISO(): number;
    weekOfYearISO(): number;
    /**
     * Ordinal month, one-based, e.g. Gregorian JANUARY = 1.
     */
    month(): number;
    /**
     * Returns the week of the month computed using the locale's 'first day
     * of week' and 'minimal days in first week' where applicable.
     *
     * For example, for the United States, weeks start on Sunday.
     * Saturday 9/1/2018 would be in week 1, and Sunday 9/2/2018 would
     * begin week 2.
     *
     *         September
     *   Su Mo Tu We Th Fr Sa
     *                      1
     *    2  3  4  5  6  7  8
     *    9 10 11 12 13 14 15
     *   16 17 18 19 20 21 22
     *   23 24 25 26 27 28 29
     *   30
     */
    weekOfMonth(): number;
    dayOfYear(): number;
    /**
     * Day of the week. 1 = SUNDAY, 2 = MONDAY, ..., 7 = SATURDAY
     */
    dayOfWeek(): number;
    /**
     * Ordinal day of the week. 1 if this is the 1st day of the week,
     * 2 if the 2nd, etc. Depends on the local starting day of the week.
     */
    ordinalDayOfWeek(): number;
    /**
     * Ordinal number indicating the day of the week in the current month.
     * The result of this method can be used to format messages like
     * "2nd Sunday in August".
     */
    dayOfWeekInMonth(): number;
    dayOfMonth(): number;
    isAM(): boolean;
    /**
     * Indicates the hour of the morning or afternoon, used for the 12-hour
     * clock (0 - 11). Noon and midnight are 0, not 12.
     */
    hour(): number;
    /**
     * Indicates the hour of the day, used for the 24-hour clock (0 - 23).
     * Noon is 12 and midnight is 0.
     */
    hourOfDay(): number;
    /**
     * Indicates the minute of the hour (0 - 59).
     */
    minute(): number;
    /**
     * Indicates the second of the minute (0 - 59).
     */
    second(): number;
    milliseconds(): number;
    millisecondsInDay(): number;
    metaZoneId(): MetaZoneType;
    timeZoneId(): string;
    timeZoneStableId(): string;
    timeZoneOffset(): number;
    isLeapYear(): boolean;
    isDaylightSavings(): boolean;
    /**
     * Computes the field of visual difference between the two dates.
     * Note: This assumes the dates are of the same type and have the same
     * timezone offset.
     */
    fieldOfVisualDifference(other: CalendarDate): DateTimePatternFieldType;
    /**
     * Compare two dates a and b, returning:
     *
     * ```
     *   a < b  ->  -1
     *   a = b  ->  0
     *   a > b  ->  1
     * ```
     */
    compare(other: CalendarDate): number;
    /**
     * Calculate the relative time between two dates. If a field is specified
     * the time will be calculated in terms of that single field. Otherwise
     * the field of greatest difference will be used.
     */
    relativeTime(other: CalendarDate, field?: TimePeriodField): [TimePeriodField, number];
    /**
     * Calculate the time period between two dates. Note this returns the
     * absolute value of the difference.
     */
    difference(other: CalendarDate, fields?: TimePeriodField[]): TimePeriod;
    /**
     * Calculate the time period between two dates. If 'other' is before this date,
     * the time period fields will be negative.
     */
    differenceSigned(other: CalendarDate, fields?: TimePeriodField[]): TimePeriod;
    /**
     * Return all of the date and time field values.
     */
    fields(): CalendarDateFields;
    /**
     * Return a JavaScript Date object with the same date and time.
     */
    asJSDate(): Date;
    /**
     * Set one or more fields on this date explicitly, and return a new date.
     *
     * Note: when setting the 'year' field you must use the "extended year".
     * For example, the extended year 0 is 1 B.C in the Gregorian calendar.
     */
    abstract set(fields: Partial<CalendarDateFields>): CalendarDate;
    /**
     * Add the fields to this date, returning a new date.
     */
    abstract add(fields: Partial<TimePeriod>): CalendarDate;
    /**
     * Subtract the fields from this date, returning a new date.
     */
    abstract subtract(fields: Partial<TimePeriod>): CalendarDate;
    /**
     * Change the timezone for this date, returning a new date.
     */
    abstract withZone(zoneId: string): CalendarDate;
    protected abstract _new(): CalendarDate;
    protected abstract initFields(f: number[]): void;
    protected abstract monthCount(): number;
    protected abstract daysInMonth(y: number, m: number): number;
    protected abstract daysInYear(y: number): number;
    protected abstract monthStart(eyear: number, month: number, useMonth: boolean): number;
    protected _toISOString(d: CalendarDate, utc: boolean): string;
    /**
     * Rollup just the time fields into number of milliseconds. This is internal
     * and assumes all time fields are defined.
     */
    protected _timeToMs(f: Partial<CalendarDateFields>): number;
    protected _invertPeriod(fields: Partial<TimePeriod>): Partial<TimePeriod>;
    /**
     * Roll up time period fields into a subset of fields.
     */
    protected _rollup(span: Partial<TimePeriod>, sf: number[], ef: number[], fields: TimePeriodField[]): TimePeriod;
    /**
     * Compute the number of years, months, days, etc, between two dates. The result will
     * have all fields as integers.
     */
    protected _diff(s: CalendarDate, sf: number[], ef: number[]): TimePeriod;
    protected swap(other: CalendarDate): [CalendarDate, number[], CalendarDate, number[]];
    /**
     * Compute a new Julian day and milliseconds UTC by updating one or more fields.
     */
    protected _add(fields: Partial<TimePeriod>): [number, number];
    /**
     * Converts all time fields into [days, milliseconds].
     */
    protected _addTime(fields: Partial<TimePeriod>): [number, number];
    protected initFromUnixEpoch(ms: number, zoneId: string): void;
    protected initFromJD(jd: number, msDay: number, zoneId: string): void;
    protected _toString(type: string): string;
    /**
     * Compute WEEK_OF_YEAR and YEAR_WOY on demand.
     */
    protected computeWeekFields(): void;
    protected _computeWeekFields(woyfield: number, ywoyfield: number, firstDay: number, minDays: number, dow: number, _dom: number, doy: number): void;
    protected yearLength(y: number): number;
    protected weekNumber(firstDay: number, minDays: number, desiredDay: number, dayOfPeriod: number, dayOfWeek: number): number;
    protected utcfields(): number[];
}
