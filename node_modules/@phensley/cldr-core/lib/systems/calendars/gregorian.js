"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GregorianDate = void 0;
var tslib_1 = require("tslib");
var timezone_1 = require("@phensley/timezone");
var calendar_1 = require("./calendar");
var utils_1 = require("./utils");
var ZEROS = {
    year: 1970,
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millis: 0,
};
/**
 * Construct a date using the rules of the Gregorian calendar.
 *
 * type: gregory
 *
 * @public
 */
var GregorianDate = /** @class */ (function (_super) {
    tslib_1.__extends(GregorianDate, _super);
    function GregorianDate(type, firstDay, minDays) {
        return _super.call(this, type, firstDay, minDays) || this;
    }
    GregorianDate.prototype.set = function (fields) {
        return this._set(tslib_1.__assign(tslib_1.__assign({}, this.fields()), fields));
    };
    GregorianDate.prototype.add = function (fields) {
        var _a = this._add(fields), jd = _a[0], ms = _a[1];
        return this._new().initFromJD(jd, ms, this.timeZoneId());
    };
    GregorianDate.prototype.subtract = function (fields) {
        return this.add(this._invertPeriod(fields));
    };
    GregorianDate.prototype.withZone = function (zoneId) {
        return this._new().initFromUnixEpoch(this.unixEpoch(), zoneId);
    };
    GregorianDate.prototype.toString = function () {
        return this._toString('Gregorian');
    };
    GregorianDate.fromFields = function (fields, firstDay, minDays) {
        return new GregorianDate('gregory', firstDay, minDays)._set(tslib_1.__assign(tslib_1.__assign({}, ZEROS), fields));
    };
    GregorianDate.fromUnixEpoch = function (epoch, zoneId, firstDay, minDays) {
        if (firstDay === void 0) { firstDay = 1; }
        if (minDays === void 0) { minDays = 1; }
        return new GregorianDate('gregory', firstDay, minDays).initFromUnixEpoch(epoch, zoneId);
    };
    GregorianDate.prototype._new = function () {
        return new GregorianDate('gregory', this._firstDay, this._minDays);
    };
    GregorianDate.prototype.initFromUnixEpoch = function (epoch, zoneId) {
        _super.prototype.initFromUnixEpoch.call(this, epoch, zoneId);
        this.initFields(this._fields);
        return this;
    };
    GregorianDate.prototype.initFromJD = function (jd, msDay, zoneId) {
        _super.prototype.initFromJD.call(this, jd, msDay, zoneId);
        this.initFields(this._fields);
        return this;
    };
    GregorianDate.prototype.initFields = function (f) {
        if (f[1 /* DateField.JULIAN_DAY */] >= 2299161 /* CalendarConstants.JD_GREGORIAN_CUTOVER */) {
            computeGregorianFields(f);
        }
        else {
            // We use Julian calendar for dates before the Gregorian cutover
            computeJulianFields(f);
        }
        // Set era and year based on extended year
        var year = f[3 /* DateField.EXTENDED_YEAR */];
        var era = 1; // AD
        if (year < 1) {
            era = 0;
            year = 1 - year;
        }
        f[2 /* DateField.ERA */] = era;
        f[4 /* DateField.YEAR */] = year;
    };
    GregorianDate.prototype.daysInMonth = function (y, m) {
        return MONTH_COUNT[m][leapGregorian(y) ? 1 : 0];
    };
    GregorianDate.prototype.daysInYear = function (y) {
        return leapGregorian(y) ? 366 : 365;
    };
    GregorianDate.prototype.monthCount = function () {
        return 12;
    };
    GregorianDate.prototype.monthStart = function (eyear, month, _useMonth) {
        var isLeap = (eyear | 0) % 4 === 0;
        var y = eyear - 1;
        var jd = 365 * y + floor(y / 4) + (1721426 /* CalendarConstants.JD_GREGORIAN_EPOCH */ - 3);
        if (eyear >= 1582 /* CalendarConstants.JD_GREGORIAN_CUTOVER_YEAR */) {
            isLeap = isLeap && (eyear % 100 !== 0 || eyear % 400 === 0);
            jd += floor(y / 400) - floor(y / 100) + 2;
        }
        if (month !== 0) {
            var mc = MONTH_COUNT;
            var m = floor(month);
            var d = month - m;
            jd += mc[m][isLeap ? 3 : 2];
            // TODO: we never reach the block below since all internal uses of monthStart
            // pass in an integer
            // Check if there is a fractional month part, and if so add the number
            // of the days in the next month multiplied by the fraction
            /* istanbul ignore if */
            if (d !== 0) {
                // note: the 'month' parameter must always be <= # months in the calendar
                // year, so <= 12 in this case.
                jd += d * mc[m + 1][isLeap ? 1 : 0];
            }
        }
        return jd;
    };
    /**
     * Convert integer (year, month, day) to Julian day.
     */
    GregorianDate.prototype._ymdToJD = function (y, m, d) {
        y |= 0;
        var leap = leapGregorian(y);
        var mc = this.monthCount();
        m = m < 1 ? 1 : m > mc ? mc : m;
        var dc = MONTH_COUNT[m - 1][leap ? 1 : 0];
        d = d < 1 ? 1 : d > dc ? dc : d;
        // Adjustment due to Gregorian calendar switch on Oct 4, 1582 -> Oct 15, 1582
        if (y < 1582 /* CalendarConstants.JD_GREGORIAN_CUTOVER_YEAR */ ||
            (y === 1582 /* CalendarConstants.JD_GREGORIAN_CUTOVER_YEAR */ &&
                (m < 10 /* CalendarConstants.JD_GREGORIAN_CUTOVER_MONTH */ ||
                    (m === 10 /* CalendarConstants.JD_GREGORIAN_CUTOVER_MONTH */ && d < 15 /* CalendarConstants.JD_GREGORIAN_CUTOVER_DAY */)))) {
            if (m < 3) {
                m += 12;
                y -= 1;
            }
            return 1721117 + floor((1461 * y) / 4) + floor((153 * m - 457) / 5) + d;
        }
        var a = ((14 - m) / 12) | 0;
        y = y + 4800 - a;
        m = m + 12 * a - 3;
        return d + (((153 * m + 2) / 5) | 0) + 365 * y + ((y / 4) | 0) - ((y / 100) | 0) + ((y / 400) | 0) - 32045;
    };
    GregorianDate.prototype._set = function (f) {
        var jd = this._ymdToJD(f.year, f.month, f.day);
        var ms = this._timeToMs(f);
        var epoch = unixEpochFromJD(jd, ms);
        var zoneId = f.zoneId || this.timeZoneId();
        // Find UTC epoch for wall clock time in the requested timezone
        var r = timezone_1.TZ.fromWall(zoneId, epoch);
        return this._new().initFromUnixEpoch(r ? r[0] : epoch, zoneId);
    };
    GregorianDate._init = (function () {
        calendar_1.CalendarDate._gregorian = function (d, utc, fd, md) {
            return GregorianDate.fromUnixEpoch(d.unixEpoch(), utc ? 'Etc/UTC' : d.timeZoneId(), fd, md);
        };
    })();
    return GregorianDate;
}(calendar_1.CalendarDate));
exports.GregorianDate = GregorianDate;
var floor = Math.floor;
var MONTH_COUNT = [
    [31, 31, 0, 0], // Jan
    [28, 29, 31, 31], // Feb
    [31, 31, 59, 60], // Mar
    [30, 30, 90, 91], // Apr
    [31, 31, 120, 121], // May
    [30, 30, 151, 152], // Jun
    [31, 31, 181, 182], // Jul
    [31, 31, 212, 213], // Aug
    [30, 30, 243, 244], // Sep
    [31, 31, 273, 274], // Oct
    [30, 30, 304, 305], // Nov
    [31, 31, 334, 335], // Dec
];
/**
 * Compute fields for dates on or after the Gregorian cutover.
 */
var computeGregorianFields = function (f) {
    var ged = f[1 /* DateField.JULIAN_DAY */] - 1721426 /* CalendarConstants.JD_GREGORIAN_EPOCH */;
    var rem = [0];
    var n400 = (0, utils_1.floorDiv)(ged, 146097, rem);
    var n100 = (0, utils_1.floorDiv)(rem[0], 36524, rem);
    var n4 = (0, utils_1.floorDiv)(rem[0], 1461, rem);
    var n1 = (0, utils_1.floorDiv)(rem[0], 365, rem);
    var year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
    var doy = rem[0]; // 0-based day of year
    if (n100 === 4 || n1 === 4) {
        doy = 365;
    }
    else {
        ++year;
    }
    var isLeap = leapGregorian(year);
    var corr = 0;
    var mar1 = isLeap ? 60 : 59;
    if (doy >= mar1) {
        corr = isLeap ? 1 : 2;
    }
    var month = floor((12 * (doy + corr) + 6) / 367);
    var dom = doy - MONTH_COUNT[month][isLeap ? 3 : 2] + 1;
    f[3 /* DateField.EXTENDED_YEAR */] = year;
    f[7 /* DateField.MONTH */] = month + 1;
    f[10 /* DateField.DAY_OF_MONTH */] = dom;
    f[9 /* DateField.DAY_OF_YEAR */] = doy + 1;
    f[21 /* DateField.IS_LEAP */] = isLeap ? 1 : 0;
};
/**
 * Compute fields for dates before the Gregorian cutover using the proleptic
 * Julian calendar. Any Gregorian date before October 15, 1582 is really a
 * date on the proleptic Julian calendar, with leap years every 4 years.
 */
var computeJulianFields = function (f) {
    var jed = f[1 /* DateField.JULIAN_DAY */] - (1721426 /* CalendarConstants.JD_GREGORIAN_EPOCH */ - 2);
    var eyear = floor((4 * jed + 1464) / 1461);
    var jan1 = 365 * (eyear - 1) + floor((eyear - 1) / 4);
    var doy = jed - jan1;
    var isLeap = eyear % 4 === 0;
    var corr = 0;
    var mar1 = isLeap ? 60 : 59;
    if (doy >= mar1) {
        corr = isLeap ? 1 : 2;
    }
    var month = floor((12 * (doy + corr) + 6) / 367);
    var dom = doy - MONTH_COUNT[month][isLeap ? 3 : 2] + 1;
    f[3 /* DateField.EXTENDED_YEAR */] = eyear;
    f[7 /* DateField.MONTH */] = month + 1;
    f[10 /* DateField.DAY_OF_MONTH */] = dom;
    f[9 /* DateField.DAY_OF_YEAR */] = doy + 1;
    f[21 /* DateField.IS_LEAP */] = isLeap ? 1 : 0;
};
/**
 * Return true if the given year is a leap year in the Gregorian calendar; false otherwise.
 * Note that we switch to the Julian calendar at the Gregorian cutover year.
 */
var leapGregorian = function (y) {
    var r = y % 4 === 0;
    if (y >= 1582 /* CalendarConstants.JD_GREGORIAN_CUTOVER_YEAR */) {
        r = r && (y % 100 !== 0 || y % 400 === 0);
    }
    return r;
};
/**
 * Given a Julian day and local milliseconds (in UTC), return the Unix
 * epoch milliseconds UTC.
 */
var unixEpochFromJD = function (jd, msDay) {
    var days = jd - 2440588 /* CalendarConstants.JD_UNIX_EPOCH */;
    return days * 86400000 /* CalendarConstants.ONE_DAY_MS */ + Math.round(msDay);
};
//# sourceMappingURL=gregorian.js.map