// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
// IMPORTANT - do not use any non-built-in libraries in this file
import * as fs from 'fs';
import * as path from 'path';
/**
 * This function reads the content for given .npmrc file path, and also trims
 * unusable lines from the .npmrc file.
 *
 * @returns
 * The text of the the .npmrc.
 */
// create a global _combinedNpmrc for cache purpose
const _combinedNpmrcMap = new Map();
function _trimNpmrcFile(options) {
    const { sourceNpmrcPath, linesToPrepend, linesToAppend } = options;
    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);
    if (combinedNpmrcFromCache !== undefined) {
        return combinedNpmrcFromCache;
    }
    let npmrcFileLines = [];
    if (linesToPrepend) {
        npmrcFileLines.push(...linesToPrepend);
    }
    if (fs.existsSync(sourceNpmrcPath)) {
        npmrcFileLines.push(...fs.readFileSync(sourceNpmrcPath).toString().split('\n'));
    }
    if (linesToAppend) {
        npmrcFileLines.push(...linesToAppend);
    }
    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
    const resultLines = [];
    // This finds environment variable tokens that look like "${VAR_NAME}"
    const expansionRegExp = /\$\{([^\}]+)\}/g;
    // Comment lines start with "#" or ";"
    const commentRegExp = /^\s*[#;]/;
    // Trim out lines that reference environment variables that aren't defined
    for (let line of npmrcFileLines) {
        let lineShouldBeTrimmed = false;
        //remove spaces before or after key and value
        line = line
            .split('=')
            .map((lineToTrim) => lineToTrim.trim())
            .join('=');
        // Ignore comment lines
        if (!commentRegExp.test(line)) {
            const environmentVariables = line.match(expansionRegExp);
            if (environmentVariables) {
                for (const token of environmentVariables) {
                    // Remove the leading "${" and the trailing "}" from the token
                    const environmentVariableName = token.substring(2, token.length - 1);
                    // Is the environment variable defined?
                    if (!process.env[environmentVariableName]) {
                        // No, so trim this line
                        lineShouldBeTrimmed = true;
                        break;
                    }
                }
            }
        }
        if (lineShouldBeTrimmed) {
            // Example output:
            // "; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}"
            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);
        }
        else {
            resultLines.push(line);
        }
    }
    const combinedNpmrc = resultLines.join('\n');
    //save the cache
    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
function _copyAndTrimNpmrcFile(options) {
    const { logger, sourceNpmrcPath, targetNpmrcPath, linesToPrepend, linesToAppend } = options;
    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose
    logger.info(`  --> "${targetNpmrcPath}"`);
    const combinedNpmrc = _trimNpmrcFile({
        sourceNpmrcPath,
        linesToPrepend,
        linesToAppend
    });
    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
export function syncNpmrc(options) {
    const { sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {
        // eslint-disable-next-line no-console
        info: console.log,
        // eslint-disable-next-line no-console
        error: console.error
    }, createIfMissing = false, linesToAppend, linesToPrepend } = options;
    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');
    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');
    try {
        if (fs.existsSync(sourceNpmrcPath) || createIfMissing) {
            // Ensure the target folder exists
            if (!fs.existsSync(targetNpmrcFolder)) {
                fs.mkdirSync(targetNpmrcFolder, { recursive: true });
            }
            return _copyAndTrimNpmrcFile({
                sourceNpmrcPath,
                targetNpmrcPath,
                logger,
                linesToAppend,
                linesToPrepend
            });
        }
        else if (fs.existsSync(targetNpmrcPath)) {
            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target
            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose
            fs.unlinkSync(targetNpmrcPath);
        }
    }
    catch (e) {
        throw new Error(`Error syncing .npmrc file: ${e}`);
    }
}
export function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey) {
    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;
    //if .npmrc file does not exist, return false directly
    if (!fs.existsSync(sourceNpmrcPath)) {
        return false;
    }
    const trimmedNpmrcFile = _trimNpmrcFile({ sourceNpmrcPath });
    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');
    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;
}
//# sourceMappingURL=npmrcUtilities.js.map