"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// THIS SCRIPT IS GENERATED BY THE "rush deploy" COMMAND.
const node_os_1 = __importDefault(require("node:os"));
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const MAX_CONCURRENCY = node_os_1.default.cpus().length * 2;
const CREATE_ACTION_NAME = 'create';
const REMOVE_ACTION_NAME = 'remove';
const REALIZE_FILES_OPTION_NAME = '--realize-files';
const TARGET_ROOT_SCRIPT_RELATIVE_PATH = '{TARGET_ROOT_SCRIPT_RELATIVE_PATH}';
const TARGET_ROOT_FOLDER = node_path_1.default.resolve(__dirname, TARGET_ROOT_SCRIPT_RELATIVE_PATH);
async function removeLinksAsync(terminal, targetRootFolder, extractorMetadataObject) {
    await node_core_library_1.Async.forEachAsync(extractorMetadataObject.links, async ({ linkPath }) => {
        const newLinkPath = `${targetRootFolder}/${linkPath}`;
        terminal.writeVerboseLine(`Removing link at path "${newLinkPath}"`);
        await node_core_library_1.FileSystem.deleteFileAsync(newLinkPath, { throwIfNotExists: false });
    }, { concurrency: MAX_CONCURRENCY });
}
async function createLinksAsync(terminal, targetRootFolder, extractorMetadataObject) {
    await node_core_library_1.Async.forEachAsync(extractorMetadataObject.links, async (linkInfo) => {
        // Link to the relative path for symlinks
        const newLinkPath = `${targetRootFolder}/${linkInfo.linkPath}`;
        const linkTargetPath = `${targetRootFolder}/${linkInfo.targetPath}`;
        // Make sure the containing folder exists
        await node_core_library_1.FileSystem.ensureFolderAsync(node_path_1.default.dirname(newLinkPath));
        // NOTE: This logic is based on NpmLinkManager._createSymlink()
        if (linkInfo.kind === 'folderLink') {
            terminal.writeVerboseLine(`Creating linked folder at path "${newLinkPath}"`);
            await node_core_library_1.FileSystem.createSymbolicLinkJunctionAsync({ newLinkPath, linkTargetPath });
        }
        else if (linkInfo.kind === 'fileLink') {
            // Use hardlinks for Windows and symlinks for other platforms since creating a symbolic link
            // requires administrator permission on Windows. This may cause unexpected behaviour for consumers
            // of the hardlinked files. If this becomes an issue, we may need to revisit this.
            terminal.writeVerboseLine(`Creating linked file at path "${newLinkPath}"`);
            if (process.platform === 'win32') {
                await node_core_library_1.FileSystem.createHardLinkAsync({ newLinkPath, linkTargetPath });
            }
            else {
                await node_core_library_1.FileSystem.createSymbolicLinkFileAsync({ newLinkPath, linkTargetPath });
            }
        }
    }, { concurrency: MAX_CONCURRENCY });
}
async function realizeFilesAsync(terminal, targetRootFolder, extractorMetadataObject) {
    await node_core_library_1.Async.forEachAsync(extractorMetadataObject.files, async (relativeFilePath) => {
        const filePath = `${targetRootFolder}/${relativeFilePath}`;
        const realFilePath = await node_core_library_1.FileSystem.getRealPathAsync(filePath);
        if (!node_core_library_1.Path.isEqual(realFilePath, filePath)) {
            await node_core_library_1.FileSystem.deleteFileAsync(filePath);
            // Hard links seem to cause build failures on Mac, so for all other operating
            // systems we copy files.
            terminal.writeVerboseLine(`Realizing file at path "${filePath}"`);
            if (process.platform === 'win32') {
                await node_core_library_1.FileSystem.createHardLinkAsync({ newLinkPath: filePath, linkTargetPath: realFilePath });
            }
            else {
                await node_core_library_1.FileSystem.copyFileAsync({ sourcePath: realFilePath, destinationPath: filePath });
            }
        }
    }, { concurrency: MAX_CONCURRENCY });
}
function showUsage(terminal) {
    terminal.writeLine('Usage:');
    terminal.writeLine(`  node create-links.js ${CREATE_ACTION_NAME} [${REALIZE_FILES_OPTION_NAME}]`);
    terminal.writeLine(`  node create-links.js ${REMOVE_ACTION_NAME}`);
    terminal.writeLine('');
    terminal.writeLine('Creates or removes the symlinks for the output folder created by "rush deploy".');
    terminal.writeLine('The link information is read from "extractor-metadata.json" in the same folder.');
}
async function runAsync(terminal) {
    // Example: [ "node.exe", "create-links.js", ""create" ]
    const args = process.argv.slice(2);
    if ((args[0] !== CREATE_ACTION_NAME && args[0] !== REMOVE_ACTION_NAME) ||
        (args[0] === CREATE_ACTION_NAME && args[1] && args[1] !== REALIZE_FILES_OPTION_NAME) ||
        (args[0] === REMOVE_ACTION_NAME && args[1])) {
        showUsage(terminal);
        return false;
    }
    const extractorMetadataPath = `${__dirname}/extractor-metadata.json`;
    if (!node_fs_1.default.existsSync(extractorMetadataPath)) {
        throw new Error('Input file not found: ' + extractorMetadataPath);
    }
    const extractorMetadataJson = node_fs_1.default.readFileSync(extractorMetadataPath).toString();
    const extractorMetadataObject = JSON.parse(extractorMetadataJson);
    if (args[0] === 'create') {
        const realizeFiles = args[1] === '--realize-files';
        terminal.writeLine(`Creating links for extraction at path "${TARGET_ROOT_FOLDER}"`);
        await removeLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
        await createLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
        if (realizeFiles) {
            await realizeFilesAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
        }
    }
    else if (args[0] === 'remove') {
        terminal.writeLine(`Removing links for extraction at path "${TARGET_ROOT_FOLDER}"`);
        await removeLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
    }
    terminal.writeLine('The operation completed successfully.');
    return true;
}
process.exitCode = 1;
const terminal = new terminal_1.Terminal(new terminal_1.ConsoleTerminalProvider());
runAsync(terminal)
    .then((result) => {
    process.exitCode = result ? 0 : 1;
})
    .catch((error) => {
    terminal.writeErrorLine('ERROR: ' + error);
});
//# sourceMappingURL=create-links.js.map