{"version":3,"file":"LookupByPath.js","sourceRoot":"","sources":["../src/LookupByPath.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * A node in the path trie used in LookupByPath\n */\ninterface IPathTrieNode<TItem> {\n  /**\n   * The value that exactly matches the current relative path\n   */\n  value: TItem | undefined;\n  /**\n   * Child nodes by subfolder\n   */\n  children: Map<string, IPathTrieNode<TItem>> | undefined;\n}\n\ninterface IPrefixEntry {\n  /**\n   * The prefix that was matched\n   */\n  prefix: string;\n  /**\n   * The index of the first character after the matched prefix\n   */\n  index: number;\n}\n\n/**\n * Object containing both the matched item and the start index of the remainder of the query.\n *\n * @beta\n */\nexport interface IPrefixMatch<TItem> {\n  /**\n   * The item that matched the prefix\n   */\n  value: TItem;\n  /**\n   * The index of the first character after the matched prefix\n   */\n  index: number;\n  /**\n   * The last match found (with a shorter prefix), if any\n   */\n  lastMatch?: IPrefixMatch<TItem>;\n}\n\n/**\n * The readonly component of `LookupByPath`, to simplify unit testing.\n *\n * @beta\n */\nexport interface IReadonlyLookupByPath<TItem> {\n  /**\n   * Searches for the item associated with `childPath`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findChildPath('foo/baz'); // returns 1\n   * trie.findChildPath('foo/bar/baz'); // returns 2\n   * ```\n   */\n  findChildPath(childPath: string): TItem | undefined;\n\n  /**\n   * Searches for the item for which the recorded prefix is the longest matching prefix of `query`.\n   * Obtains both the item and the length of the matched prefix, so that the remainder of the path can be\n   * extracted.\n   *\n   * @returns the found item and the length of the matched prefix, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findLongestPrefixMatch('foo/baz'); // returns { item: 1, index: 3 }\n   * trie.findLongestPrefixMatch('foo/bar/baz'); // returns { item: 2, index: 7 }\n   * ```\n   */\n  findLongestPrefixMatch(query: string): IPrefixMatch<TItem> | undefined;\n\n  /**\n   * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findChildPathFromSegments(['foo', 'baz']); // returns 1\n   * trie.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2\n   * ```\n   */\n  findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined;\n\n  /**\n   * Groups the provided map of info by the nearest entry in the trie that contains the path. If the path\n   * is not found in the trie, the info is ignored.\n   *\n   * @returns The grouped info, grouped by the nearest entry in the trie that contains the path\n   *\n   * @param infoByPath - The info to be grouped, keyed by path\n   */\n  groupByChild<TInfo>(infoByPath: Map<string, TInfo>): Map<TItem, Map<string, TInfo>>;\n}\n\n/**\n * This class is used to associate path-like-strings, such as those returned by `git` commands,\n * with entities that correspond with ancestor folders, such as Rush Projects or npm packages.\n *\n * It is optimized for efficiently locating the nearest ancestor path with an associated value.\n *\n * It is implemented as a Trie (https://en.wikipedia.org/wiki/Trie) data structure, with each edge\n * being a path segment.\n *\n * @example\n * ```ts\n * const trie = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);\n * trie.findChildPath('foo'); // returns 1\n * trie.findChildPath('foo/baz'); // returns 1\n * trie.findChildPath('baz'); // returns undefined\n * trie.findChildPath('foo/bar/baz'); returns 3\n * trie.findChildPath('bar/foo/bar'); returns 2\n * ```\n * @beta\n */\nexport class LookupByPath<TItem> implements IReadonlyLookupByPath<TItem> {\n  /**\n   * The delimiter used to split paths\n   */\n  public readonly delimiter: string;\n  /**\n   * The root node of the trie, corresponding to the path ''\n   */\n  private readonly _root: IPathTrieNode<TItem>;\n\n  /**\n   * Constructs a new `LookupByPath`\n   *\n   * @param entries - Initial path-value pairs to populate the trie.\n   */\n  public constructor(entries?: Iterable<[string, TItem]>, delimiter?: string) {\n    this._root = {\n      value: undefined,\n      children: undefined\n    };\n\n    this.delimiter = delimiter ?? '/';\n\n    if (entries) {\n      for (const [path, item] of entries) {\n        this.setItem(path, item);\n      }\n    }\n  }\n\n  /**\n   * Iterates over the segments of a serialized path.\n   *\n   * @example\n   *\n   * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'\n   *\n   * `LookupByPath.iteratePathSegments('foo\\\\bar\\\\baz', '\\\\')` yields 'foo', 'bar', 'baz'\n   */\n  public static *iteratePathSegments(serializedPath: string, delimiter: string = '/'): Iterable<string> {\n    for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {\n      yield prefixMatch.prefix;\n    }\n  }\n\n  private static *_iteratePrefixes(input: string, delimiter: string = '/'): Iterable<IPrefixEntry> {\n    if (!input) {\n      return;\n    }\n\n    let previousIndex: number = 0;\n    let nextIndex: number = input.indexOf(delimiter);\n\n    // Leading segments\n    while (nextIndex >= 0) {\n      yield {\n        prefix: input.slice(previousIndex, nextIndex),\n        index: nextIndex\n      };\n      previousIndex = nextIndex + 1;\n      nextIndex = input.indexOf(delimiter, previousIndex);\n    }\n\n    // Last segment\n    if (previousIndex < input.length) {\n      yield {\n        prefix: input.slice(previousIndex, input.length),\n        index: input.length\n      };\n    }\n  }\n\n  /**\n   * Associates the value with the specified serialized path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItem(serializedPath: string, value: TItem): this {\n    return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);\n  }\n\n  /**\n   * Associates the value with the specified path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this {\n    let node: IPathTrieNode<TItem> = this._root;\n    for (const segment of pathSegments) {\n      if (!node.children) {\n        node.children = new Map();\n      }\n      let child: IPathTrieNode<TItem> | undefined = node.children.get(segment);\n      if (!child) {\n        node.children.set(\n          segment,\n          (child = {\n            value: undefined,\n            children: undefined\n          })\n        );\n      }\n      node = child;\n    }\n    node.value = value;\n\n    return this;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findChildPath(childPath: string): TItem | undefined {\n    return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findLongestPrefixMatch(query: string): IPrefixMatch<TItem> | undefined {\n    return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, this.delimiter));\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined {\n    let node: IPathTrieNode<TItem> = this._root;\n    let best: TItem | undefined = node.value;\n    // Trivial cases\n    if (node.children) {\n      for (const segment of childPathSegments) {\n        const child: IPathTrieNode<TItem> | undefined = node.children.get(segment);\n        if (!child) {\n          break;\n        }\n        node = child;\n        best = node.value ?? best;\n        if (!node.children) {\n          break;\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public groupByChild<TInfo>(infoByPath: Map<string, TInfo>): Map<TItem, Map<string, TInfo>> {\n    const groupedInfoByChild: Map<TItem, Map<string, TInfo>> = new Map();\n\n    for (const [path, info] of infoByPath) {\n      const child: TItem | undefined = this.findChildPath(path);\n      if (child === undefined) {\n        continue;\n      }\n      let groupedInfo: Map<string, TInfo> | undefined = groupedInfoByChild.get(child);\n      if (!groupedInfo) {\n        groupedInfo = new Map();\n        groupedInfoByChild.set(child, groupedInfo);\n      }\n      groupedInfo.set(path, info);\n    }\n\n    return groupedInfoByChild;\n  }\n\n  /**\n   * Iterates through progressively longer prefixes of a given string and returns as soon\n   * as the number of candidate items that match the prefix are 1 or 0.\n   *\n   * If a match is present, returns the matched itme and the length of the matched prefix.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   */\n  private _findLongestPrefixMatch(prefixes: Iterable<IPrefixEntry>): IPrefixMatch<TItem> | undefined {\n    let node: IPathTrieNode<TItem> = this._root;\n    let best: IPrefixMatch<TItem> | undefined = node.value\n      ? {\n          value: node.value,\n          index: 0,\n          lastMatch: undefined\n        }\n      : undefined;\n    // Trivial cases\n    if (node.children) {\n      for (const { prefix: hash, index } of prefixes) {\n        const child: IPathTrieNode<TItem> | undefined = node.children.get(hash);\n        if (!child) {\n          break;\n        }\n        node = child;\n        if (node.value !== undefined) {\n          best = {\n            value: node.value,\n            index,\n            lastMatch: best\n          };\n        }\n        if (!node.children) {\n          break;\n        }\n      }\n    }\n\n    return best;\n  }\n}\n"]}